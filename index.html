<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-17KR2JJYTY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-17KR2JJYTY');
</script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta property="og:title" content="TRONS">
    <meta property="og:description" content="The first AI-powered game that generated itself.">
    <meta property="og:image" content="https://einsteins.xyz/meta.png">
    <meta property="og:image:alt" content="TRONS">
    <meta property="og:url" content="https://trons.io">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="TRONS">
    <meta property="og:locale" content="en_US">


    <title id="gameTitle">TRONS</title>
    <link rel="icon" href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">ðŸ”´</text></svg>' type="image/svg+xml">

    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400..700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">


    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <!-- Firebase 11 SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.10.0/firebase-app.js';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.10.0/firebase-auth.js';
        import { getFirestore, doc, getDoc, setDoc, updateDoc } from 'https://www.gstatic.com/firebasejs/11.10.0/firebase-firestore.js';
        import { getAnalytics } from 'https://www.gstatic.com/firebasejs/11.10.0/firebase-analytics.js';
        
        // Make Firebase functions available globally
        window.firebase = { initializeApp, getAuth, signInAnonymously, onAuthStateChanged, getFirestore, getAnalytics, doc, getDoc, setDoc, updateDoc };
    </script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column; /* Allow column layout for header/game/footer */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            /* Mr. Terrific color scheme - dark background with red accents */
            background: #1a0000; /* Deep black-red background */
            color: #ff3333; /* Mr. Terrific red text */
            font-family: 'Orbitron', sans-serif; /* Futuristic font for UI */
            position: relative; /* Needed for background pseudo-element */
        }

        /* Background Video Styling */
        #background-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: -2; /* Behind everything */
            opacity: 0.7; /* Slightly transparent */
        }

        /* Video Overlay for Better Text Readability */
        .video-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent; /* Remove overlay */
            z-index: -1; /* Above video, behind UI */
            pointer-events: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            flex-grow: 1; /* Allow canvas to take up available space */
            position: absolute; /* Ensure canvas is part of the layout flow for z-indexing */
            top: 0;
            left: 0;
            z-index: 1; /* Game canvas behind UI overlays but above body background */
        }

        /* Full screen overlays for start and game over */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            z-index: 50; /* Above game elements */
            background-color: rgba(0, 0, 0, 0.4); /* More transparent for particle background */
        }

        #start-screen {
            /* Styles for H1 moved for cyberpunk effect */
            padding-bottom: 15vh; /* Pushes content up from the center */
        }

        #start-screen h1 {
            font-family: 'Orbitron', sans-serif; /* Changed from 'Press Start 2P' for a crisper look */
            font-weight: 700;
            font-size: 6.75vw; /* Slightly larger for impact */
            color: #fff; /* Bright white for high contrast */
            text-shadow: 
                0 0 1px #fff, 
                0 0 3px #ff3333, /* Mr. Terrific red glow */
                0 0 8px #ff3333;
            position: relative;
            animation: flicker 8s infinite alternate;
        }

        .blinking-cursor {
            color: #ff3333;
            text-shadow: 0 0 5px #ff3333;
            animation: blink 1s steps(2) infinite;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        #start-screen h1::before,
        #start-screen h1::after,
        #game-over-screen h1::before,
        #game-over-screen h1::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            overflow: hidden;
        }

        #start-screen h1::before,
        #game-over-screen h1::before {
            left: -2px;
            text-shadow: -2px 0 #ff00ff;
            animation: glitch-before 6s infinite linear alternate-reverse;
        }

        #start-screen h1::after,
        #game-over-screen h1::after {
            left: 2px;
            text-shadow: -2px 0 #00c2cb, 2px 2px #ff00ff;
            animation: glitch-after 5s infinite linear alternate-reverse;
        }

        @keyframes glitch-before {
            0% { clip-path: inset(83% 0 1% 0); transform: translateX(-0.05em); }
            10% { clip-path: inset(45% 0 40% 0); }
            20% { clip-path: inset(62% 0 31% 0); }
            30% { clip-path: inset(21% 0 71% 0); }
            40% { clip-path: inset(88% 0 5% 0); }
            50% { clip-path: inset(40% 0 51% 0); transform: translateX(0.05em); }
            60% { clip-path: inset(6% 0 88% 0); }
            70% { clip-path: inset(93% 0 4% 0); }
            80% { clip-path: inset(45% 0 45% 0); }
            90% { clip-path: inset(10% 0 80% 0); }
            100% { clip-path: inset(64% 0 27% 0); transform: translateX(0.05em); }
        }

        @keyframes glitch-after {
            0% { clip-path: inset(84% 0 13% 0); transform: translateX(0.05em); }
            10% { clip-path: inset(59% 0 25% 0); }
            20% { clip-path: inset(4% 0 88% 0); }
            30% { clip-path: inset(67% 0 17% 0); }
            40% { clip-path: inset(36% 0 58% 0); }
            50% { clip-path: inset(20% 0 77% 0); transform: translateX(-0.05em); }
            60% { clip-path: inset(79% 0 1% 0); }
            70% { clip-path: inset(44% 0 47% 0); }
            80% { clip-path: inset(92% 0 2% 0); }
            90% { clip-path: inset(14% 0 76% 0); }
            100% { clip-path: inset(64% 0 27% 0); transform: translateX(0.05em); }
        }

        @keyframes flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow:
                    0 0 1px #fff, 
                    0 0 4px #00ffff, 
                    0 0 10px #00ffff, 
                    0 0 20px #00ffff, 
                    0 0 40px #ff00ff, /* Keep some magenta for the flicker effect */
                    0 0 50px #ff00ff;
            }
            20%, 24%, 55% {       
                text-shadow: none;
            }
        }

        @keyframes flicker-red {
            0%, 18%, 22%, 25%, 53%, 57%, 100% {
                text-shadow:
                    0 0 1px #fff,
                    0 0 4px #ff0055,
                    0 0 10px #ff0055,
                    0 0 20px #ff0055,
                    0 0 40px #ff0000,
                    0 0 50px #ff0000;
            }
            20%, 24%, 55% {
                text-shadow: none;
            }
        }

        /* Scanline Overlay */
        #start-screen::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 51;
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
            animation: scanline-anim 12s linear infinite;
        }
        
        @keyframes scanline-anim {
            from { background-position: 0 0; }
            to { background-position: 0 100%; }
        }

        #game-over-screen {
            color: #ff0055; /* Neon Pink */
            text-shadow: none; /* This is now on the h1 */
            display: none; /* Hidden by default */
            padding-bottom: 15vh; /* Pushes content up from the center */
        }

        #game-over-screen h1 {
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            font-size: 3.375vw;
            color: #ff2222; /* A bright, crisp red */
            text-shadow:
                0 0 1px #fff,
                0 0 3px #ff0055,
                0 0 8px #ff0055;
            position: relative;
            animation: flicker-red 8s infinite alternate;
        }

        .overlay h1 {
            font-size: 3em;
            margin-bottom: 20px;
        }

        .overlay p {
            font-size: 1em;
            margin-bottom: 10px; /* Reduced margin */
            color: #ffffff; /* White text for info */
            text-shadow: none;
        }

        .overlay button {
            font-family: 'Press Start 2P', cursive;
            font-size: 1em;
            /* Adjusted padding to decrease size by roughly 50% */
            padding: 7.5px 15px; /* Half of 15px 30px */
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        /* Enhanced Start Screen Styling */
        .star-wars-logo {
            margin-bottom: 30px;
            animation: logoGlow 3s ease-in-out infinite alternate;
        }
        
        .logo-text {
            font-size: 3.5em;
            color: #ffff00;
            text-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
            margin: 0;
            letter-spacing: 3px;
        }
        
        .custom-game-name {
            font-size: 2.2em;
            color: #ff3333;
            text-shadow: 0 0 15px rgba(255, 51, 51, 0.8);
            margin: 15px 0 5px 0;
            letter-spacing: 2px;
            font-weight: bold;
            animation: customNameGlow 2s ease-in-out infinite alternate;
        }
        
        @keyframes customNameGlow {
            0% { 
                text-shadow: 0 0 15px rgba(255, 51, 51, 0.8);
                transform: scale(1);
            }
            100% { 
                text-shadow: 0 0 25px rgba(255, 51, 51, 1), 0 0 35px rgba(255, 51, 51, 0.6);
                transform: scale(1.02);
            }
        }
        
        .logo-subtitle {
            font-size: 4em;
            color: #ff3333;
            text-shadow: 0 0 25px rgba(255, 51, 51, 0.8);
            margin: 10px 0 0 0;
            letter-spacing: 5px;
            font-weight: bold;
        }
        
        .game-description {
            margin: 20px 0 30px 0;
        }
        
        .main-desc {
            font-size: 1.4em;
            margin: 0;
            color: #ffffff;
        }
        
        .highlight {
            color: #ff3333;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 51, 51, 0.8);
        }
        
        .sub-desc {
            font-size: 1.1em;
            color: #888;
            margin: 10px 0 0 0;
        }
        
        .controls-section {
            background: rgba(20, 0, 0, 0.7);
            border: 2px solid #ff3333;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            min-width: 300px;
        }
        
        .controls-section h3 {
            color: #ff3333;
            margin: 0 0 15px 0;
            font-size: 1.3em;
        }
        
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .control-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        
        .key {
            background: #333;
            color: #ffff00;
            padding: 4px 8px;
            border-radius: 3px;
            font-family: monospace;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .action {
            color: #ffffff;
            font-size: 0.9em;
        }
        
        .difficulty-section {
            margin: 20px 0;
        }
        
        .difficulty-section h3 {
            color: #ffff00;
            margin: 0 0 15px 0;
        }
        
        .difficulty-options {
            display: flex;
            gap: 10px;
        }
        
        .difficulty-btn {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #666;
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .difficulty-btn:hover {
            border-color: #00ffff;
            background: rgba(0, 255, 255, 0.1);
        }
        
        .difficulty-btn.active {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
        }
        
        .start-btn {
            background: linear-gradient(45deg, #ff4444, #ff8800);
            border: 3px solid #ffff00;
            color: #ffffff;
            padding: 15px 30px;
            font-size: 1.4em;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            margin: 20px 0;
            transition: all 0.3s ease;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }
        
        .start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.8);
        }
        
        .tips-section {
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #00ff00;
        }
        
        .tip {
            margin: 5px 0;
            font-size: 0.9em;
            color: #ccc;
        }
        
        @keyframes logoGlow {
            0% { transform: scale(1); }
            100% { transform: scale(1.02); }
        }

        /* Menu Buttons */
        .menu-buttons {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .menu-btn {
            padding: 12px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ffff;
            color: #00ffff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            font-size: 0.9em;
            min-width: 120px;
        }

        .menu-btn:hover {
            background: rgba(0, 255, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }

        .current-difficulty {
            margin-top: 15px;
            color: #ffff00;
            font-size: 0.9em;
            text-shadow: 0 0 10px rgba(255, 255, 0, 0.8);
        }

        /* Modal Styling */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal-content {
            background: radial-gradient(circle, rgba(0,20,40,0.95) 0%, rgba(0,10,20,0.98) 100%);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: modalSlideIn 0.3s ease-out;
            box-shadow: 0 0 50px rgba(0,255,255,0.5);
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: scale(0.9) translateY(-20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #00ffff;
            padding-bottom: 15px;
        }

        .modal-header h3 {
            color: #00ffff;
            margin: 0;
            font-size: 1.3em;
        }

        .close-btn {
            background: none;
            border: none;
            color: #ff4444;
            font-size: 2em;
            cursor: pointer;
            transition: color 0.3s ease;
            line-height: 1;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: #ff0000;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }

        /* Modal specific styling */
        .mobile-info {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 4px solid #00ff00;
        }

        .mobile-info h4 {
            color: #00ff00;
            margin: 0 0 10px 0;
            font-size: 1.1em;
        }

        .mobile-info p {
            margin: 5px 0;
            color: #ccc;
            font-size: 0.9em;
        }

        /* Enhanced difficulty modal */
        .difficulty-btn {
            display: block;
            width: 100%;
            margin: 10px 0;
            padding: 15px;
            text-align: left;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #666;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .difficulty-btn:hover {
            border-color: #00ffff;
            background: rgba(0, 255, 255, 0.1);
        }

        .difficulty-btn.active {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.2);
        }

        .diff-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .diff-desc {
            font-size: 0.9em;
            color: #ccc;
            line-height: 1.3;
        }

        .difficulty-btn.active .diff-name {
            color: #00ff00;
        }

        /* Tips modal styling */
        .tips-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .tip-item {
            display: flex;
            gap: 15px;
            align-items: flex-start;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border-left: 4px solid #00ffff;
        }

        .tip-icon {
            font-size: 1.5em;
            min-width: 30px;
        }

        .tip-item strong {
            color: #ffff00;
            text-shadow: 0 0 10px rgba(255, 255, 0, 0.8);
        }

        /* Mission Stats Button Styling */
        .mission-stats-btn {
            padding: 15px 20px;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
            color: #00ff00;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.1em;
            width: 160px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            box-sizing: border-box;
        }

        .mission-stats-btn:hover {
            background: rgba(0, 255, 0, 0.4);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
            transform: translateY(-2px);
            text-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
        }

        #start-button {
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.3), rgba(0, 153, 255, 0.4), rgba(0, 255, 255, 0.3));
            background-size: 200% 200%;
            color: #ffffff;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 
                0 0 20px rgba(0, 255, 255, 0.6),
                inset 0 2px 0 rgba(255, 255, 255, 0.3);
            border: 2px solid #00ffff;
            animation: hyperspacePulse 2s ease-in-out infinite alternate;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
        }
        
        @keyframes hyperspacePulse {
            0% { 
                background-position: 0% 50%;
                box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            }
            100% { 
                background-position: 100% 50%;
                box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
            }
        }
        
        #start-button:hover {
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.6), rgba(255, 255, 255, 0.4), rgba(0, 255, 255, 0.6));
            transform: scale(1.05);
            box-shadow: 
                0 0 40px rgba(0, 255, 255, 0.8),
                inset 0 2px 0 rgba(255, 255, 255, 0.5);
        }

        #restart-button {
            background-color: #ff00ff; /* Neon Magenta */
            color: #0a0a0a;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
            margin-top: 20px;
        }
         #restart-button:hover {
            background-color: #cc00cc;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.7);
         }

         /* Footer styles */
         .game-footer {
             position: absolute;
             bottom: 0;
             left: 0;
             width: 100%;
             /* Reduced padding to decrease size */
             padding: 4px 20px; /* Reduced padding, added horizontal padding */
             background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent dark background */
             color: #00ffff; /* Neon Aqua text */
             font-family: 'Orbitron', sans-serif;
             font-size: 0.7em;
             /* Changed to flexbox for alignment */
             display: flex; /* Use flexbox */
             justify-content: space-between; /* Space between copyright and social links */
             align-items: center; /* Vertically center items */
             z-index: 10; /* Above canvas, below overlays */
             box-sizing: border-box; /* Include padding in width */
         }

         .copyright {
             margin-bottom: 0;
         }

         .social-links-container {
             display: flex; /* Use flexbox to arrange icons horizontally */
             gap: 10px; /* Reduced space between icons */
             align-items: center; /* Vertically center icons */
         }

         .social-link {
             color: #00ffff; /* Neon Aqua for link */
             text-decoration: none;
             text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
             transition: color 0.3s ease, text-shadow 0.3s ease;
             display: flex; /* Use flex to center SVG within link */
             justify-content: center;
             align-items: center;
         }

         .social-link:hover {
             color: #ffffff; /* White on hover */
             text-shadow: 0 0 8px rgba(255, 255, 255, 0.7);
         }

         .social-link svg {
             width: 18px; /* Reduced icon size */
             height: 18px; /* Reduced icon size */
             fill: currentColor; /* Use the link's text color for the icon fill */
         }

         /* Social Media Section in Modals */
         .social-media-section {
             margin-top: 20px;
             padding-top: 15px;
             border-top: 1px solid rgba(0, 255, 255, 0.3);
             text-align: center;
         }

         .social-title {
             font-family: 'Orbitron', sans-serif;
             font-size: 0.9em;
             color: #00ffff;
             margin-bottom: 15px;
             text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
         }

         .social-icons {
             display: flex;
             justify-content: center;
             gap: 20px;
             flex-wrap: wrap;
         }

         .social-icons .social-link {
             display: flex;
             align-items: center;
             gap: 8px;
             padding: 8px 12px;
             background: rgba(0, 255, 255, 0.1);
             border: 1px solid rgba(0, 255, 255, 0.3);
             border-radius: 15px;
             transition: all 0.3s ease;
             text-decoration: none;
             color: #00ffff;
             font-family: 'Orbitron', sans-serif;
             font-size: 0.85em;
         }

         .social-icons .social-link:hover {
             background: rgba(0, 255, 255, 0.2);
             border-color: #00ffff;
             transform: translateY(-2px);
             box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3);
         }

         .social-icon {
             font-size: 1.2em;
         }

         .social-text {
             font-weight: 500;
         }


        /* Game UI elements */
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9em;
            color: #00ffff;
            text-shadow: 2px 2px #000, 0 0 10px rgba(0, 255, 255, 0.5);
            z-index: 10;
        }

        #jackpot {
             position: absolute;
             top: 20px;
             left: 20px;
             font-family: 'Press Start 2P', cursive;
             font-size: 0.8em;
             color: #ffffff;
             text-shadow: 2px 2px #000, 0 0 10px rgba(0, 255, 255, 0.7), 0 0 20px rgba(0, 255, 255, 0.5);
             z-index: 10;
             display: flex;
             flex-direction: column;
             align-items: flex-start;
        }

        #jackpot .game-demo-tag {
             font-size: 0.5em;
             color: #ff00ff;
             text-shadow: none;
             margin-top: 5px;
        }

        #jackpot-amount {
            color: #ffff00;
            text-shadow: 2px 2px #000, 0 0 10px rgba(255, 255, 0, 0.7), 0 0 20px rgba(255, 255, 0, 0.5);
            margin-top: 5px;
        }

        #level-display {
            position: absolute;
            top: 40px;
            right: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.9em;
            color: #ffff00;
            text-shadow: 2px 2px #000, 0 0 10px rgba(255, 255, 0, 0.5);
            z-index: 10;
        }

        #dialogue-box {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7em;
            background-color: rgba(0, 0, 0, 0.7);
            color: #00ffff;
            padding: 10px 15px;
            border: 2px solid #00ffff;
            border-radius: 10px;
            z-index: 15;
            max-width: 80%;
            text-align: center;
            display: none;
            pointer-events: none;
        }

        #boost-button {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.32em;
            padding: 10px 15px;
            background-color: #ff00ff;
            color: #0a0a0a;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);
            transition: background-color 0.3s ease;
        }
        #boost-button:hover:not(:disabled) {
            background-color: #cc00cc;
        }
         #boost-button:disabled {
            background-color: #555555;
            cursor: not-allowed;
            box-shadow: none;
         }

         #blaster-button {
            position: absolute;
            bottom: 20px;
            left: calc(50% + 120px);
            transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.32em;
            padding: 10px 15px;
            background-color: #0066ff;
            color: #ffffff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(0, 102, 255, 0.5);
            transition: background-color 0.3s ease;
         }

         #blaster-button:hover:not(:disabled) {
            background-color: #0044cc;
            box-shadow: 0 0 15px rgba(0, 102, 255, 0.8);
         }

         #blaster-button:disabled {
            background-color: #555555;
            cursor: not-allowed;
            box-shadow: none;
         }

         #mini-boost-button {
            position: absolute;
            bottom: 20px;
            left: calc(50% - 120px);
            transform: translateX(-50%);
            font-family: 'Press Start 2P', cursive;
            font-size: 0.32em;
            padding: 10px 15px;
            background-color: #00ff00;
            color: #000000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            z-index: 10;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
            transition: background-color 0.3s ease;
         }

         #mini-boost-button:hover:not(:disabled) {
            background-color: #00cc00;
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
         }



         #mini-boost-button:disabled {
            background-color: #555555;
            cursor: not-allowed;
            box-shadow: none;
         }

         #lightning-flash {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             background-color: rgba(255, 255, 255, 0.8);
             z-index: 30;
             pointer-events: none;
             display: none;
         }

         #level-up-popup {
             position: absolute;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             font-family: 'Press Start 2P', cursive;
             font-size: 3em;
             color: #ffff00;
             text-shadow: 3px 3px #000, 0 0 20px rgba(255, 255, 0, 0.8);
             z-index: 25;
             display: none;
             text-align: center;
             animation: pulse 1.5s infinite alternate;
         }

         @keyframes pulse {
             from {
                 opacity: 0;
                 transform: translate(-50%, -50%) scale(1);
             }
             to {
                 opacity: 1;
                 transform: translate(-50%, -50%) scale(1.1);
             }
         }

         .mobile-controls {
             position: fixed;
             top: 50%;
             transform: translateY(-50%);
             width: 100%;
             display: none; /* Start hidden, will be shown by JS on mobile */
             justify-content: space-between;
             align-items: center;
             padding: 0 20px;
             z-index: 1001;
             pointer-events: none; /* Allow clicks to pass through container */
         }

         .mobile-controls button {
             width: 90px;
             height: 90px;
             font-size: 2.5em;
             background-color: rgba(0, 0, 0, 0.7);
             color: #ffffff;
             border: 3px solid #00ffff;
             border-radius: 50%;
             display: flex;
             justify-content: center;
             align-items: center;
             cursor: pointer;
             box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
             transition: all 0.2s ease;
             font-family: 'Press Start 2P', cursive;
             font-weight: bold;
             text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
             pointer-events: auto; /* Re-enable clicks for buttons */
             touch-action: manipulation; /* Optimize for touch */
             user-select: none;
             -webkit-user-select: none;
         }

         .mobile-controls button:hover {
             background-color: rgba(0, 255, 255, 0.4);
             border-color: #ffff00;
             box-shadow: 0 0 25px rgba(0, 255, 255, 0.9);
         }

         .mobile-controls button:active,
         .mobile-controls button.active {
             background-color: rgba(0, 255, 255, 0.6);
             transform: scale(0.95);
             border-color: #ffff00;
             box-shadow: 0 0 30px rgba(0, 255, 255, 1);
         }

         .mobile-controls button:disabled {
             background-color: rgba(85, 85, 85, 0.5);
             border-color: #555555;
             color: #666;
             cursor: not-allowed;
             box-shadow: none;
         }

         /* Hide mobile controls on desktop */
         @media (min-width: 768px) {
             .mobile-controls {
                 display: none !important;
             }
         }

         #use-power-up-button {
             position: fixed;
             bottom: 30px;
             left: 50%;
             transform: translateX(-50%);
             width: 140px;
             height: 70px;
             font-size: 1em;
             background-color: rgba(255, 0, 100, 0.8);
             color: #ffffff;
             padding: 10px 15px;
             border: 3px solid #ff00ff;
             border-radius: 15px;
             display: none;
             justify-content: center;
             align-items: center;
             cursor: pointer;
             z-index: 1001;
             font-family: 'Press Start 2P', cursive;
             text-align: center;
             line-height: 1.2;
             box-sizing: border-box;
             transition: all 0.2s ease;
             font-weight: bold;
             text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
             box-shadow: 0 0 15px rgba(255, 0, 255, 0.6);
             touch-action: manipulation;
             user-select: none;
             -webkit-user-select: none;
         }

         #use-power-up-button:hover {
             background-color: rgba(255, 0, 100, 1);
             border-color: #ffff00;
             box-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
         }

         #use-power-up-button:active {
             background-color: rgba(255, 0, 100, 1);
             transform: scale(0.9);
             border-color: #ffff00;
             box-shadow: 0 0 25px rgba(255, 0, 255, 1);
         }

         #use-power-up-button:disabled {
             background-color: rgba(85, 85, 85, 0.5);
             border-color: #555555;
             color: #b0b0b0;
             cursor: not-allowed;
             box-shadow: none;
         }

         /* Removed welcome-message styles */

         #power-up-display {
             position: absolute;
             top: 60px;
             right: 20px;
             font-family: 'Press Start 2P', cursive;
             font-size: 0.8em;
             color: #00ff00;
             text-shadow: 0 0 5px #00ff00, 0 0 15px #00ff00;
             z-index: 10;
             display: none;
        }

        /* Settings Menu */
        #settings-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 20px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.6em;
            color: #00ffff;
            z-index: 100;
            display: none;
            min-width: 400px;
        }

        #settings-menu h2 {
            text-align: center;
            margin-bottom: 20px;
            color: #ffff00;
            text-shadow: 0 0 10px #ffff00;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 5px;
        }

        .setting-label {
            color: #ffffff;
            min-width: 120px;
        }

        .setting-value {
            color: #00ff00;
            text-shadow: 0 0 5px #00ff00;
            min-width: 100px;
            text-align: right;
        }

        .setting-controls {
            font-size: 0.5em;
            color: #888888;
            margin-top: 20px;
            line-height: 1.5;
        }

        #social-display {
            position: absolute;
            bottom: 4px;
            right: 20px;
            font-family: 'Inter', sans-serif;
            font-size: 0.8em;
            z-index: 15;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 12px 16px;
            border-radius: 8px;
            display: block;
            border: 1px solid rgba(0, 255, 255, 0.3);
        }

        #social-display a {
            transition: all 0.3s ease;
        }

        #social-display a:hover {
            transform: translateY(-2px);
            text-shadow: 0 0 10px currentColor;
        }

        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 50;
            font-family: 'Press Start 2P', cursive;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            font-size: 2em;
            text-align: center;
        }

        #pause-overlay .pause-text {
            animation: pulse 2s infinite;
        }

        @keyframes pausePulse {
            0% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
            100% { opacity: 0.7; transform: scale(1); }
        }

        @keyframes powerUpPulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        @keyframes powerUpGlow {
            0% { filter: drop-shadow(0 0 5px currentColor); }
            50% { filter: drop-shadow(0 0 15px currentColor); }
            100% { filter: drop-shadow(0 0 5px currentColor); }
        }

        .power-up-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 40px;
            height: 40px;
            margin: 5px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            font-size: 24px;
            animation: powerUpPulse 1.5s infinite, powerUpGlow 2s infinite;
            transition: all 0.3s ease;
        }

        .power-up-icon:hover {
            transform: scale(1.1);
        }

        .power-up-container {
            position: absolute;
            top: 100px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        .power-up-row {
            display: flex;
            gap: 5px;
        }



        .share-button {
            background-color: #1DA1F2;
            color: white;
            border: none;
            border-radius: 20px;
            padding: 10px 20px;
            margin-top: 15px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.7em;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.3s ease;
        }

        .share-button:hover {
            background-color: #1991db;
        }

        .share-button svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        /* --- UI/UX POLISH ANIMATIONS --- */
        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.25); }
            100% { transform: scale(1); }
        }
        @keyframes flash {
            0% { background-color: rgba(255,255,0,0.3); }
            100% { background-color: transparent; }
        }
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 0px #00ff00; }
            50% { box-shadow: 0 0 20px #00ff00; }
            100% { box-shadow: 0 0 0px #00ff00; }
        }
        @keyframes shake {
            0% { transform: translateX(0); }
            25% { transform: translateX(-4px); }
            50% { transform: translateX(4px); }
            75% { transform: translateX(-4px); }
            100% { transform: translateX(0); }
        }
        .animated-pop { animation: pop 0.3s; }
        .animated-flash { animation: flash 0.4s; }
        .animated-pulse { animation: pulse-glow 0.8s; }
        .animated-shake { animation: shake 0.3s; }

        /* --- CSS for the Particle Background --- */
        #particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 25; /* Below overlays (z-index: 50), above main canvas (z-index: 1) */
            pointer-events: none;
            display: none; /* Only show when overlays are visible */
        }
    </style>
</head>
<body>
    <!-- Background Video Layer -->
    <video id="background-video" autoplay muted loop playsinline>
        <source src="CYPHES.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>
    
    <!-- Video Overlay for Darkening -->
    <div class="video-overlay"></div>
    
    <div id="start-screen" class="overlay">
        <button id="start-button" class="start-btn">ðŸ”´ ENTER ðŸ”´</button>
        
        <div class="menu-buttons">
            <button class="menu-btn" id="difficulty-btn">âš¡ Difficulty</button>
            <button class="menu-btn" id="controls-btn">ðŸŽ® Controls</button>
            <button class="menu-btn" id="tips-btn">ðŸ’¡ Tips</button>
        </div>
    </div>

    <!-- Controls Modal -->
    <div id="controls-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>ðŸŽ® Controls</h3>
                <button class="close-btn" data-modal="controls-modal">&times;</button>
            </div>
            <div class="controls-grid">
                <div class="control-item">
                    <span class="key">ARROWS</span>
                    <span class="action">Steer TRONS lightcycle</span>
                </div>
                <div class="control-item">
                    <span class="key">SPACE</span>
                    <span class="action">DISCO jump</span>
                </div>
                <div class="control-item">
                    <span class="key">E</span>
                    <span class="action">Use DISCO power</span>
                </div>
                <div class="control-item">
                    <span class="key">M</span>
                    <span class="action">Toggle audio</span>
                </div>
                <div class="control-item">
                    <span class="key">P</span>
                    <span class="action">Pause game</span>
                </div>
                <div class="control-item">
                    <span class="key">â†‘</span>
                    <span class="action">Boost (Level 5+)</span>
                </div>
                <div class="control-item">
                    <span class="key">S</span>
                    <span class="action">BOOST (+25% speed)</span>
                </div>
                <div class="control-item">
                    <span class="key">F</span>
                                                    <span class="action">VIBES (Level 10+)</span>
                </div>
            </div>
            <div class="mobile-info">
                <h4>ðŸ“± Mobile Controls</h4>
                <p>â€¢ Touch buttons for steering</p>
                <p>â€¢ Swipe left/right to steer</p>
                <p>â€¢ Dedicated power-up button</p>
            </div>
        </div>
    </div>

    <!-- Difficulty Modal -->
    <div id="difficulty-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>âš¡ Difficulty Selection</h3>
                <button class="close-btn" data-modal="difficulty-modal">&times;</button>
            </div>
            <div class="difficulty-options">
                <button class="difficulty-btn active" data-difficulty="normal">
                    <div class="diff-name">Normal</div>
                    <div class="diff-desc">Balanced gameplay for all heroes</div>
                </button>
                <button class="difficulty-btn" data-difficulty="hard">
                    <div class="diff-name">Hard</div>
                    <div class="diff-desc">50% faster criminals, less margin for error</div>
                </button>
                <button class="difficulty-btn" data-difficulty="insane">
                    <div class="diff-name">Insane</div>
                    <div class="diff-desc">Double-speed chaos, only for Fair Play Masters</div>
                </button>
            </div>
        </div>
    </div>

    <!-- Tips Modal -->
    <div id="tips-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3>ðŸ’¡ Pro Tips</h3>
                <button class="close-btn" data-modal="tips-modal">&times;</button>
            </div>
            <div class="tips-content">
                <div class="tip-item">
                    <span class="tip-icon">ðŸŽµ</span>
                    <div>
                        <strong>Audio Control:</strong><br>
                        Audio is OFF by default. Press 'M' anytime to enable immersive TRONS sounds.
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">ðŸŒŒ</span>
                    <div>
                        <strong>DISCO Acceleration:</strong><br>
                        Reach maximum speed to trigger spectacular technological effects!
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">ðŸ”´</span>
                    <div>
                        <strong>DISCO Powers:</strong><br>
                        Collect energy boxes to gain TRONS abilities: Stealth Mode, Fair Play, LASER STRIKE, and more!
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">âšª</span>
                    <div>
                        <strong>Fair Play Mode:</strong><br>
                        Turn white to destroy criminal competitors on contact (+30 ETHER each). Lasts 6 seconds.
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">ðŸ”´</span>
                    <div>
                        <strong>DISCO STRIKE:</strong><br>
                        Fire cyan DISCO projectiles at enemies (+20 ETHER). Press 'E' to deploy!
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">ðŸŽ¯</span>
                    <div>
                        <strong>Scoring Strategy:</strong><br>
                        Collect Degree crystals (+1), hunt criminals with Fair Play (+30), use DISCO powers wisely!
                    </div>
                </div>
                <div class="tip-item">
                    <span class="tip-icon">âš¡</span>
                    <div>
                        <strong>Speed Control:</strong><br>
                        Use 'S' for unlimited boosts (+25% speed). Use 'F' for VIBES power (level 10+) that destroys enemies for +15 ETHER!
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="game-over-screen" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 style="font-size: 1.6em;">ðŸ“Š Mission Stats</h3>
            </div>
            
            <!-- Mission Stats Section -->
            <div class="tips-content">
                <div class="tip-item">
                    <span class="tip-icon" style="font-size: 2em;">ðŸ“ˆ</span>
                    <div>
                        <strong style="font-size: 1.2em;">Performance Metrics</strong><br>
                        <div class="controls-grid" style="margin-top: 15px; gap: 15px;">
                            <div class="control-item" style="padding: 12px; font-size: 1.1em;">
                                <span class="key" style="font-size: 1em; padding: 6px 12px;">â±ï¸ Mission Time</span>
                                <span class="action" id="stat-time" style="font-size: 1.1em; font-weight: bold; color: #00ffff;">0:00</span>
                            </div>
                            <div class="control-item" style="padding: 12px; font-size: 1.1em;">
                                <span class="key" style="font-size: 1em; padding: 6px 12px;">ðŸš€ Distance</span>
                                <span class="action" id="stat-distance" style="font-size: 1.1em; font-weight: bold; color: #00ffff;">0</span>
                            </div>
                            <div class="control-item" style="padding: 12px; font-size: 1.1em;">
                                <span class="key" style="font-size: 1em; padding: 6px 12px;">ðŸ”´ ETHER Collected</span>
                                <span class="action" id="stat-ether" style="font-size: 1.1em; font-weight: bold; color: #ffff00;">0</span>
                            </div>
                            <div class="control-item" style="padding: 12px; font-size: 1.1em;">
                                <span class="key" style="font-size: 1em; padding: 6px 12px;">âš”ï¸ Enemies Defeated</span>
                                <span class="action" id="stat-enemies" style="font-size: 1.1em; font-weight: bold; color: #ff6666;">0</span>
                            </div>
                            <div class="control-item" style="padding: 12px; font-size: 1.1em;">
                                <span class="key" style="font-size: 1em; padding: 6px 12px;">âš¡ Power-Ups Used</span>
                                <span class="action" id="stat-powerups" style="font-size: 1.1em; font-weight: bold; color: #ff00ff;">0</span>
                            </div>
                            <div class="control-item" style="padding: 12px; font-size: 1.1em;">
                                <span class="key" style="font-size: 1em; padding: 6px 12px;">ðŸŒŒ DISCO Jumps</span>
                                <span class="action" id="stat-jumps" style="font-size: 1.1em; font-weight: bold; color: #8844ff;">0</span>
                            </div>
                        </div>
                        <div style="margin-top: 15px; text-align: center;">
                            <div class="control-item" style="padding: 12px; font-size: 1.1em; background: rgba(0, 255, 0, 0.1); border: 1px solid #00ff00;">
                                <span class="key" style="font-size: 1em; padding: 6px 12px; background: #00ff00; color: #000;">ðŸƒ Max Speed Achieved</span>
                                <span class="action" id="stat-speed" style="font-size: 1.2em; font-weight: bold; color: #00ff00;">Mach 0.0</span>
                            </div>
                        </div>
                        <div style="margin-top: 15px; text-align: center;">
                            <div class="control-item" style="padding: 12px; font-size: 1.1em; background: rgba(255, 255, 0, 0.1); border: 1px solid #ffff00;">
                                <span class="key" style="font-size: 1em; padding: 6px 12px; background: #ffff00; color: #000;">âš¡ Frame Rate</span>
                                <span class="action" id="stat-fps" style="font-size: 1.2em; font-weight: bold; color: #ffff00;">60 FPS</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="tip-item">
                    <span class="tip-icon" style="font-size: 2em;">ðŸ†</span>
                    <div style="display: flex; align-items: flex-start; gap: 30px;">
                        <div style="flex: 1;">
                            <strong style="font-size: 1.2em;">Final Results</strong><br>
                            <div style="margin-top: 15px;">
                                <p id="final-score" style="margin: 10px 0; color: #ff3333; font-size: 1.2em; font-weight: bold;">Final ETHER: 0</p>
                                <p id="final-level" style="margin: 10px 0; color: #ff3333; font-size: 1.2em; font-weight: bold;">Sector Reached: 1</p>

                            </div>
                        </div>
                        <!-- Action Buttons Column -->
                        <div style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
                            <!-- Buttons Row -->
                            <div style="display: flex; gap: 15px; align-items: center;">
                                <button id="restart-button" class="mission-stats-btn">ðŸš€ New Mission</button>
                                <button id="twitter-share-button" class="mission-stats-btn" style="background: #1da1f2; font-size: 0.9em;">
                                    ðŸ¦ Share on Twitter
                                </button>
                            </div>

                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="jackpot">
                            TRONS <span class="game-demo-tag">(beta)</span>
    </div>

                <div id="score">ETHER: 0</div>
    <div id="level-display">Sector: 1</div>
    <div id="dialogue-box"></div>
                <button id="boost-button">BLAST</button>
            <button id="blaster-button">VIBES</button>
    <button id="mini-boost-button">BOOST</button>
    <div id="lightning-flash"></div>
    <div id="level-up-popup">LEVEL UP!</div>
    <div class="mobile-controls">
        <button id="steer-left-button"><</button>
        <button id="steer-right-button">></button>
    </div>
    <button id="use-power-up-button">Use Power-up</button>
    <div id="power-up-display"></div>

    

    <div id="settings-menu">
        <h2>Customization Settings</h2>
        
        <div class="setting-row">
            <span class="setting-label">Bike Skin:</span>
            <span class="setting-value" id="current-skin">Default</span>
        </div>
        
        <div class="setting-row">
            <span class="setting-label">Trail Effect:</span>
            <span class="setting-value" id="current-trail">Default</span>
        </div>
        
        <div class="setting-row">
            <span class="setting-label">Rider Outfit:</span>
            <span class="setting-value" id="current-outfit">Classic</span>
        </div>
        
                    <div class="setting-controls">
                CONTROLS:<br/>
                [1/2] - Change Bike Skin<br/>
                [3/4] - Change Trail Effect<br/>
                [5/6] - Change Rider Outfit<br/>
                [S] - BOOST (+25% speed)<br/>
                [F] - VIBES (Level 10+)<br/>
                [I] - Toggle Game Instructions<br/>
                [TAB] - Toggle Settings Menu<br/>
                [ESC] - Close Settings
            </div>
        
        <div id="game-instructions" style="display: none; margin-top: 20px; padding: 15px; background: rgba(0,0,0,0.7); border-radius: 8px; max-height: 300px; overflow-y: auto;">
                            <h3 style="color: #ff3333; margin-top: 0;">TRONS - MISSION BRIEFING</h3>
            
            <div style="color: #ffffff; font-size: 0.85em; line-height: 1.4;">
                <p><strong style="color: #ffff00;">OBJECTIVE:</strong><br/>
                Fight criminal forces through the city and unlock your technological powers! Reach level 100 to complete the ultimate justice mission and ensure Fair Play.</p>
                
                <p><strong style="color: #ffff00;">BASIC CONTROLS:</strong><br/>
                â€¢ Arrow Keys - Steer Terrific Quest high-tech vehicle<br/>
                â€¢ SPACE - DISCO jump<br/>
                â€¢ E - Use DISCO power (when available)<br/>
                â€¢ â†‘ - BLAST (unlocked at level 5)<br/>
                â€¢ S - BOOST (+25% speed, unlimited use)<br/>
                â€¢ F - VIBES (unlocked at level 10, 1 per 10 levels)<br/>
                â€¢ P / Tap Screen - Pause mission<br/>
                â€¢ M - Toggle audio on/off<br/>
                â€¢ TAB - Settings menu</p>
                
                <p><strong style="color: #ffff00;">DISCO DEGREE POWERS (Collect degree boxes):</strong><br/>
                â€¢ ðŸ‘» Stealth Mode - Temporary invisibility from criminal forces<br/>
                â€¢ âšª Fair Play - Turn white, destroy criminal competitors on contact (+30 ETHER each, 6s)<br/>
                â€¢ â° Slow Time - Use technology to manipulate time<br/>
                â€¢ ðŸ”µ DISCO STRIKE - Fire cyan DISCO at criminal speeders (+20 ETHER)<br/>
                â€¢ ðŸ’£ Degree Trap - Deploy mine trap for criminals (+10 ETHER)<br/>
                â€¢ ðŸ”„ Position Swap - Technology teleport with leading criminal<br/>
                â€¢ âš¡ Speed Boost - Temporary speed enhancement</p>
                
                <p><strong style="color: #ffff00;">SCORING SYSTEM:</strong><br/>
                â€¢ Degree crystals (coins): +1 point each<br/>
                â€¢ Item crates: Random DISCO power<br/>
                â€¢ Red containers: Random vehicle skin or color change<br/>
                â€¢ Fair Play mode criminal kill: +30 ETHER<br/>
                            â€¢ DISCO STRIKE hit: +20 ETHER<br/>
                            â€¢ VIBES kill: +15 ETHER (destroys drones, criminal riders, helicopters)<br/>
                            â€¢ Criminal hits your mine: +10 ETHER<br/>
                            â€¢ Defeat Helicopter: +500 ETHER<br/>
                            â€¢ Level progression: Every 5 ETHER = next level</p>
                
                <p><strong style="color: #ffff00;">HAZARDS TO AVOID:</strong><br/>
                â€¢ Criminal debris and degree mines<br/>
                â€¢ Helicopter swarms (appear level 2+)<br/>
                â€¢ Criminal vehicles (hostile riders)<br/>
                â€¢ Obstacle spheres (reduce ETHER)<br/>
                â€¢ Drone gangs (levels 2+)<br/>
                â€¢ Criminal Strongholds (levels 10, 50, 90)</p>
                
                <p><strong style="color: #ffff00;">SPECIAL FEATURES:</strong><br/>
                â€¢ Dynamic city weather system (levels 5-25)<br/>
                â€¢ Terrific Quest quotes floating in degree space<br/>
                â€¢ DISCO acceleration jumps at maximum speed<br/>
                â€¢ Fair Play degree glow when holding powers<br/>
                â€¢ Bright red pulsating rider power (level 10+)<br/>
                â€¢ Customizable vehicle skins, trails, and outfits<br/>
                â€¢ Immersive 3D spatial audio (press M to enable)<br/>
                â€¢ Real-time mission statistics</p>
                
                <p><strong style="color: #ff6600;">EXTREME DIFFICULTY:</strong> Level 60+ features enhanced criminal forces and faster gameplay!</p>
            </div>
        </div>
    </div>

    <div id="social-display" style="opacity: 0.6;">
        <div style="display: flex; align-items: center; gap: 15px; font-size: 0.9em;">
            <a href="https://x.com/einsteinsgame" target="_blank" style="color: #1da1f2; text-decoration: none; display: flex; align-items: center; gap: 5px;">
                <span style="font-size: 1.2em;">ðŸ¦</span>
                <span>@einsteinsgame</span>
            </a>
            <a href="https://t.me/zkEinstein" target="_blank" style="color: #00d9ff; text-decoration: none; display: flex; align-items: center; gap: 5px;">
                <span style="font-size: 1.2em;">ðŸ“±</span>
                <span>Telegram</span>
            </a>
            <a href="https://discord.gg/bmpFdd2ekr" target="_blank" style="color: #5865f2; text-decoration: none; display: flex; align-items: center; gap: 5px;">
                <span style="font-size: 1.2em;">ðŸ’¬</span>
                <span>Discord</span>
            </a>
            <a href="https://youtube.com/@zkEinstein" target="_blank" style="color: #ff0000; text-decoration: none; display: flex; align-items: center; gap: 5px;">
                <span style="font-size: 1.2em;">ðŸ“º</span>
                <span>YouTube</span>
            </a>
            <a href="https://github.com/zkEinstein?tab=repositories" target="_blank" style="color: #ffffff; text-decoration: none; display: flex; align-items: center; gap: 5px;">
                <span style="font-size: 1.2em;">âš™ï¸</span>
                <span>GitHub</span>
            </a>
        </div>
    </div>

    <!-- Power-up Display in Top Right -->
    <div id="power-up-display"></div>

    <div id="pause-overlay">
        <div class="pause-text">
            GAME PAUSED<br/>
            <div style="font-size: 0.5em; margin-top: 20px;">
                Tap/Click to Resume
            </div>
        </div>
    </div>

    <div class="game-footer">
        <div>
            <a href="#" id="how-to-play-link" style="color: yellow; text-decoration: none; display: block; margin-bottom: 5px;">How to Play</a>
            <a href="#" id="leaderboard-link" style="color: yellow; text-decoration: none; display: block; margin-bottom: 5px;">ðŸ† Hall of Fame</a>
            <p class="copyright" style="margin: 0;">&copy; 2025 Ockams Inc.</p>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboard-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; color: white;">
        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(135deg, #1a1a2e, #16213e); border: 2px solid #00ffff; border-radius: 15px; padding: 30px; max-width: 90%; max-height: 90%; overflow-y: auto;">
            <div style="text-align: center; margin-bottom: 20px;">
                <h2 style="color: #00ffff; text-shadow: 0 0 10px #00ffff; margin: 0 0 10px 0; font-size: 2em;">ðŸ† HALL OF FAME ðŸ†</h2>
                <p style="color: #ffff00; margin: 0;">Top TRONS Pilots</p>
                ${playerName ? `<p style="color: #00ff00; margin: 5px 0 0 0; font-size: 0.9em;">Current Pilot: ${playerName}</p>` : ''}
            </div>
            
            <div id="leaderboard-content" style="min-width: 400px;">
                <!-- Leaderboard entries will be populated here -->
            </div>
            
            <div style="text-align: center; margin-top: 20px;">
                <button id="close-leaderboard" style="background: #ff3333; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1.1em;">Close</button>

                <button id="clear-leaderboard" style="background: #ff8800; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 1.1em; margin-left: 10px;">Reset Scores</button>
            </div>
        </div>
    </div>




    <!-- <audio id="boost-sound" src="https://assets.mixkit.co/sfx/preview/mixkit-sci-fi-rocket-engine-1320.mp3" loop></audio> -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <script>
        // Read URL parameters for customization
        const urlParams = new URLSearchParams(window.location.search);
        const isCustomized = urlParams.get('customized') === 'true';
        
        // Apply customizations if parameters are present
        if (isCustomized) {
            // Update title
            const gameName = urlParams.get('name') || 'Terrific Quest';
            document.title = gameName;
            const titleElement = document.getElementById('gameTitle');
            if (titleElement) titleElement.textContent = gameName;
            
            // Display custom game name instead of JEDAII
            const logoSubtitleElement = document.getElementById('logo-subtitle');
            if (logoSubtitleElement && gameName && gameName.trim() !== '') {
                logoSubtitleElement.textContent = gameName;
                logoSubtitleElement.setAttribute('data-text', gameName);
            }
            
            // Store customization parameters globally
            window.gameCustomizations = {
                name: gameName,
                theme: urlParams.get('theme') || 'cyberpunk',
                weather: urlParams.get('weather') || 'dynamic',
                starDensity: parseInt(urlParams.get('starDensity')) || 1000,
                helmetColor: parseInt(urlParams.get('helmetColor') || '00ff00', 16),
                helmetGlow: urlParams.get('helmetGlow') === 'true',
                bodyColor: parseInt(urlParams.get('bodyColor') || '000000', 16),
                bodyGlow: urlParams.get('bodyGlow') === 'true',
                bikeColor: parseInt(urlParams.get('bikeColor') || '000000', 16),
                bikeGlow: urlParams.get('bikeGlow') === 'true',
                baseSpeed: parseFloat(urlParams.get('baseSpeed')) || 0.8,
                aiCount: parseInt(urlParams.get('aiCount')) || 3,
                aiDifficulty: urlParams.get('aiDifficulty') || 'normal',
                enablePowerups: urlParams.get('enablePowerups') !== 'false',
                enableObstacles: urlParams.get('enableObstacles') !== 'false',
                enableJumping: urlParams.get('enableJumping') !== 'false',
                enableEnemies: urlParams.get('enableEnemies') !== 'false',
                gameLength: urlParams.get('gameLength') || 'medium'
            };
        }

        // Theme configurations - Updated for NYC city setting
        const themes = {
            cyberpunk: {
                backgroundColor: 0x1a1a2e, // Dark city night sky
                primaryColor: 0x00f0ff,
                accentColor: 0xff00ff,
                starColor: 0x00ffff
            },
            space: {
                backgroundColor: 0x2c3e50, // City twilight
                primaryColor: 0xffffff,
                accentColor: 0xffd60a,
                starColor: 0xffffff
            },
            neon: {
                backgroundColor: 0x16213e, // City night with neon glow
                primaryColor: 0xff0080,
                accentColor: 0x00ff80,
                starColor: 0xff80ff
            },
            matrix: {
                backgroundColor: 0x0f3460, // Deep city blue
                primaryColor: 0x00ff00,
                accentColor: 0x008000,
                starColor: 0x00ff00
            }
        };

        // Get current theme
        const currentTheme = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.theme : 'cyberpunk';
        const themeConfig = themes[currentTheme] || themes.cyberpunk;

        // Set up the scene, camera, and renderer
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000011, 50, 300); // Add atmospheric fog for nighttime depth
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000); // Increased far plane for starfield
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });

        // Set renderer size and append to body
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000011); // Dark nighttime sky
        document.body.appendChild(renderer.domElement);
        
        // Optimize renderer for better performance
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio at 2 for performance
        renderer.outputEncoding = THREE.sRGBEncoding;
        
        // FPS counter variables
        let fpsFrameCount = 0;
        let fpsLastTime = performance.now();
        let currentFPS = 60;

        // Get the canvas element
        const gameCanvas = renderer.domElement;
        gameCanvas.style.zIndex = 1; // Ensure game canvas is above body background but below UI

        // Store player rider parts globally for easy access
        let playerRiderBody;
        let playerRiderHead;
        let originalRiderMaterials = {}; // To store materials during shield effect
        
        // Global neon lights for lens flares (declared early)
        let neonLight1, neonLight2, neonLight3, lightningLight;

        // NYC City Buildings - Infinite Generation System
        let cityBuildings;
        let buildingSegments = [];
        const segmentLength = 200;
        const buildingsPerSegment = 6; // Reduced from 10 for better performance
        
        function createCityscape() {
            cityBuildings = new THREE.Group();
            scene.add(cityBuildings);
            
            // Create initial segments
            for (let segment = 0; segment < 5; segment++) {
                createBuildingSegment(segment * segmentLength);
            }
        }
        
        function createBuildingSegment(startZ) {
            const segment = new THREE.Group();
            segment.userData.startZ = startZ;
            segment.userData.endZ = startZ - segmentLength;
            
            for (let i = 0; i < buildingsPerSegment; i++) {
                const buildingZ = startZ - (i * (segmentLength / buildingsPerSegment));
                
                // Left side buildings (single row for performance)
                const leftBuilding = createBuilding();
                leftBuilding.position.set(
                    -15 - Math.random() * 3, // Single row of buildings
                    0,
                    buildingZ + (Math.random() - 0.5) * 10
                );
                segment.add(leftBuilding);
                
                // Right side buildings (single row for performance)
                const rightBuilding = createBuilding();
                rightBuilding.position.set(
                    15 + Math.random() * 3, // Single row of buildings
                    0,
                    buildingZ + (Math.random() - 0.5) * 10
                );
                segment.add(rightBuilding);
            }
            
            cityBuildings.add(segment);
            buildingSegments.push(segment);
        }
        
        // Optimized city update with reduced frequency
        let cityUpdateCounter = 0;
        function updateInfiniteCity() {
            // Only update city every 5th frame for better performance
            cityUpdateCounter++;
            if (cityUpdateCounter % 5 !== 0) return;
            
            const playerZ = playerMotorcycle.position.z;
            
            // Remove old segments that are far behind
            for (let i = buildingSegments.length - 1; i >= 0; i--) {
                const segment = buildingSegments[i];
                if (segment.userData.endZ > playerZ + 100) {
                    cityBuildings.remove(segment);
                    buildingSegments.splice(i, 1);
                    // Dispose of segment resources
                    segment.traverse((child) => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                }
            }
            
            // Add new segments ahead
            const frontMostSegment = buildingSegments.reduce((front, segment) => 
                segment.userData.startZ < front.userData.startZ ? segment : front
            );
            
            if (frontMostSegment.userData.startZ > playerZ - 500) {
                createBuildingSegment(frontMostSegment.userData.startZ - segmentLength);
            }
        }
        
        function createBuilding() {
            const building = new THREE.Group();
            
            // Times Square style building dimensions - taller and more varied
            const width = 4 + Math.random() * 8;
            const depth = 4 + Math.random() * 8;
            const height = 25 + Math.random() * 60; // Much taller buildings
            
            // Main building structure - darker for nighttime
            const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
            const buildingMaterial = new THREE.MeshLambertMaterial({
                color: new THREE.Color().setHSL(0.6, 0.1, 0.05 + Math.random() * 0.15) // Very dark buildings for nighttime
            });
            const buildingMesh = new THREE.Mesh(buildingGeometry, buildingMaterial);
            buildingMesh.position.y = height / 2;
            building.add(buildingMesh);
            
            // Add windows (small glowing squares)
            const windowsPerFloor = Math.floor(width / 1.2);
            const floors = Math.floor(height / 2.5);
            
            for (let floor = 1; floor < floors; floor += 2) { // Every other floor for performance
                for (let window = 0; window < windowsPerFloor; window++) {
                    if (Math.random() > 0.3) { // 70% chance of lit window (reduced from 85%)
                        const windowGeometry = new THREE.PlaneGeometry(0.4, 0.6);
                        const windowColors = [0xffff00, 0xff6600, 0x00ffff, 0xff0080, 0xffffff, 0x80ff00]; // Brighter nighttime colors
                        const chosenColor = windowColors[Math.floor(Math.random() * windowColors.length)];
                        const windowMaterial = new THREE.MeshBasicMaterial({
                            color: chosenColor,
                            transparent: true,
                            opacity: 0.95
                        });
                        const windowMesh = new THREE.Mesh(windowGeometry, windowMaterial);
                        windowMesh.position.set(
                            (window - windowsPerFloor/2) * 1.2,
                            floor * 2.5,
                            depth/2 + 0.01
                        );
                        building.add(windowMesh);
                    }
                }
            }
            
            // Add massive Times Square style billboards (reduced for performance)
            if (Math.random() > 0.5) { // 50% chance of billboard
                const billboardWidth = width * 1.2;
                const billboardHeight = height * 0.4;
                const signGeometry = new THREE.PlaneGeometry(billboardWidth, billboardHeight);
                const signColors = [0xff0080, 0x00ff80, 0x0080ff, 0xff8000, 0xff0040, 0x8000ff, 0x40ff00];
                const chosenColor = signColors[Math.floor(Math.random() * signColors.length)];
                const signMaterial = new THREE.MeshStandardMaterial({
                    color: chosenColor,
                    transparent: true,
                    opacity: 0.95,
                    emissive: chosenColor,
                    metalness: 0.1,
                    roughness: 0.9,
                    emissiveIntensity: 1.2 // Brighter for nighttime
                });
                const signMesh = new THREE.Mesh(signGeometry, signMaterial);
                signMesh.position.set(0, height * 0.5, depth/2 + 0.02);
                
                // Add pulsing animation to billboards
                signMesh.userData.originalIntensity = 1.2;
                signMesh.userData.animationPhase = Math.random() * Math.PI * 2;
                
                building.add(signMesh);
                
                // Add smaller secondary signs
                if (Math.random() > 0.5) {
                    const smallSignGeometry = new THREE.PlaneGeometry(width * 0.6, height * 0.15);
                    const smallSignColor = signColors[Math.floor(Math.random() * signColors.length)];
                    const smallSignMaterial = new THREE.MeshStandardMaterial({
                        color: smallSignColor,
                        transparent: true,
                        opacity: 0.9,
                        emissive: smallSignColor,
                        metalness: 0.1,
                        roughness: 0.9,
                        emissiveIntensity: 0.8
                    });
                    const smallSignMesh = new THREE.Mesh(smallSignGeometry, smallSignMaterial);
                    smallSignMesh.position.set(0, height * 0.2, depth/2 + 0.01);
                    building.add(smallSignMesh);
                }
            }
            
            return building;
        }

        // Create the Motorcycle and Rider - Updated for futuristic look
        function createMotorcycle(bikeColor = 0x222222, riderColor = 0x333333, isPlayer = false) {
            const motorcycle = new THREE.Group();
            
            // Choose a random motorcycle style
            const style = Math.floor(Math.random() * 4); // 4 different styles
            
            // Base materials
            const bikeBodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000, // Pure black for ALL bikes
                metalness: 0.9,
                roughness: 0.1,
                emissive: isPlayer ? 0xffff00 : 0x000000, // Only player bike glows yellow
                emissiveIntensity: isPlayer ? 0.4 : 0.0
            });

            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000, // All wheels are black
                metalness: 0.9,
                roughness: 0.1,
                emissive: isPlayer ? 0xffff00 : 0x000000, // Only player wheels glow
                emissiveIntensity: isPlayer ? 0.4 : 0.0
            });

            // Common wheel geometry
            const wheelGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 24);

            // Style-specific body parts
            switch(style) {
                case 0: // Sport Bike
                    const sportBodyGeometry = new THREE.BoxGeometry(0.5, 0.4, 1.5);
                    const sportBody = new THREE.Mesh(sportBodyGeometry, bikeBodyMaterial);
                    sportBody.position.y = 0.2;
                    motorcycle.add(sportBody);

                    // Add sport fairing
                    const fairingGeometry = new THREE.BoxGeometry(0.6, 0.5, 0.8);
                    const fairingMaterial = new THREE.MeshStandardMaterial({
                        color: 0x000000,
                        metalness: 0.7,
                        roughness: 0.3,
                        emissive: isPlayer ? 0xffff00 : 0x000000,
                        emissiveIntensity: isPlayer ? 0.4 : 0.0
                    });
                    const fairing = new THREE.Mesh(fairingGeometry, fairingMaterial);
                    fairing.position.set(0, 0.4, 0.3);
                    motorcycle.add(fairing);
                    break;

                case 1: // Cruiser
                    const cruiserBodyGeometry = new THREE.BoxGeometry(0.6, 0.3, 1.8);
                    const cruiserBody = new THREE.Mesh(cruiserBodyGeometry, bikeBodyMaterial);
                    cruiserBody.position.y = 0.15;
                    motorcycle.add(cruiserBody);

                    // Add cruiser handlebars
                    const handlebarGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1.2);
                    const handlebarMaterial = new THREE.MeshStandardMaterial({
                        color: 0x888888,
                        metalness: 0.9,
                        roughness: 0.1
                    });
                    const handlebars = new THREE.Mesh(handlebarGeometry, handlebarMaterial);
                    handlebars.position.set(0, 0.6, 0.4);
                    handlebars.rotation.x = Math.PI / 2;
                    motorcycle.add(handlebars);
                    break;

                case 2: // Super Bike
                    const superBodyGeometry = new THREE.BoxGeometry(0.45, 0.35, 1.6);
                    const superBody = new THREE.Mesh(superBodyGeometry, bikeBodyMaterial);
                    superBody.position.y = 0.25;
                    motorcycle.add(superBody);

                    // Add aerodynamic wings
                    const wingGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.4);
                    const wingMaterial = new THREE.MeshStandardMaterial({
                        color: 0x000000,
                        metalness: 0.8,
                        roughness: 0.2,
                        emissive: isPlayer ? 0xffff00 : 0x000000,
                        emissiveIntensity: isPlayer ? 0.4 : 0.0
                    });
                    const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                    leftWing.position.set(-0.4, 0.3, 0);
                    motorcycle.add(leftWing);
                    const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                    rightWing.position.set(0.4, 0.3, 0);
                    motorcycle.add(rightWing);
                    break;

                case 3: // Future Bike
                    const futureBodyGeometry = new THREE.BoxGeometry(0.5, 0.4, 1.5);
                    const futureBody = new THREE.Mesh(futureBodyGeometry, bikeBodyMaterial);
                    futureBody.position.y = 0.2;
                    motorcycle.add(futureBody);

                    // Add hover elements
                    const hoverGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
                    const hoverMaterial = new THREE.MeshStandardMaterial({
                        color: 0x00ffff,
                        metalness: 0.5,
                        roughness: 0.5,
                        emissive: 0x00ffff,
                        emissiveIntensity: 0.8
                    });
                    const leftHover = new THREE.Mesh(hoverGeometry, hoverMaterial);
                    leftHover.position.set(-0.3, 0.1, 0);
                    motorcycle.add(leftHover);
                    const rightHover = new THREE.Mesh(hoverGeometry, hoverMaterial);
                    rightHover.position.set(0.3, 0.1, 0);
                    motorcycle.add(rightHover);
                    break;
            }

            // Add wheels for all styles
            const frontWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            frontWheel.position.set(0, 0, 0.7);
            frontWheel.rotation.x = Math.PI / 2;
            motorcycle.add(frontWheel);

            const rearWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
            rearWheel.position.set(0, 0, -0.7);
            rearWheel.rotation.x = Math.PI / 2;
            motorcycle.add(rearWheel);

            // Rider (sleek, dark suit with glowing visor)
            const riderBodyMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000, // Pure black for ALL riders
                metalness: 0.9,
                roughness: 0.1,
                emissive: isPlayer ? 0xffff00 : 0x000000, // Only player has yellow body glow
                emissiveIntensity: isPlayer ? 0.6 : 0.0 // Only player glows
            });

            const riderBodyGeometry = new THREE.BoxGeometry(0.6, 0.8, 0.4);
            const riderBody = new THREE.Mesh(riderBodyGeometry, riderBodyMaterial);
            riderBody.position.set(0, 0.7, 0);
            motorcycle.add(riderBody);

            const riderHeadGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const riderHeadMaterial = new THREE.MeshStandardMaterial({
                color: isPlayer ? 0xff3333 : 0x00ff00, // Red helmet for player, green for competitors
                metalness: 0.9,
                roughness: 0.1,
                emissive: isPlayer ? 0xff3333 : 0x00ff00, // Red glow for player, green for competitors
                emissiveIntensity: 1.5, // Strong helmet glow for all riders
                transparent: true,
                opacity: 0.9
            });
            const riderHead = new THREE.Mesh(riderHeadGeometry, riderHeadMaterial);
            riderHead.position.set(0, 1.2, 0);
            motorcycle.add(riderHead);

            // Add a subtle engine glow for the player
            if (isPlayer) {
                const engineGlowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff8800,
                    transparent: true,
                    opacity: 0.6
                });
                const engineGlowGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const engineGlow = new THREE.Mesh(engineGlowGeometry, engineGlowMaterial);
                engineGlow.position.set(0, 0.2, -0.9);
                motorcycle.add(engineGlow);
                motorcycle.userData.engineGlow = engineGlow;
            }

            // Add a light following the motorcycle for visibility
            const bikeLight = new THREE.PointLight(0xffffff, 0.8, 15);
            bikeLight.position.y = 1;
            motorcycle.add(bikeLight);

            return { motorcycle, riderBody, riderHead };
        }


        // Player Motorcycle and Rider Parts
        // Use custom colors if available, otherwise use defaults
        const playerBikeColor = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.bikeColor : 0x000000;
        const playerBodyColor = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.bodyColor : 0x000000;
        const playerMotorcycleParts = createMotorcycle(playerBikeColor, playerBodyColor, true);
        let playerMotorcycle = playerMotorcycleParts.motorcycle;
        playerRiderBody = playerMotorcycleParts.riderBody;
        playerRiderHead = playerMotorcycleParts.riderHead;
        
        // Apply custom rider body color and glow
        if (playerRiderBody) {
            const customBodyColor = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.bodyColor : 0x000000;
            const customBodyGlow = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.bodyGlow : false;
            
            playerRiderBody.material = new THREE.MeshStandardMaterial({
                color: customBodyGlow ? customBodyColor * 0.3 : customBodyColor, // Darker base if glowing
                metalness: customBodyGlow ? 0.5 : 0.3,
                roughness: customBodyGlow ? 0.3 : 0.7,
                emissive: customBodyGlow ? customBodyColor : 0x000000,
                emissiveIntensity: customBodyGlow ? 0.4 : 0.1
            });
        }
        
        // Force player helmet to be red regardless of customization
        if (playerRiderHead) {
            const helmetColor = 0xff3333; // Always red for main player
            const helmetGlow = true; // Always glowing
            
            playerRiderHead.material = new THREE.MeshStandardMaterial({
                color: helmetColor,
                metalness: 0.9,
                roughness: 0.1,
                emissive: helmetColor,
                emissiveIntensity: 1.5,
                transparent: true,
                opacity: 0.9
            });
        }
        
        // Apply custom bike color and glow if specified
        const customBikeColor = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.bikeColor : 0x000000;
        const customBikeGlow = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.bikeGlow : false;
        
        playerMotorcycle.traverse((child) => {
            if (child.isMesh && child.material && child !== playerRiderBody && child !== playerRiderHead) {
                // Apply custom bike color to all motorcycle parts (but not rider parts)
                child.material = new THREE.MeshStandardMaterial({
                    color: customBikeGlow ? customBikeColor * 0.3 : customBikeColor, // Darker base if glowing
                    metalness: customBikeGlow ? 0.8 : 0.0, // More metallic if glowing
                    roughness: customBikeGlow ? 0.2 : 1.0, // Smoother if glowing
                    emissive: customBikeGlow ? customBikeColor : 0x000000,
                    emissiveIntensity: customBikeGlow ? 0.4 : 0.0
                });
            }
        });
        
        scene.add(playerMotorcycle);

        // AI Competitor Motorcycles
        const aiMotorcycles = [];
        let numAIMotorcycles = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.aiCount : 3;
        // TRON-style neon cyberpunk colors for AI competitors
const aiColors = [0x00ffff, 0xff00ff, 0x00ff00, 0xffff00, 0xff6600, 0x6600ff];
        const initialAiBikes = 3;


        function createInitialAIMotorcycles() {
             for (let i = 0; i < numAIMotorcycles; i++) {
                 const aiBikeParts = createMotorcycle(aiColors[i % aiColors.length], 0x000000); // AI bikes colored, riders wear black
                 const aiBike = aiBikeParts.motorcycle;
                 
                 // Force all AI riders to have green helmets
                 if (aiBikeParts.riderHead) {
                     aiBikeParts.riderHead.material = new THREE.MeshStandardMaterial({
                         color: 0x00ff00,
                         metalness: 0.9,
                         roughness: 0.1,
                         emissive: 0x00ff00,
                         emissiveIntensity: 1.2,
                         transparent: true,
                         opacity: 0.9
                     });
                 }
                 
                 aiBike.position.set((i - (numAIMotorcycles - 1) / 2) * 2, 0, playerMotorcycle.position.z - 10 - i * 8); // Stagger spawn positions more
                 aiBike.userData.targetX = aiBike.position.x;
                 aiBike.userData.targetTimer = 0;
                 aiBike.userData.steerSpeed = 0.02;
                 aiBike.userData.moveSpeed = baseMoveSpeed * (0.85 + Math.random() * 0.2); // AI slightly slower for racing balance
                 aiBike.userData.canMove = true; // Add canMove flag
                 scene.add(aiBike);
                 aiMotorcycles.push(aiBike);
             }
        }


        const roadWidth = 10;
        const roadLength = 200; // Shorter segments for infinite tiling
        const roadSegments = [];

        function createRoadSegment(zPosition) {
            const roadSegment = new THREE.Mesh(sharedRoadGeometry, sharedRoadMaterials[currentRoadTextureIndex]);
            roadSegment.rotation.x = Math.PI / 2;
            roadSegment.position.set(0, -0.5, zPosition);
            roadSegment.userData.zPosition = zPosition;
            scene.add(roadSegment);
            roadSegments.push(roadSegment);
            return roadSegment;
        }
        
        function updateInfiniteRoad() {
            const playerZ = playerMotorcycle.position.z;
            
            // Only update road segments every 200ms for better performance (doubled from 100ms)
            if (Math.floor(getAdjustedTime() / 200) !== updateInfiniteRoad.lastUpdate) {
                updateInfiniteRoad.lastUpdate = Math.floor(getAdjustedTime() / 200);
                
                // Remove road segments that are far behind
                for (let i = roadSegments.length - 1; i >= 0; i--) {
                    const segment = roadSegments[i];
                    if (segment.userData.zPosition > playerZ + roadLength * 2) {
                        scene.remove(segment);
                        // Don't dispose shared geometry and materials
                        roadSegments.splice(i, 1);
                    }
                }
                
                // Add new road segments ahead
                const frontMostZ = roadSegments.length > 0 ? 
                    Math.min(...roadSegments.map(s => s.userData.zPosition)) : 0;
                
                if (frontMostZ > playerZ - roadLength * 4) {
                    createRoadSegment(frontMostZ - roadLength);
                }
            }
        }

        // Keep road flat for smooth NYC street racing

        function createCityStreetTexture(centerColor, edgeColor, glowColor) {
            const roadCanvas = document.createElement('canvas');
            roadCanvas.width = 256;
            roadCanvas.height = 1024;
            const roadCtx = roadCanvas.getContext('2d');

            // Base asphalt with city wear - darker for nighttime
            roadCtx.fillStyle = '#151515'; // Much darker nighttime asphalt
            roadCtx.fillRect(0, 0, roadCanvas.width, roadCanvas.height);

            // Add some wear marks and cracks for city authenticity - more subtle for nighttime
            roadCtx.strokeStyle = '#0f0f0f';
            roadCtx.lineWidth = 1;
            for (let i = 0; i < 12; i++) {
                roadCtx.beginPath();
                roadCtx.moveTo(Math.random() * roadCanvas.width, Math.random() * roadCanvas.height);
                roadCtx.lineTo(Math.random() * roadCanvas.width, Math.random() * roadCanvas.height);
                roadCtx.stroke();
            }

            // Sidewalk/curb glow (representing street lighting)
            roadCtx.fillStyle = glowColor;
            roadCtx.globalAlpha = 0.3;
            const sidewalkWidth = 15;
            roadCtx.fillRect(0, 0, sidewalkWidth, roadCanvas.height); // Left sidewalk
            roadCtx.fillRect(roadCanvas.width - sidewalkWidth, 0, sidewalkWidth, roadCanvas.height); // Right sidewalk
            roadCtx.globalAlpha = 1.0;

            // Lane dividers (yellow city street lines)
            roadCtx.fillStyle = '#ffff00'; // Yellow street markings
            const laneLineWidth = 4;
            const laneLineGap = 40;
            
            // Center double yellow lines
            for (let i = 0; i < roadCanvas.height; i += laneLineGap) {
                roadCtx.fillRect(roadCanvas.width / 2 - laneLineWidth - 1, i, laneLineWidth, laneLineGap / 2);
                roadCtx.fillRect(roadCanvas.width / 2 + 1, i, laneLineWidth, laneLineGap / 2);
            }

            const roadTexture = new THREE.CanvasTexture(roadCanvas);
            roadTexture.wrapS = THREE.RepeatWrapping;
            roadTexture.wrapT = THREE.RepeatWrapping;
            roadTexture.repeat.set(1, roadLength / roadCanvas.height * 2);
            roadTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            return roadTexture;
        }

        function createCyberRoadTexture() {
             const roadCanvas = document.createElement('canvas');
             roadCanvas.width = 256;
             roadCanvas.height = 1024;
             const roadCtx = roadCanvas.getContext('2d');

             // Jet black base 
             roadCtx.fillStyle = '#000000'; // Pure jet black base
             roadCtx.fillRect(0, 0, roadCanvas.width, roadCanvas.height);

             // No grid lines - keep road mostly black

             // Cyan border outlines only
             roadCtx.strokeStyle = '#00ffff';
             roadCtx.lineWidth = 3;
             roadCtx.globalAlpha = 1.0;
             
             // Left edge
             roadCtx.beginPath();
             roadCtx.moveTo(20, 0);
             roadCtx.lineTo(20, roadCanvas.height);
             roadCtx.stroke();
             
             // Right edge  
             roadCtx.beginPath();
             roadCtx.moveTo(roadCanvas.width - 20, 0);
             roadCtx.lineTo(roadCanvas.width - 20, roadCanvas.height);
             roadCtx.stroke();

             // No center lines - keep road clean

             const roadTexture = new THREE.CanvasTexture(roadCanvas);
             roadTexture.wrapS = THREE.RepeatWrapping;
             roadTexture.wrapT = THREE.RepeatWrapping;
             roadTexture.repeat.set(1, roadLength / roadCanvas.height * 2);
             roadTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
             return roadTexture;
        }


        const roadTextures = [
            createCityStreetTexture('#ffff00', '#ffffff', 'rgba(255, 165, 0, 0.4)'), // City street with orange lighting
            createCyberRoadTexture(),
            createCyberRoadTexture() // Cyber grid road for nighttime racing
        ];

        // Shared geometries and materials for better performance (defined after roadTextures)
        const sharedRoadGeometry = new THREE.PlaneGeometry(roadWidth, roadLength);
        const sharedRoadMaterials = roadTextures.map(texture => 
            new THREE.MeshPhongMaterial({ 
                map: texture, 
                side: THREE.DoubleSide 
            })
        );

        let currentRoadTextureIndex = 1; // Use dark road texture for nighttime
        
        // Initialize infinite road system
        for (let i = 0; i < 5; i++) {
            createRoadSegment(-i * roadLength);
        }

        // Dramatic nighttime Times Square lighting
        const ambientLight = new THREE.AmbientLight(0x220033, 0.3); // Dark purple ambient for nighttime
        scene.add(ambientLight);

        // Neon billboard lighting effects (lens flares added later)
        neonLight1 = new THREE.PointLight(0xff0080, 2.0, 50); // Hot pink neon
        neonLight1.position.set(-15, 12, 0);
        scene.add(neonLight1);

        neonLight2 = new THREE.PointLight(0x00ff80, 2.0, 50); // Electric green neon
        neonLight2.position.set(15, 12, -20);
        scene.add(neonLight2);

        neonLight3 = new THREE.PointLight(0x0080ff, 1.8, 45); // Electric blue neon
        neonLight3.position.set(0, 15, -40);
        scene.add(neonLight3);

        // Removed neonLight4 and neonLight5 for better performance

        // Animated neon light cycling (optimized)
        let lightAnimationCounter = 0;
        function animateNeonLights() {
            // Only animate lights every 2nd frame for better performance
            lightAnimationCounter++;
            if (lightAnimationCounter % 2 !== 0) return;
            
            const time = Date.now() * 0.002; // Slower animation
            neonLight1.intensity = 1.8 + Math.sin(time) * 0.3;
            neonLight2.intensity = 1.8 + Math.sin(time + 1) * 0.3;
            neonLight3.intensity = 1.6 + Math.sin(time + 2) * 0.3;
        }

        lightningLight = new THREE.PointLight(0xffffff, 0, 200);
        lightningLight.position.set(0, 50, 0);
        scene.add(lightningLight);


        // Memory Management System
        const objectPools = {
            coins: [],
            obstacles: [],
            projectiles: [],
            particles: [],
            sparkles: []
        };

        const sharedGeometries = {
            coin: new THREE.OctahedronGeometry(0.4), // Changed to octahedron for diamond shape
            sphere: new THREE.SphereGeometry(0.15, 8, 8),
            box: new THREE.BoxGeometry(1.5, 1, 1.5),
            particle: new THREE.SphereGeometry(0.05, 8, 8)
        };

        const sharedMaterials = {
            coin: new THREE.MeshStandardMaterial({
                color: 0x222222, // Changed from gold to dark gray/black
                metalness: 1.0, // Increased metalness for diamond-like reflection
                roughness: 0.1, // Decreased roughness for shiny diamond appearance
                emissive: 0x111111, // Dark emissive
                emissiveIntensity: 0.3
            }),
            particle: new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 1.0
            }),
            sparkle: new THREE.MeshBasicMaterial({
                color: 0x00ff44,
                emissive: 0x00ff44,
                emissiveIntensity: 1.0,
                transparent: true,
                opacity: 1.0
            })
        };

        function getPooledObject(type, createFn) {
            const pool = objectPools[type];
            if (pool && pool.length > 0) {
                return pool.pop();
            }
            return createFn();
        }

        function returnToPool(type, object) {
            if (object && objectPools[type]) {
                // Reset object state
                object.position.set(0, 0, 0);
                object.rotation.set(0, 0, 0);
                object.scale.set(1, 1, 1);
                object.visible = true;
                if (object.material && object.material.opacity !== undefined) {
                    object.material.opacity = 1.0;
                }
                objectPools[type].push(object);
            }
        }

        function disposeObject(object) {
            if (!object) return;
            
            // Traverse and dispose geometries and materials
            object.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => {
                                if (material.map) material.map.dispose();
                                material.dispose();
                            });
                        } else {
                            if (child.material.map) child.material.map.dispose();
                            child.material.dispose();
                        }
                    }
                }
            });
        }

        function cleanupScene() {
            // Only dispose renderer lists when game is paused or not running to avoid visual interruption
            if (!isGameRunning || gamePaused) {
                renderer.renderLists.dispose();
            }
            
            // Monitor memory usage
            if (window.performance && window.performance.memory) {
                const memory = window.performance.memory;
                console.log(`Memory: ${(memory.usedJSHeapSize / 1048576).toFixed(2)}MB used, ${(memory.totalJSHeapSize / 1048576).toFixed(2)}MB total`);
                
                // Only force cleanup if memory usage is extremely high
                if (memory.usedJSHeapSize > 150 * 1048576) { // > 150MB (increased threshold)
                    forceCleanup();
                }
            }
        }

        function forceCleanup() {
            console.log("Forcing memory cleanup...");
            
            // Clear all object pools
            Object.keys(objectPools).forEach(key => {
                objectPools[key].forEach(obj => disposeObject(obj));
                objectPools[key].length = 0;
            });
            
            // Force garbage collection
            if (window.gc) window.gc();
        }

        // Enhanced cleanup with power-up specific optimization
        function cleanupPowerUps() {
            // Remove power-ups that are too far behind the player
            for (let i = powerUps.length - 1; i >= 0; i--) {
                const powerUp = powerUps[i];
                if (powerUp.position.z > camera.position.z + 50) {
                    scene.remove(powerUp);
                    returnPooledObject('powerups', powerUp);
                    powerUps.splice(i, 1);
                }
            }
        }

        // More frequent power-up cleanup to prevent accumulation
        // Performance monitoring and cleanup intervals
        let cleanupPowerUpsInterval = setInterval(cleanupPowerUps, 5000); // Every 5 seconds
        let cleanupSceneInterval = setInterval(cleanupScene, 30000); // Every 30 seconds
        let memoryMonitorInterval = setInterval(monitorPerformance, 10000); // Every 10 seconds
        
        // Enhanced memory monitoring for detecting future leaks
        let memoryWarningShown = false;
        let frameCount = 0;
        function monitorMemoryLeaks() {
            frameCount++;
            // Only check memory every 300 frames (~5 seconds at 60fps) to reduce overhead
            if (frameCount % 300 !== 0) return;
            
            if (window.performance && window.performance.memory) {
                const memory = window.performance.memory;
                const usedMB = memory.usedJSHeapSize / 1048576;
                const totalMB = memory.totalJSHeapSize / 1048576;
                
                // Show warning if memory usage is excessive (increased threshold)
                if (usedMB > 200 && !memoryWarningShown) {
                    console.warn(`High memory usage detected: ${usedMB.toFixed(2)}MB`);
                    console.warn(`Active burst particles: ${activeBursts.length}`);
                    console.warn(`Active boost particles: ${boostParticles.length}`);
                    console.warn(`Power-ups: ${powerUps.length}`);
                    console.warn(`Scene children count: ${scene.children.length}`);
                    memoryWarningShown = true;
                    
                    // Force aggressive cleanup
                    forceCleanup();
                    cleanupPowerUps();
                }
                
                // Reset warning if memory goes back down
                if (usedMB < 120 && memoryWarningShown) {
                    memoryWarningShown = false;
                }
            }
        }
        
        // Performance monitoring function
        function monitorPerformance() {
            const totalObjects = coins.length + obstacles.length + bowlingBallObstacles.length + 
                               batGangs.length + powerUps.length + itemBoxes.length + greenVials.length + 
                               activeProjectiles.length + dragons.length + aiMotorcycles.length;
                               
            if (totalObjects > 100) { // Performance warning threshold
                console.warn(`Performance Warning: ${totalObjects} objects in scene at level ${level}`);
                // Force cleanup if too many objects
                if (totalObjects > 150) {
                    cleanupScene();
                    cleanupPowerUps();
                }
            }
            
            // Call existing memory monitoring
            monitorMemoryLeaks();
        }

        // Balanced object spawning throttling - maintain gameplay while preventing performance issues
        function shouldSpawnObject(spawnRate, level) {
            // Much gentler throttling that maintains gameplay excitement
            let levelMultiplier = 0;
            if (level > 30) {
                levelMultiplier = Math.min((level - 30) / 20, 0.8); // Max 80% reduction after level 30
            } else if (level > 20) {
                levelMultiplier = Math.min((level - 20) / 40, 0.4); // Max 40% reduction levels 20-30
            } else if (level > 15) {
                levelMultiplier = Math.min((level - 15) / 50, 0.2); // Max 20% reduction levels 15-20
            }
            const adjustedRate = spawnRate * (1 + levelMultiplier);
            const shouldSpawn = Math.random() < 1 / adjustedRate;
            
            // Debug logging for high levels
            if (level >= 20 && shouldSpawn && Math.random() < 0.1) { // Log 10% of spawns
                console.log(`Level ${level}: Object spawned. Base rate: ${spawnRate}, Multiplier: ${levelMultiplier.toFixed(2)}, Adjusted rate: ${adjustedRate.toFixed(1)}`);
            }
            
            return shouldSpawn;
        }

        function createCoin() {
            return getPooledObject('coins', () => {
                const coinGroup = new THREE.Group();
                
                // Main black diamond
                const coin = new THREE.Mesh(sharedGeometries.coin, sharedMaterials.coin.clone());
                coinGroup.add(coin);
                
                // White glowing outline for visibility
                const outlineGeometry = new THREE.OctahedronGeometry(0.45); // Slightly larger
                const outlineMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.4,
                    emissive: 0xffffff,
                    emissiveIntensity: 0.8
                });
                const outline = new THREE.Mesh(outlineGeometry, outlineMaterial);
                coinGroup.add(outline);
                
                return coinGroup;
            });
        }

        function createObstacle() {
            const kryptonGroup = new THREE.Group();
            
            // Create crystalline Krypton structure
            const kryptonMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff88, // Bright green-cyan for Krypton
                metalness: 0.7,
                roughness: 0.1,
                emissive: 0x00ffaa, // Strong emissive glow
                emissiveIntensity: 1.2,
                transparent: true,
                opacity: 0.9
            });

            // Main crystal body - octahedron shape
            const kryptonGeometry = new THREE.OctahedronGeometry(0.6, 0);
            const kryptonMesh = new THREE.Mesh(kryptonGeometry, kryptonMaterial);
            kryptonMesh.position.y = 0.6; 
            kryptonGroup.add(kryptonMesh);

            // Smaller crystal satellites
            for (let i = 0; i < 4; i++) {
                const smallCrystal = new THREE.Mesh(
                    new THREE.OctahedronGeometry(0.2, 0), 
                    kryptonMaterial
                );
                const angle = (i / 4) * Math.PI * 2;
                smallCrystal.position.set(
                    Math.cos(angle) * 0.8,
                    0.3,
                    Math.sin(angle) * 0.8
                );
                kryptonGroup.add(smallCrystal);
            }

            // Energy core
            const coreGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0x88ffff,
                emissive: 0x88ffff,
                emissiveIntensity: 2.0,
                transparent: true,
                opacity: 0.7
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            core.position.y = 0.6;
            kryptonGroup.add(core);

            kryptonGroup.position.y = 0.5;
            kryptonGroup.userData.isPlayerObstacle = false; // Spawned obstacles are deadly to player
            kryptonGroup.userData.rotationSpeed = 0.02; // Add rotation for visual effect
            return kryptonGroup;
        }



         function createBowlingBallObstacle() {
             // Create a group to hold the ball and its subtle outline
             const ballGroup = new THREE.Group();
             
             // Main bowling ball - keep original design
             const geometry = new THREE.SphereGeometry(0.8, 16, 16);
             const material = new THREE.MeshStandardMaterial({
                 color: 0x1a1a1a, // Very dark (original)
                 metalness: 0.9,
                 roughness: 0.1,
                 emissive: 0x050505, // Original subtle emissive
                 emissiveIntensity: 0.2 // Original intensity
                });
             const bowlingBall = new THREE.Mesh(geometry, material);
             ballGroup.add(bowlingBall);
             
             // Subtle red corona/outline - like a sun corona
             const coronaGeometry = new THREE.SphereGeometry(0.82, 16, 16); // Just slightly larger
             const coronaMaterial = new THREE.MeshBasicMaterial({
                 color: 0xff0000,
                 transparent: true,
                 opacity: 0.15, // Very subtle
                 side: THREE.BackSide, // Render from inside for outline effect
                 emissive: 0xff0000,
                 emissiveIntensity: 0.1 // Very low intensity
             });
             const corona = new THREE.Mesh(coronaGeometry, coronaMaterial);
             ballGroup.add(corona);
             
             // Add glowing red fuse
             const fuseGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8); // Thin cylinder
             const fuseMaterial = new THREE.MeshBasicMaterial({
                 color: 0xff3300, // Bright red
                 emissive: 0xff1100, // Glowing red emissive
                 emissiveIntensity: 1.2, // Strong glow
                 transparent: true,
                 opacity: 0.9
             });
             const fuse = new THREE.Mesh(fuseGeometry, fuseMaterial);
             fuse.position.set(0, 0.8, 0); // Position on top of the ball
             fuse.rotation.x = Math.PI / 6; // Slight angle
             ballGroup.add(fuse);
             
             // Add small sparking tip to the fuse
             const sparkTipGeometry = new THREE.SphereGeometry(0.03, 6, 6);
             const sparkTipMaterial = new THREE.MeshBasicMaterial({
                 color: 0xffff00, // Bright yellow
                 emissive: 0xffaa00, // Yellow-orange emissive
                 emissiveIntensity: 2.0, // Very bright
                 transparent: true,
                 opacity: 0.8
             });
             const sparkTip = new THREE.Mesh(sparkTipGeometry, sparkTipMaterial);
             sparkTip.position.set(0, 0.95, 0); // At the top of the fuse
             ballGroup.add(sparkTip);
             
             ballGroup.position.y = 0.8;
             ballGroup.userData.fuseSparkPhase = Math.random() * Math.PI * 2; // For animation
             return ballGroup;
         }

        function createBatGang() {
            const batGang = new THREE.Group();
            const numBats = 3 + Math.floor(Math.random() * 3);
            const batColor = 0xaa0000; // Slightly brighter red

            for (let i = 0; i < numBats; i++) {
                const batGeometry = new THREE.ConeGeometry(0.3, 0.5, 8);
                const batMaterial = new THREE.MeshStandardMaterial({
                    color: batColor,
                    metalness: 0.6,
                    roughness: 0.5,
                    emissive: 0x550000,
                    emissiveIntensity: 0.4
                });
                const bat = new THREE.Mesh(batGeometry, batMaterial);
                bat.position.set((Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 1.5, (Math.random() - 0.5) * 1.5);
                bat.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                batGang.add(bat);
            }
            batGang.position.y = 2;
            batGang.userData.speed = 0.2 + Math.random() * 0.1;
            batGang.userData.attackPattern = Math.random() < 0.5 ? 'swoop' : 'straight';
            batGang.userData.swoopPhase = Math.random() * Math.PI * 2;
            batGang.userData.amplitude = 1 + Math.random();
            batGang.userData.frequency = 0.05 + Math.random() * 0.05;
            return batGang;
        }

        function createItemBox() {
            const rubyGroup = new THREE.Group();
            
            // STUNNING RUBY GEM DESIGN
            // Main ruby body - diamond/gem shape using dodecahedron
            const rubyGeometry = new THREE.DodecahedronGeometry(0.8, 0);
            const rubyMaterial = new THREE.MeshStandardMaterial({
                color: 0xff0040, // Deep ruby red
                metalness: 0.1,
                roughness: 0.05, // Very smooth for gem-like reflections
                emissive: 0xff0020, // Red glow
                emissiveIntensity: 1.2,
                transparent: true,
                opacity: 0.95
            });
            const ruby = new THREE.Mesh(rubyGeometry, rubyMaterial);
            rubyGroup.add(ruby);
            
            // Inner crystal core
            const coreGeometry = new THREE.OctahedronGeometry(0.5, 0);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4080,
                emissive: 0xff4080,
                emissiveIntensity: 2.0,
                transparent: true,
                opacity: 0.8
            });
            const core = new THREE.Mesh(coreGeometry, coreMaterial);
            rubyGroup.add(core);
            
            // Outer energy aura
            const auraGeometry = new THREE.IcosahedronGeometry(1.2, 0);
            const auraMaterial = new THREE.MeshBasicMaterial({
                color: 0xff8888,
                emissive: 0xff4444,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            rubyGroup.add(aura);
            
            rubyGroup.position.y = 0.5;
            rubyGroup.userData.rotationSpeed = 0.03;
            rubyGroup.userData.pulsePhase = Math.random() * Math.PI * 2; // Random start phase
            return rubyGroup;
        }

        function createGreenVial() {
            const vialGroup = new THREE.Group();
            
            // Create green vial collectible
            const vialRadius = 0.2;
            const vialCylinderHeight = 0.6;
            const vialMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ff44, // Bright green color
                metalness: 0.3,
                roughness: 0.2,
                emissive: 0x00cc33, // Bright emissive green
                emissiveIntensity: 1.2,
                transparent: true,
                opacity: 0.9
            });

            // Cylinder part of the vial
            const cylinderGeometry = new THREE.CylinderGeometry(vialRadius, vialRadius, vialCylinderHeight, 12);
            const cylinderMesh = new THREE.Mesh(cylinderGeometry, vialMaterial);
            cylinderMesh.position.y = vialCylinderHeight / 2; 
            vialGroup.add(cylinderMesh);

            // Rounded bottom part of the vial (sphere)
            const sphereGeometry = new THREE.SphereGeometry(vialRadius, 12, 12, 0, Math.PI * 2, 0, Math.PI / 2);
            const sphereMesh = new THREE.Mesh(sphereGeometry, vialMaterial);
            sphereMesh.position.y = 0; 
            sphereMesh.rotation.x = Math.PI; 
            vialGroup.add(sphereMesh);

            // Add glowing effect particles around the vial
            const glowGeometry = new THREE.SphereGeometry(vialRadius * 1.5, 8, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff44,
                transparent: true,
                opacity: 0.3,
                emissive: 0x00ff44,
                emissiveIntensity: 0.5
            });
            const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
            glowSphere.position.y = vialCylinderHeight / 2;
            vialGroup.add(glowSphere);

            vialGroup.position.y = 0.5;
            vialGroup.userData.rotationSpeed = 0.05; // Rotation for visual appeal
            vialGroup.userData.pulsePhase = Math.random() * Math.PI * 2; // Random phase for pulsing
            return vialGroup;
        }

        // DRAGON VISUAL ENHANCEMENT: Updated createDragon function
        function createDragon(tieFighterType = 0) { // 0 = first tieFighter, 1 = mid tieFighter, 2 = final tieFighter
            const tieFighterGroup = new THREE.Group();
            tieFighterGroup.userData.segments = [];
            tieFighterGroup.userData.wingFlapAngle = 0;
            tieFighterGroup.userData.wingFlapDirection = 1;
            tieFighterGroup.userData.wingFlapSpeed = 0.08;
            tieFighterGroup.userData.bodyWaveAngle = 0;
            tieFighterGroup.userData.tieFighterType = tieFighterType;
            tieFighterGroup.userData.stalkPhase = 0;
            tieFighterGroup.userData.stalkSpeed = tieFighterType === 2 ? 0.06 : tieFighterType === 1 ? 0.045 : 0.03;
            tieFighterGroup.userData.stalkAmplitude = tieFighterType === 2 ? 6 : tieFighterType === 1 ? 4.5 : 3;
            tieFighterGroup.userData.circlePhase = 0;
            tieFighterGroup.userData.circleSpeed = tieFighterType === 2 ? 0.03 : tieFighterType === 1 ? 0.022 : 0.015;
            tieFighterGroup.userData.circleRadius = tieFighterType === 2 ? 12 : tieFighterType === 1 ? 9 : 6;
            tieFighterGroup.userData.attackMode = 'stalking';
            tieFighterGroup.userData.attackTimer = 0;
            tieFighterGroup.userData.attackInterval = tieFighterType === 2 ? 150 : tieFighterType === 1 ? 200 : 250;
            tieFighterGroup.userData.faceAnimationPhase = 0;
            tieFighterGroup.userData.isCharging = false;

            const numSegments = tieFighterType === 2 ? 40 : tieFighterType === 1 ? 30 : 20;
            const segmentRadius = tieFighterType === 2 ? 2.0 : tieFighterType === 1 ? 1.3 : 0.6;
            const segmentSpacing = tieFighterType === 2 ? -2.0 : tieFighterType === 1 ? -1.5 : -1.0;

            // Materials
            const blackMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0x000000,
                emissiveIntensity: 0.1
            });

            const neonMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                emissive: 0xff4500,
                emissiveIntensity: 1.5,
                metalness: 0.3,
                roughness: 0.5,
            });

            // Create longer, more serpentine body
            for (let i = 0; i < numSegments; i++) {
                const segmentGeometry = new THREE.SphereGeometry(
                    segmentRadius * (1 - (i / numSegments) * 0.3), // Gentler taper
                    16, 16
                );
                const material = (i % 2 === 0) ? neonMaterial : blackMaterial;
                const segment = new THREE.Mesh(segmentGeometry, material);
                segment.position.z = i * segmentSpacing;
                tieFighterGroup.add(segment);
                tieFighterGroup.userData.segments.push(segment);
            }

            // Enhanced facial features
            const headSegment = tieFighterGroup.userData.segments[0];
            const headGroup = new THREE.Group();

            // Main head shape
            const headGeometry = new THREE.BoxGeometry(segmentRadius * 2, segmentRadius * 1.5, segmentRadius * 2);
            const head = new THREE.Mesh(headGeometry, neonMaterial);
            head.position.z = -segmentRadius;
            headGroup.add(head);

            // More aggressive snout
            const snoutGeometry = new THREE.ConeGeometry(segmentRadius * 1.2, segmentRadius * 2.5, 8);
            const snout = new THREE.Mesh(snoutGeometry, neonMaterial);
            snout.position.z = -segmentRadius * 2;
            snout.rotation.x = Math.PI / 2;
            headGroup.add(snout);

            // Animated jaw
            const jawGeometry = new THREE.BoxGeometry(segmentRadius * 1.8, segmentRadius * 0.4, segmentRadius * 1.2);
            const jaw = new THREE.Mesh(jawGeometry, neonMaterial);
            jaw.position.set(0, -segmentRadius * 0.6, -segmentRadius * 1.5);
            jaw.userData.baseY = jaw.position.y;
            headGroup.add(jaw);
            tieFighterGroup.userData.jaw = jaw;

            // More aggressive eyes
            const eyeGeometry = new THREE.SphereGeometry(segmentRadius * 0.4, 16, 16);
            const eyeMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 2.0
            });
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-segmentRadius * 0.7, segmentRadius * 0.4, -segmentRadius * 0.8);
            headGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(segmentRadius * 0.7, segmentRadius * 0.4, -segmentRadius * 0.8);
            headGroup.add(rightEye);
            tieFighterGroup.userData.eyes = [leftEye, rightEye];

            // Animated whiskers
            const whiskerGeometry = new THREE.CylinderGeometry(0.05, 0.05, segmentRadius * 4, 8);
            const whiskerMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                emissive: 0xff4500,
                emissiveIntensity: 1.0,
                metalness: 0.5,
                roughness: 0.3
            });

            // Left whiskers with animation
            const leftWhisker1 = new THREE.Mesh(whiskerGeometry, whiskerMaterial);
            leftWhisker1.position.set(-segmentRadius * 0.6, segmentRadius * 0.3, -segmentRadius * 2);
            leftWhisker1.rotation.z = Math.PI / 6;
            headGroup.add(leftWhisker1);
            const leftWhisker2 = new THREE.Mesh(whiskerGeometry, whiskerMaterial);
            leftWhisker2.position.set(-segmentRadius * 0.6, segmentRadius * 0.3, -segmentRadius * 2);
            leftWhisker2.rotation.z = Math.PI / 4;
            headGroup.add(leftWhisker2);

            // Right whiskers with animation
            const rightWhisker1 = new THREE.Mesh(whiskerGeometry, whiskerMaterial);
            rightWhisker1.position.set(segmentRadius * 0.6, segmentRadius * 0.3, -segmentRadius * 2);
            rightWhisker1.rotation.z = -Math.PI / 6;
            headGroup.add(rightWhisker1);
            const rightWhisker2 = new THREE.Mesh(whiskerGeometry, whiskerMaterial);
            rightWhisker2.position.set(segmentRadius * 0.6, segmentRadius * 0.3, -segmentRadius * 2);
            rightWhisker2.rotation.z = -Math.PI / 4;
            headGroup.add(rightWhisker2);

            tieFighterGroup.userData.whiskers = [leftWhisker1, leftWhisker2, rightWhisker1, rightWhisker2];
            headSegment.add(headGroup);

            // Remove wings and add flowing body segments
            tieFighterGroup.userData.bodyWaveAngle = 0;
            tieFighterGroup.userData.waveSpeed = 0.05;
            tieFighterGroup.userData.waveAmplitude = 0.3;

            tieFighterGroup.rotation.y = Math.PI;
            tieFighterGroup.userData.speed = tieFighterType === 2 ? 2.5 : tieFighterType === 1 ? 2.0 : 1.5; // MASSIVELY INCREASED BASE SPEEDS
            tieFighterGroup.userData.verticalSpeed = 0.02;
            tieFighterGroup.userData.verticalPhase = 0;
            tieFighterGroup.userData.amplitude = tieFighterType === 2 ? 5 : tieFighterType === 1 ? 3.5 : 2;
            tieFighterGroup.userData.frequency = 0.05;
            tieFighterGroup.userData.stalkDistance = tieFighterType === 2 ? 60 : tieFighterType === 1 ? 45 : 30;
            tieFighterGroup.userData.catchUpSpeed = tieFighterType === 2 ? 0.8 : tieFighterType === 1 ? 0.6 : 0.4; // INCREASED CATCH-UP SPEED

            return tieFighterGroup;
        }

        // NEW GALAXY ZONE: Create AI Wars style ships
        function createGalaxyShip() {
            const shipGroup = new THREE.Group();
            
            // Ship hull with AI Wars aesthetic
            const hullGeometry = new THREE.BoxGeometry(2, 0.8, 4);
            const hullMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a2e,
                metalness: 0.7,
                roughness: 0.3,
                emissive: 0x00ffff,
                emissiveIntensity: 0.2
            });
            const hull = new THREE.Mesh(hullGeometry, hullMaterial);
            shipGroup.add(hull);
            
            // Wings with neon edges
            const wingGeometry = new THREE.BoxGeometry(4, 0.2, 1.5);
            const wingMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a1a,
                metalness: 0.8,
                roughness: 0.2,
                emissive: 0xff00ff,
                emissiveIntensity: 0.3
            });
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-3, 0, 0);
            shipGroup.add(leftWing);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(3, 0, 0);
            shipGroup.add(rightWing);
            
            // Cockpit with glowing effect
            const cockpitGeometry = new THREE.SphereGeometry(0.6, 8, 8);
            const cockpitMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 1.0,
                transparent: true,
                opacity: 0.8
            });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(0, 0.2, 1.5);
            shipGroup.add(cockpit);
            
            // Engine thrusters
            const thrusterGeometry = new THREE.CylinderGeometry(0.3, 0.5, 1, 6);
            const thrusterMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4500,
                emissive: 0xff4500,
                emissiveIntensity: 1.5
            });
            const leftThruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
            leftThruster.position.set(-1.5, -0.2, -2);
            leftThruster.rotation.x = Math.PI / 2;
            shipGroup.add(leftThruster);
            
            const rightThruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial);
            rightThruster.position.set(1.5, -0.2, -2);
            rightThruster.rotation.x = Math.PI / 2;
            shipGroup.add(rightThruster);
            
            // Ship behavior
            shipGroup.userData.speed = 0.3 + Math.random() * 0.2;
            shipGroup.userData.shootTimer = 0;
            shipGroup.userData.shootInterval = 80 + Math.random() * 40;
            shipGroup.userData.driftAngle = Math.random() * Math.PI * 2;
            shipGroup.userData.driftSpeed = 0.02;
            
            return shipGroup;
        }

        // Create galaxy zone projectile
        function createGalaxyProjectile(position, direction) {
            const projectileGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const projectileMaterial = new THREE.MeshBasicMaterial({
                color: 0xff00ff,
                emissive: 0xff00ff,
                emissiveIntensity: 1.5
            });
            const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectile.position.copy(position);
            projectile.userData.velocity = direction.clone().multiplyScalar(1.5);
            projectile.userData.life = 0;
            projectile.userData.maxLife = 300;
            
            return projectile;
        }

        // Create red vial bomb dropped by galaxy ships
        function createGalaxyBomb(position) {
            const bombGroup = new THREE.Group();
            
            // Red vial body - MUCH LARGER AND BRIGHTER
            const vialGeometry = new THREE.CylinderGeometry(0.8, 0.8, 2.5, 8); // Much larger: 0.3->0.8, 1.2->2.5
            const vialMaterial = new THREE.MeshBasicMaterial({ // Changed to MeshBasicMaterial for better visibility
                color: 0xff0000, // Bright red instead of dark red
                emissive: 0xff0000,
                emissiveIntensity: 1.5, // Much brighter
                transparent: true,
                opacity: 0.9
            });
            const vial = new THREE.Mesh(vialGeometry, vialMaterial);
            bombGroup.add(vial);
            
            // Glowing red liquid inside - MUCH LARGER AND BRIGHTER
            const liquidGeometry = new THREE.CylinderGeometry(0.7, 0.7, 2.2, 8); // Much larger: 0.25->0.7, 1.0->2.2
            const liquidMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 2.0, // Much brighter
                transparent: true,
                opacity: 0.8
            });
            const liquid = new THREE.Mesh(liquidGeometry, liquidMaterial);
            bombGroup.add(liquid);
            
            // Cork/cap - LARGER
            const capGeometry = new THREE.CylinderGeometry(0.85, 0.85, 0.4, 8); // Larger: 0.32->0.85, 0.2->0.4
            const capMaterial = new THREE.MeshStandardMaterial({
                color: 0x2F4F4F, // Dark slate gray
                metalness: 0.8,
                roughness: 0.2
            });
            const cap = new THREE.Mesh(capGeometry, capMaterial);
            cap.position.y = 1.45; // Adjusted for larger vial: 0.7->1.45
            bombGroup.add(cap);
            
            // Add outer glow effect for maximum visibility
            const glowGeometry = new THREE.CylinderGeometry(1.0, 1.0, 3.0, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 1.0,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            bombGroup.add(glow);
            
            bombGroup.position.copy(position);
            bombGroup.userData.velocity = new THREE.Vector3(0, 0, 0.3); // Slight forward momentum
            bombGroup.userData.gravity = -0.02; // Falling speed
            bombGroup.userData.life = 0;
            bombGroup.userData.maxLife = 600;
            bombGroup.userData.hasExploded = false;
            
            return bombGroup;
        }


        const powerUpTypes = {
            ghost: { color: 0xff00ff, duration: 5000, message: "Ghost Mode Activated!" },
            magnet: { color: 0xffffff, duration: 6000, message: "Clock Mode!" },
            slowTime: { color: 0xffff00, duration: 4000, message: "Slow Time Activated!" },
            speedBoost: { color: 0xff8800, duration: 3000, message: "Speed Boost!" },
            projectile: { color: 0x00ffff, duration: 0, message: "Use DISCO!" }, // Cyan for DISCO projectiles
            obstacleDrop: { color: 0x8a2be2, duration: 0, message: "Krypton Acquired!" },
            swapPosition: { color: 0xff1493, duration: 0, message: "Position Swapped!" }
        };

        // Optimized power-up creation with shared geometries and materials
        const powerUpGeometries = {
            laser: new THREE.CylinderGeometry(0.1, 0.05, 5.0, 12), // Bigger, tapered laser beam
            core: new THREE.CylinderGeometry(0.15, 0.1, 5.0, 12), // Bigger core
            glow: new THREE.CylinderGeometry(0.25, 0.2, 5.5, 12), // Much bigger glow envelope
            spark: new THREE.SphereGeometry(0.3, 12, 12), // Bigger spark tip
            cube: new THREE.BoxGeometry(1.2, 1.2, 1.2),
            vialCylinder: new THREE.CylinderGeometry(0.15, 0.15, 0.35, 12),
            vialSphere: new THREE.SphereGeometry(0.15, 12, 12, 0, Math.PI * 2, 0, Math.PI / 2)
        };

        const powerUpSharedMaterials = {
            laser: new THREE.MeshBasicMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 5.0, // Much brighter
                transparent: true,
                opacity: 1.0 // Fully opaque for dramatic effect
            }),
            core: new THREE.MeshBasicMaterial({
                color: 0xff6666,
                emissive: 0xff0000,
                emissiveIntensity: 4.0, // Brighter core
                transparent: true,
                opacity: 0.9
            }),
            glow: new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.6, // More visible glow
                emissive: 0xff0000,
                emissiveIntensity: 2.0 // Brighter glow
            }),
            spark: new THREE.MeshBasicMaterial({
                color: 0xffffff,
                emissive: 0xff0000,
                emissiveIntensity: 6.0, // Ultra bright spark tip
                transparent: true,
                opacity: 1.0
            }),
            vial: new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                metalness: 0.2,
                roughness: 0.3,
                emissive: 0x00cc00,
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.75
            })
        };

        function createPowerUp(type) {
            return getPooledObject('powerups', () => {
                const powerUpInfo = powerUpTypes[type];
                const powerUp = new THREE.Group();

                if (type === 'projectile') {
                     // STUNNING CYAN DISCO PROJECTILE - Glowing spinning disk!
                     const discoGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.3, 32); // Wide, thin cylinder = disk
                     const discoMaterial = new THREE.MeshBasicMaterial({
                         color: 0x00ffff, // Cyan color
                         emissive: 0x00ffff,
                         emissiveIntensity: 8.0, // Ultra bright cyan glow
                         transparent: true,
                         opacity: 0.9
                     });
                     const disco = new THREE.Mesh(discoGeometry, discoMaterial);
                     disco.rotation.x = Math.PI / 2; // Rotate to face forward like a spinning disk
                     powerUp.add(disco);
                     
                     // Add outer energy ring for extra glow
                     const outerRingGeometry = new THREE.CylinderGeometry(2.0, 2.0, 0.1, 32);
                     const outerRingMaterial = new THREE.MeshBasicMaterial({
                         color: 0x00ffff,
                         emissive: 0x00ffff,
                         emissiveIntensity: 6.0,
                         transparent: true,
                         opacity: 0.6
                     });
                     const outerRing = new THREE.Mesh(outerRingGeometry, outerRingMaterial);
                     outerRing.rotation.x = Math.PI / 2;
                     powerUp.add(outerRing);
                     
                     // Add central core for intense center glow
                     const coreGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.4, 16);
                     const coreMaterial = new THREE.MeshBasicMaterial({
                         color: 0xffffff, // Bright white center
                         emissive: 0x00ffff,
                         emissiveIntensity: 12.0 // Extremely bright core
                     });
                     const core = new THREE.Mesh(coreGeometry, coreMaterial);
                     core.rotation.x = Math.PI / 2;
                     powerUp.add(core);
                     
                     // Add energy sparks around the edge
                     for (let i = 0; i < 8; i++) {
                         const sparkGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                         const sparkMaterial = new THREE.MeshBasicMaterial({
                             color: 0x00ffff,
                             emissive: 0x00ffff,
                             emissiveIntensity: 10.0
                         });
                         const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                         const angle = (i / 8) * Math.PI * 2;
                         spark.position.x = Math.cos(angle) * 1.3;
                         spark.position.y = Math.sin(angle) * 1.3;
                         spark.position.z = 0;
                         powerUp.add(spark);
                     }
                     
                     console.log("Created stunning DISCO projectile with", powerUp.children.length, "components");

                } else {
                     // Create cubic power-up with green vial inside using shared materials
                     const baseMaterial = new THREE.MeshStandardMaterial({
                         color: powerUpInfo.color,
                         metalness: 0.3,
                         roughness: 0.6,
                         emissive: powerUpInfo.color,
                         emissiveIntensity: 0.8
                     });
                     
                     const mainShape = new THREE.Mesh(powerUpGeometries.cube, baseMaterial);
                     powerUp.add(mainShape);

                     const vialGroup = new THREE.Group();

                     const cylinderMesh = new THREE.Mesh(powerUpGeometries.vialCylinder, powerUpSharedMaterials.vial);
                     cylinderMesh.position.y = 0.175; // vialCylinderHeight / 2
                     vialGroup.add(cylinderMesh);

                     const sphereMesh = new THREE.Mesh(powerUpGeometries.vialSphere, powerUpSharedMaterials.vial);
                     sphereMesh.position.y = 0;
                     sphereMesh.rotation.x = Math.PI;
                     vialGroup.add(sphereMesh);

                     vialGroup.position.y = -0.175; // -(vialCylinderHeight / 2)
                     powerUp.add(vialGroup);
                }

                powerUp.userData.type = type;
                return powerUp;
            });
        }


        const coins = [];
        const obstacles = [];
        const bowlingBallObstacles = [];
        const batGangs = [];
        const activeBursts = [];
        const powerUps = [];
        const itemBoxes = [];
        const activeProjectiles = [];
        const dragons = []; // Array to hold tieFighter instances
        const boostParticles = []; // Array to hold boost particles
        const greenVials = []; // Array to hold green vial collectibles
        
        // NEW GALAXY ZONE SYSTEM (Levels 3-8)
        const galaxyShips = []; // Enemy ships in galaxy zone
        const galaxyProjectiles = []; // Enemy ship projectiles
        const galaxyBombs = []; // Red vial bombs dropped by ships
        let galaxyZoneActive = false;
        let galaxyZoneTimer = 0;
        const galaxyShipSpawnRate = 450; // Spawn frequency
        const maxGalaxyShips = 2; // Max ships on screen
        const bombDropRate = 60; // How often ships drop bombs (reduced from 120 to 60 for more frequent drops)
        
        // NEW VISUAL ENHANCEMENT SYSTEMS
        const etherTrails = []; // Array for Ether collection trails
        const speedLines = []; // Array for dynamic speed lines
        let hyperspaceActive = false; // Hyperspace jump effect state
        let forcePowerActive = false; // Mr. Terrific's helmet DISCO glow state
        
        // CAMERA SHAKE SYSTEM
        const cameraShake = {
            active: false,
            intensity: 0,
            duration: 0,
            timer: 0,
            offsetX: 0,
            offsetY: 0,
            offsetZ: 0
        };

        // LENS FLARE SYSTEM
        const lensFlares = [];
        
        function createLensFlare(light, size = 100, color = 0xffffff) {
            const flareGroup = new THREE.Group();
            
            // Main flare
            const flareGeometry = new THREE.PlaneGeometry(size, size);
            const flareMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            });
            const flare = new THREE.Mesh(flareGeometry, flareMaterial);
            flareGroup.add(flare);
            
            // Secondary flares at different sizes
            for (let i = 0; i < 3; i++) {
                const secondarySize = size * (0.3 + i * 0.2);
                const secondaryGeometry = new THREE.PlaneGeometry(secondarySize, secondarySize);
                const secondaryMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.3 - i * 0.1,
                    blending: THREE.AdditiveBlending,
                    side: THREE.DoubleSide
                });
                const secondaryFlare = new THREE.Mesh(secondaryGeometry, secondaryMaterial);
                secondaryFlare.position.z = (i + 1) * 2;
                flareGroup.add(secondaryFlare);
            }
            
            // Make flares always face camera
            flareGroup.userData.isLensFlare = true;
            flareGroup.userData.light = light;
            scene.add(flareGroup);
            lensFlares.push(flareGroup);
            
            return flareGroup;
        }
        
        function updateLensFlares() {
            for (let i = lensFlares.length - 1; i >= 0; i--) {
                const flare = lensFlares[i];
                const light = flare.userData.light;
                
                if (!light.parent) {
                    // Light has been removed, remove flare
                    scene.remove(flare);
                    lensFlares.splice(i, 1);
                    continue;
                }
                
                // Position flare at light position
                flare.position.copy(light.getWorldPosition(new THREE.Vector3()));
                
                // Make flare face camera
                flare.lookAt(camera.position);
                
                // Adjust opacity based on light intensity
                const intensity = light.intensity;
                flare.children.forEach((child, index) => {
                    if (child.material) {
                        child.material.opacity = (intensity / 2) * (index === 0 ? 0.6 : 0.3 - index * 0.1);
                    }
                });
            }
        }


        const coinSpawnRate = 30; // Increased from 60
        const maxCoins = 30; // Increased from 20
        const obstacleSpawnRate = 300; // Increased from 150 (less frequent obstacles)
        const maxObstacles = 3; // Reduced from 5

        const bowlingBallSpawnRate = 2000; // Increased from 1500 (less frequent)
        const maxBowlingBalls = 2; // Reduced from 3
        const bowlingBallPenalty = 1;

        const batGangSpawnRate = 1200; // Increased from 900 (less frequent)
        const maxBatGangs = 1; // Reduced from 2

        const powerUpSpawnRate = 600; // Reduced from 1200 (more frequent power-ups)
        const maxPowerUps = 4; // Increased from 3

        const itemBoxSpawnRate = 300; // Reduced from 600 (more frequent item boxes)
        const maxItemBoxes = 6; // Increased from 5

        const greenVialSpawnRate = 200; // Spawn rate for green vials (more frequent for testing)
        const maxGreenVials = 3; // Maximum green vials on screen

        const projectileSpeed = 2.4; // 2x faster: 1.2 -> 2.4
        const tieFighterSpeed = 0.4; // Reduced from 0.5


        let score = 0;
        const scoreDisplay = document.getElementById('score');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreDisplay = document.getElementById('final-score');
        const finalLevelDisplay = document.getElementById('final-level'); // Get the new element
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        
        // Debug restart button setup
        if (!restartButton) {
            console.error("Restart button not found!");
        } else {
            console.log("Restart button found:", restartButton);
            
            // Test if button is clickable
            setTimeout(() => {
                console.log("Testing restart button after page load...");
                console.log("Button style:", window.getComputedStyle(restartButton));
                console.log("Button disabled:", restartButton.disabled);
                console.log("Button parent element:", restartButton.parentElement);
            }, 2000);
        }
        const gameFooter = document.querySelector('.game-footer');
        // const boostSound = document.getElementById('boost-sound');


        const dialogueBox = document.getElementById('dialogue-box');
        const boostButton = document.getElementById('boost-button');
        const blasterButton = document.getElementById('blaster-button');
        const miniBoostButton = document.getElementById('mini-boost-button');
        const lightningFlashElement = document.getElementById('lightning-flash');
        const levelUpPopup = document.getElementById('level-up-popup');
        const levelDisplay = document.getElementById('level-display');
        // Removed welcomeMessageElement reference
        const powerUpDisplay = document.getElementById('power-up-display');


         const mobileControlsDiv = document.querySelector('.mobile-controls');
         const steerLeftButton = document.getElementById('steer-left-button');
         const steerRightButton = document.getElementById('steer-right-button');
         const usePowerUpButton = document.getElementById('use-power-up-button');


        let isGameOver = false;
        let gameMode = 'manual';
        let crashPosition = new THREE.Vector3();
        let isBoosting = false;
        let manualBoostsUsed = 0; // Track manual boosts used this level bracket
        let isMiniBoostActive = false;
        let miniBoostTimer = null;
        let isGameRunning = false;
        let isInvincible = false;
        let invincibilityTimer = null;
        let gamePaused = false;
        let isFirstLaunch = true;


        let isGhostActive = false;
        let ghostTimer = null;
        let ghostPulsePhase = 0; // For ghost pulsing effect
        let isMagnetActive = false;
        let magnetTimer = null;
        let isSlowTimeActive = false;
        let slowTimeTimer = null;
        let slowTimeFactor = 0.5;
        let hasProjectile = false;
        let hasObstacleDrop = false;
        let hasSwapPosition = false;



        // VIBES system
        let remainingBlasterBolts = 0;
        let maxBlasterBolts = 0;
        let blasterBoltsUsed = 0;
        let isBlasterActive = false;
        let blasterDuration = 2000; // 2 seconds


        let level = 1;
        let levelThreshold = 5;
        const baseAiBikes = 3;
        const GRAND_PRIZE_LEVEL = 100;
        const BOOST_UNLOCK_LEVEL = 2; // Changed from 10 to 2
        const DRAGON_LEVELS = [10, 50, 90]; // Added level 50 tieFighter

        // Add extreme difficulty level constant
        const EXTREME_DIFFICULTY_LEVEL = 60;

        // Speed increase limit level
        const SPEED_INCREASE_LIMIT_LEVEL = 75;


        const initialBaseMoveSpeed = (isCustomized && window.gameCustomizations) ? window.gameCustomizations.baseSpeed : 1.0; // Increased by 25% from 0.8 to 1.0
        let baseMoveSpeed = initialBaseMoveSpeed;
        let moveSpeed = baseMoveSpeed;
        let currentMoveSpeed = baseMoveSpeed; // Make currentMoveSpeed global for stats tracking
        const speedIncreaseRate = 0.00004; // Increased slightly for faster progression
        const maxMoveSpeed = 2.0; // Increased by 25% from 1.6 to 2.0
        const baseSpeedIncreasePerLevel = 0.0146; // Recalculated for new max speed (25% increase)

        let steerSpeed = 0.10; // Increased from 0.08 for more responsive steering
        let currentSteerAngle = 0;
        let targetSteerAngle = 0;
        const steerInterpolationSpeed = 0.12; // Increased from 0.08 for more responsive feel
        const maxSteerAngle = 0.32; // Slightly increased from 0.3 for better maneuverability
        let steerMomentum = 0;
        const momentumDecay = 0.985; // Slightly increased from 0.98 for smoother momentum
        const maxMomentum = 0.10; // Reduced from 0.12 for more control
        let lastSteerInput = 0;
        const inputSmoothing = 0.15; // Increased from 0.12 for smoother input
        let lateralVelocity = 0; // Add lateral velocity for smoother movement
        const lateralDamping = 0.94; // Increased from 0.92 for better damping

        let playerRandomSteerDirection = 0;
        let playerRandomSteerTimer = 0;
        const playerRandomSteerInterval = 120;
        const playerRandomSteerChance = 0.1;

         const aiSteerSpeed = 0.005;
         const aiRandomSteerInterval = 90;
         const aiRandomSteerChance = 0.2;


        const roadEdgeThreshold = (roadWidth / 2) - 0.5;

        const resetThreshold = -roadLength / 4;
        const sceneryChangeDistance = roadLength / 2;
        let lastSceneryChangeZ = 0;

        let playerManualSteerDirection = 0;

        const keys = {};

        let isJumping = false;
        let jumpVelocity = 0;
        const jumpPower = 0.5;
        const gravity = -0.03;

        let coinsForPowerUp = 0;
        const coinsNeededForPowerUp = 15;
        const powerUpDuration = 2500;
        const powerUpCoinBonus = 3;

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        Tone.setContext(audioContext);

        const shieldSynth = new Tone.Synth().toDestination();
        const magnetSynth = new Tone.Synth().toDestination();
        const slowTimeSynth = new Tone.Synth().toDestination();
        const coinSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
        const crashNoise = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.2 } }).toDestination();
        const itemBoxSynth = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
        // Increased projectile synth volume
        const projectileSynth = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 } }).toDestination().set({ volume: -5 }); // Increased volume (less negative dB)
        const explosionSynth = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 } }).toDestination(); // Added explosion sound
        
        // NEW ENHANCED AUDIO SYSTEM
        const engineSynth = new Tone.Oscillator(60, "sawtooth").toDestination().set({ volume: -20 }); // Engine sound
        const ambientSynth = new Tone.AMSynth().toDestination().set({ volume: -25 }); // Ambient music
        const forceSynth = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.2, decay: 0.5, sustain: 0.3, release: 1.0 } }).toDestination().set({ volume: -10 }); // Force power sounds
        const hyperspaceNoise = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.1, decay: 0.3, sustain: 0.2, release: 0.5 } }).toDestination().set({ volume: -8 }); // Hyperspace effect
        
        // Star Wars ambient music simulation
        let ambientMusicActive = false;
        let ambientMusicInterval = null;
        let audioSystemEnabled = false; // Audio OFF by default
        
        // DIFFICULTY SYSTEM
        let gameDifficulty = 'normal';
        const difficultySettings = {
            normal: {
                multiplier: 1.0,
                name: 'Normal',
                description: 'Balanced gameplay for all pilots'
            },
            hard: {
                multiplier: 1.5,
                name: 'Hard',
                description: 'Faster enemies, less margin for error'
            },
            insane: {
                multiplier: 2.0,
                name: 'Insane',
                description: 'Extreme speed, only for Jedi Masters'
            }
        };
        
        // SESSION STATS TRACKING
        const sessionStats = {
            distanceTraveled: 0,
            enemiesDefeated: 0,
            etherCollected: 0,
            startTime: 0,
            sessionTime: 0,
            maxSpeed: 0,
            hyperspaceJumps: 0,
            powerUpsUsed: 0
        };
        
        // LEADERBOARD TRACKING VARIABLES
        let totalEnemiesDefeated = 0;
        let totalDiscoProjectiles = 0;
        let sessionStartTime = Date.now();
        let lastLeaderboardCheck = 0; // For showing motivational messages
        let playerName = "Player One"; // Default player name
        
        // Pause timing variables
        let pauseStartTime = 0;
        let totalPausedTime = 0;
        
        // Animation frame management
        window.animationFrameId = null;
        
        // Helper function to get adjusted time (accounting for paused time)
        function getAdjustedTime() {
            return Date.now() - totalPausedTime;
        }
        
        const powerUpActivateSynth = new Tone.Synth().toDestination(); // Synth for power-up activation
        const boostSound = new Tone.Player({
            url: "https://assets.mixkit.co/sfx/preview/mixkit-sci-fi-rocket-engine-1320.mp3",
            loop: true,
        }).toDestination();

        // DRAGON SOUND REMOVED: tieFighterRoarSynth definition commented out
        /*
        const tieFighterRoarSynth = new Tone.NoiseSynth({
            noise: { type: 'brown' },
            envelope: {
                attack: 0.2,
                decay: 1.5,
                sustain: 0.1,
                release: 0.8
            },
            volume: -2
        }).toDestination();
        */


        window.addEventListener('keydown', (event) => {
            keys[event.key] = true;
            
            // Game controls
            if (event.key === ' ' && !isJumping && isGameRunning && (gameMode === 'manual' || gameMode === 'auto') && !gamePaused) {
                 startJump();
            }
            if ((event.key === 'e' || event.key === 'E') && !isMobileDevice()) {
                usePowerUp();
            }
            if (event.key === 'ArrowUp' && !isMobileDevice() && isGameRunning && !gamePaused && level >= BOOST_UNLOCK_LEVEL) {
                activateBoost(3000, true); // Manual boost
            }
            if ((event.key === 'f' || event.key === 'F') && !isMobileDevice() && isGameRunning && !gamePaused) {
                activateBlasterBolt();
            }
            if ((event.key === 's' || event.key === 'S') && !isMobileDevice() && isGameRunning && !gamePaused) {
                activateMiniBoost();
            }
            
            // Settings menu controls
            if (event.key === 'Tab') {
                event.preventDefault();
                toggleSettingsMenu();
            }
            if (event.key === 'Escape') {
                const settingsMenu = document.getElementById('settings-menu');
                if (settingsMenu.style.display === 'block') {
                    // Close settings menu and resume game
                    settingsMenu.style.display = 'none';
                    if (isGameRunning && !isGameOver && gamePaused) {
                        gamePaused = false;
                        document.getElementById('pause-overlay').style.display = 'none';
                        animate(); // Resume game loop
                    }
                }
            }
            
            // Customization controls
            if (event.key === '1') {
                changeBikeSkin('prev');
            }
            if (event.key === '2') {
                changeBikeSkin('next');
            }
            if (event.key === '3') {
                changeTrailEffect('prev');
            }
            if (event.key === '4') {
                changeTrailEffect('next');
            }
            if (event.key === '5') {
                changeRiderOutfit('prev');
            }
            if (event.key === '6') {
                changeRiderOutfit('next');
            }
            
            // Pause game with P key
            if (event.key === 'p' || event.key === 'P') {
                togglePause();
            }
            
            // Toggle game instructions with I key
            if (event.key === 'i' || event.key === 'I') {
                toggleGameInstructions();
            }
            
            // Toggle audio system with M key
            if (event.key === 'm' || event.key === 'M') {
                toggleAudioSystem();
            }
        });

        window.addEventListener('keyup', (event) => {
            keys[event.key] = false;
        });

        // Add click/tap to pause functionality
        document.addEventListener('click', handleScreenTap);
        document.addEventListener('touchstart', handleScreenTap);

        // Prevent context menu on right click to avoid interference
        document.addEventListener('contextmenu', (event) => {
            event.preventDefault();
        });

        // LEADERBOARD EVENT HANDLERS
        document.getElementById('leaderboard-link').addEventListener('click', (e) => {
            e.preventDefault();
            displayLeaderboard();
        });

        document.getElementById('close-leaderboard').addEventListener('click', () => {
            document.getElementById('leaderboard-modal').style.display = 'none';
        });



        document.getElementById('clear-leaderboard').addEventListener('click', () => {
            if (confirm('Are you sure you want to reset all scores? This cannot be undone!')) {
                leaderboard.clearScores();
                displayLeaderboard(); // Refresh the display
            }
        });

        // Close modals when clicking outside them
        document.getElementById('leaderboard-modal').addEventListener('click', (e) => {
            if (e.target.id === 'leaderboard-modal') {
                document.getElementById('leaderboard-modal').style.display = 'none';
            }
        });

        // Twitter Share Button Event Handler
        document.getElementById('twitter-share-button').addEventListener('click', () => {
            const playerNameText = playerName ? ` by ${playerName}` : '';
            const tweetText = `ðŸ§ª Finished crazy run at TRONS${playerNameText}!
âš¡ Sector Level: ${level}
ðŸ”´ ETHER Score: ${score}
Try yourself at https://trons.io!

#TRONS #Gaming #Web3`;
            const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(tweetText)}`;
            window.open(twitterUrl, '_blank', 'width=550,height=420');
        });

        const dialogueMessages = [
            "Fair Play prevails...",
            "I have a bad feeling about this!",
            "The Empire strikes back...",
            "These aren't the droids you're looking for!",
            "The faster I go, the closer to lightspeed.",
            "Racing through city tunnels.",
            "Imperial entanglements ahead!",
            "The Force will be with you, always.",
            "Justice credits scattered on streets.",
                            "Use DISCO, Terrific!",
            "Watch out for Imperial patrols!",
            "Another Imperial speeder spotted!",
            "tieFighter formation detected!",
                            "The Jackpot is within reach!",
            "Star Destroyer approaching...",
            "The Force flows through everything..."
        ];
        let dialogueTimer = 0;
        const dialogueInterval = 900;

        let lightningTimer = 0;
        const lightningInterval = 1500;
        const lightningDuration = 100;

        let obstacleSpeedMultiplier = 1.5;

                        // Update the rider colors array for Mr. Terrific's appearance
        const riderColors = [
            0xFFE4B5, // Level 1: Light skin tone (Mr. Terrific's complexion)
            0xFFE4B5, // Level 2: Keep skin tone
            0xFFE4B5, // Level 3: Keep skin tone
            0xFFE4B5, // Level 4: Keep skin tone
            0xFFE4B5, // Level 5: Keep skin tone
            0xFFE4B5, // Level 6: Keep skin tone
            0xFFE4B5, // Level 7: Keep skin tone
            0xFFE4B5, // Level 8: Keep skin tone
            0xFFE4B5  // Level 9: Keep skin tone
        ];

        function isMobileDevice() {
             return window.innerWidth <= 768;
        }
        
        // MOBILE SWIPE-TO-STEER SYSTEM
        let touchStartX = 0;
        let touchCurrentX = 0;
        let swipeSteerDirection = 0;
        
        // Touch event handlers for swipe steering
        document.addEventListener('touchstart', (e) => {
            if (isMobileDevice() && isGameRunning && !isGameOver && !gamePaused) {
                touchStartX = e.touches[0].clientX;
                touchCurrentX = touchStartX;
            }
        });
        
        document.addEventListener('touchmove', (e) => {
            if (isMobileDevice() && isGameRunning && !isGameOver && !gamePaused) {
                e.preventDefault(); // Prevent scrolling
                touchCurrentX = e.touches[0].clientX;
                const swipeDistance = touchCurrentX - touchStartX;
                const swipeThreshold = 50; // Minimum swipe distance
                
                if (Math.abs(swipeDistance) > swipeThreshold) {
                    swipeSteerDirection = swipeDistance > 0 ? -1 : 1; // Invert for natural feel
                } else {
                    swipeSteerDirection = 0;
                }
            }
        });
        
        document.addEventListener('touchend', (e) => {
            if (isMobileDevice()) {
                swipeSteerDirection = 0; // Reset steering when touch ends
            }
        });

         function updateMobileControlVisibility() {
             if (isMobileDevice() && isGameRunning && !isGameOver && !gamePaused) {
                 mobileControlsDiv.style.display = 'flex';
                 
                 // Only show power-up button if player has a power-up
                 if (hasProjectile || hasObstacleDrop) {
                     usePowerUpButton.style.display = 'flex';
                 } else {
                     usePowerUpButton.style.display = 'none';
                 }
             } else {
                 mobileControlsDiv.style.display = 'none';
                 usePowerUpButton.style.display = 'none';
             }
         }

        function setGameUIVisibility(visible) {
            const display = visible ? 'block' : 'none';
            scoreDisplay.style.display = display;
            // jackpotDisplay removed - no longer needed
            levelDisplay.style.display = display;
            boostButton.style.display = display;
            blasterButton.style.display = display;
            miniBoostButton.style.display = display;
            powerUpDisplay.style.display = display;
            gameFooter.style.display = visible && !isGameOver ? 'flex' : 'none';
        }


        function getPlayerAISteerDirection() {
            playerRandomSteerTimer++;
            if (playerRandomSteerTimer >= playerRandomSteerInterval || Math.random() < playerRandomSteerChance) {
                playerRandomSteerDirection = (Math.random() - 0.5) * 2;
                playerRandomSteerTimer = 0;
            }
            const motorcycleX = playerMotorcycle.position.x;
            const centerOffset = -motorcycleX * 0.002;
            let aiSteer = playerRandomSteerDirection * 0.05 + centerOffset;
            aiSteer = Math.max(-1, Math.min(1, aiSteer));
            return aiSteer;
        }

        function getPlayerManualSteerDirection() {
            let manualSteer = 0;
            if (!isMobileDevice() && gameMode === 'manual') {
                 if (keys['ArrowLeft'] || keys['a']) {
                     manualSteer = 1;
                 } else if (keys['ArrowRight'] || keys['d']) {
                     manualSteer = -1;
                 }
            }
             if (isMobileDevice() && gameMode === 'manual') {
                 // Check for button presses
                 if (steerLeftButton.classList.contains('active')) {
                     manualSteer = 1;
                 } else if (steerRightButton.classList.contains('active')) {
                     manualSteer = -1;
                 }
                 // Override with swipe steering if active
                 if (swipeSteerDirection !== 0) {
                     manualSteer = swipeSteerDirection;
                 }
             }
            return manualSteer;
        }

        function automateAIMotorcycle(aiBike) {
             // Only move the AI if canMove is true
             if (!aiBike.userData.canMove) return;

             const difficultyMultiplier = difficultySettings[gameDifficulty].multiplier;
             const currentAiMoveSpeed = isSlowTimeActive ? 
                 aiBike.userData.moveSpeed * slowTimeFactor * difficultyMultiplier : 
                 aiBike.userData.moveSpeed * difficultyMultiplier;
             aiBike.position.z -= currentAiMoveSpeed;

            aiBike.userData.targetTimer++;
            if (aiBike.userData.targetTimer >= 90 || Math.random() < 0.2) {
                 aiBike.userData.targetX = (Math.random() - 0.5) * (roadWidth - 1);
                 aiBike.userData.targetTimer = 0;
            }

            const steeringDifference = aiBike.userData.targetX - aiBike.position.x;
            const steerMagnitude = Math.min(aiBike.userData.steerSpeed, Math.abs(steeringDifference) * 0.05);

            let steeringDirection = 0;
            if (steeringDifference < -0.1) {
              steeringDirection = -1;
            } else if (steeringDifference > 0.1) {
              steeringDirection = 1;
            }
            aiBike.position.x += steeringDirection * steerMagnitude;
            aiBike.rotation.y = steeringDirection * 0.1;
            aiBike.rotation.x = 0;
            aiBike.rotation.z = 0;

            const aiBikeX = aiBike.position.x;
            if (aiBikeX < -roadEdgeThreshold) {
                 aiBike.position.x = -roadEdgeThreshold;
            } else if (aiBikeX > roadEdgeThreshold) {
                 aiBike.position.x = roadEdgeThreshold;
            }

             const lookAheadDistance = 10;
             const currentAiPosition = aiBike.position.clone();
             const aiForward = new THREE.Vector3(0, 0, -1).applyQuaternion(aiBike.quaternion);
             const lookAheadPoint = currentAiPosition.clone().add(aiForward.multiplyScalar(lookAheadDistance));
             let avoidDirection = 0;

             for (const obstacle of obstacles) {
                 const distToObstacle = lookAheadPoint.distanceTo(obstacle.position);
                 const avoidanceRadius = 3;
                 if (distToObstacle < avoidanceRadius) {
                     const obstacleRelativeX = obstacle.position.x - aiBike.position.x;
                     avoidDirection = obstacleRelativeX > 0 ? -1 : 1;
                     break;
                 }
             }

             if (avoidDirection === 0) {
                  for (const bowlingBall of bowlingBallObstacles) {
                      const distToBowlingBall = lookAheadPoint.distanceTo(bowlingBall.position);
                      const avoidanceRadius = 3;
                      if (distToBowlingBall < avoidanceRadius) {
                          const ballRelativeX = bowlingBall.position.x - aiBike.position.x;
                          avoidDirection = ballRelativeX > 0 ? -1 : 1;
                          break;
                      }
                  }
             }

             if (avoidDirection !== 0) {
                 aiBike.position.x += avoidDirection * aiBike.userData.steerSpeed * 1.5;
             }

             for (let i = coins.length - 1; i >= 0; i--) {
                 const coin = coins[i];
                 const distance = aiBike.position.distanceTo(coin.position);
                 const coinCollectionThreshold = 1.0;
                 if (distance < coinCollectionThreshold) {
                     scene.remove(coin);
                     coins.splice(i, 1);
                     // console.log('AI collected a coin!');
                 }
             }
        }

         function moveBatGang(batGang) {
             const currentBatGangSpeed = isSlowTimeActive ? batGang.userData.speed * slowTimeFactor : batGang.userData.speed;
             batGang.position.z += currentBatGangSpeed * baseMoveSpeed * 1.2; // Bats chase player at reasonable speed
             if (batGang.userData.attackPattern === 'swoop') {
                 batGang.userData.swoopPhase += batGang.userData.frequency;
                 batGang.position.y = 2 + Math.sin(batGang.userData.swoopPhase) * batGang.userData.amplitude;
             }
             if (batGang.position.z > playerMotorcycle.position.z + 20) {
                 scene.remove(batGang);
                 batGangs.splice(batGangs.indexOf(batGang), 1);
                 // console.log('Bat gang removed.');
             }
         }

        // DRAGON VISUAL ENHANCEMENT: Updated moveDragon function for new visuals
        function moveDragon(tieFighter) {
            tieFighter.userData.attackTimer++;
            
            // Calculate distance to player for proximity-based behavior
            const distanceToPlayer = tieFighter.position.distanceTo(playerMotorcycle.position);
        
            // --- Attack Logic ---
            if (tieFighter.userData.attackTimer > tieFighter.userData.attackInterval && !tieFighter.userData.isCharging) {
                tieFighter.userData.isCharging = true;
                tieFighter.userData.attackTimer = 0; // Reset timer for next charge
                // Add a visual cue for charging
                tieFighter.userData.segments.forEach(segment => {
                    if(segment.material.emissive) {
                        segment.material.emissiveIntensity = 3.0; // Glow brightly
                    }
                });
                
                // Alert player of incoming attack
                setMessage("âš ï¸ STRONGHOLD CHARGING ATTACK!");
            }
        
            let currentTieFighterSpeed;
            if (tieFighter.userData.isCharging) {
                // Significantly higher speed during a charge - VERY AGGRESSIVE
                currentTieFighterSpeed = tieFighter.userData.speed * 3.5; // INCREASED FROM 2.5 TO 3.5 FOR MAXIMUM THREAT
                // Charge for a longer duration to be more threatening
                if (tieFighter.userData.attackTimer > 90) { // 1.5 second charge at 60fps
                    tieFighter.userData.isCharging = false;
                    // Restore normal glow
                    tieFighter.userData.segments.forEach(segment => {
                        if(segment.material.emissive) {
                            segment.material.emissiveIntensity = 1.5;
                        }
                    });
                    setMessage("ðŸ’€ Stronghold attack completed!");
                }
            } else {
                // PERSISTENT CHASING: Speed depends on distance to maintain pressure
                if (distanceToPlayer > 30) {
                    // Far away - speed up significantly to catch up
                    currentTieFighterSpeed = tieFighter.userData.speed * 2.2; // INCREASED FROM 1.8 TO 2.2
                } else if (distanceToPlayer > 15) {
                    // Medium distance - normal chase speed
                    currentTieFighterSpeed = tieFighter.userData.speed * 1.8; // INCREASED FROM 1.3 TO 1.8
                } else {
                    // Close - still aggressive but controlled
                    currentTieFighterSpeed = tieFighter.userData.speed * 1.2; // INCREASED FROM 0.9 TO 1.2
                }
            }
        
            // Apply slow time effect
            if (isSlowTimeActive) {
                currentTieFighterSpeed *= slowTimeFactor;
            }
        
            // --- Movement Logic ---
            const direction = new THREE.Vector3().subVectors(playerMotorcycle.position, tieFighter.position).normalize();
            
            // AGGRESSIVE MOVEMENT: Always move toward player
            tieFighter.position.add(direction.multiplyScalar(currentTieFighterSpeed));
        
            // SMART POSITIONING: Try to get behind or to the side of player for flanking
            const targetX = playerMotorcycle.position.x + (Math.sin(Date.now() * 0.002) * 2); // Weave side to side
            tieFighter.position.x += (targetX - tieFighter.position.x) * 0.05; // Increased responsiveness
        
            // Maintain vertical oscillation but keep it above the road
            tieFighter.userData.verticalPhase += tieFighter.userData.frequency;
            tieFighter.position.y = Math.max(2.0, 6 + Math.sin(tieFighter.userData.verticalPhase) * tieFighter.userData.amplitude);
        
            // Make the tieFighter look at the player menacingly
            tieFighter.lookAt(playerMotorcycle.position);
            
            // THREAT PROXIMITY WARNINGS WITH PERIODIC REMINDERS
            if (!tieFighter.userData.reminderTimer) tieFighter.userData.reminderTimer = 0;
            tieFighter.userData.reminderTimer++;
            
            if (distanceToPlayer < 20 && distanceToPlayer > 15) {
                if (Math.random() < 0.01) { // Occasional warning
                    setMessage("ðŸ”´ STRONGHOLD APPROACHING!");
                }
            } else if (distanceToPlayer < 10) {
                if (Math.random() < 0.02) { // More frequent warnings when very close
                    setMessage("ðŸ’€ STRONGHOLD IMMINENT THREAT!");
                }
            }
            
            // PERIODIC PRESENCE REMINDER - every 8 seconds (480 frames at 60fps)
            if (tieFighter.userData.reminderTimer >= 480) {
                if (distanceToPlayer < 50) { // Only if reasonably close
                    const messages = [
                        "ðŸ‘ï¸ Stronghold still hunting you...",
                        "âš ï¸ Don't forget the stronghold behind you!",
                        "ðŸ’€ Stronghold maintaining pursuit...",
                        "ðŸŽ¯ You can't shake the stronghold!"
                    ];
                    setMessage(messages[Math.floor(Math.random() * messages.length)]);
                }
                tieFighter.userData.reminderTimer = 0;
            }
        
            // PERSISTENT THREAT: Only remove if player gets VERY far ahead (much more lenient)
            if (tieFighter.position.z > playerMotorcycle.position.z + 150) {
                scene.remove(tieFighter);
                dragons.splice(dragons.indexOf(tieFighter), 1);
                setMessage("ðŸŽ¯ Stronghold lost your trail... for now.");
            }
            
            // COLLISION DETECTION: Damage player if stronghold gets too close
            if (distanceToPlayer < 3.0 && !isGhostActive && !isInvincible) {
                if (score > 0) score = Math.max(0, score - 5);
                updateScoreDisplay();
                setMessage("ðŸ’¥ STRONGHOLD IMPACT! --5 ETHER");
                
                // Push stronghold back slightly after impact
                const pushDirection = direction.clone().multiplyScalar(-10);
                tieFighter.position.add(pushDirection);
                
                // Give player brief invincibility after impact
                isInvincible = true;
                setTimeout(() => {
                    isInvincible = false;
                }, 2000); // 2 seconds of invincibility
            }
        }

        // NEW GALAXY ZONE SYSTEM
        function updateGalaxyZone() {
            galaxyZoneTimer++;
            
            // Spawn galaxy ships
            if (galaxyShips.length < maxGalaxyShips && Math.random() < 1 / galaxyShipSpawnRate) {
                const ship = createGalaxyShip();
                ship.position.set(
                    (Math.random() - 0.5) * roadWidth * 1.5,
                    3 + Math.random() * 4,
                    playerMotorcycle.position.z - 80 - Math.random() * 60
                );
                scene.add(ship);
                galaxyShips.push(ship);
                console.log("Galaxy ship spawned at level", level);
            }
            
            // Update galaxy ships
            for (let i = galaxyShips.length - 1; i >= 0; i--) {
                const ship = galaxyShips[i];
                
                // Ship movement with drift pattern
                ship.userData.driftAngle += ship.userData.driftSpeed;
                ship.position.x += Math.sin(ship.userData.driftAngle) * 0.05;
                ship.position.z += ship.userData.speed;
                
                // Ship shooting behavior
                ship.userData.shootTimer++;
                if (ship.userData.shootTimer >= ship.userData.shootInterval) {
                    // Calculate direction to player
                    const direction = new THREE.Vector3()
                        .subVectors(playerMotorcycle.position, ship.position)
                        .normalize();
                    
                    // Create projectile
                    const projectile = createGalaxyProjectile(ship.position.clone(), direction);
                    scene.add(projectile);
                    galaxyProjectiles.push(projectile);
                    
                    // Play shooting sound
                    projectileSynth.triggerAttackRelease('A4', '8n');
                    
                    ship.userData.shootTimer = 0;
                    ship.userData.shootInterval = 60 + Math.random() * 80; // Reset with some randomness
                }
                
                // Ship bomb dropping behavior
                if (!ship.userData.bombTimer) ship.userData.bombTimer = 0;
                ship.userData.bombTimer++;
                if (ship.userData.bombTimer >= bombDropRate && Math.random() < 0.8) { // Increased probability from 0.6 to 0.8
                    // Drop red vial bomb
                    const bomb = createGalaxyBomb(ship.position.clone());
                    scene.add(bomb);
                    galaxyBombs.push(bomb);
                    
                    console.log("Red vial bomb dropped at position:", bomb.position); // Debug message
                    setMessage("ðŸ’£ Enemy ship dropped a red vial bomb!"); // Visual feedback
                    
                    // Play bomb drop sound
                    projectileSynth.triggerAttackRelease('C3', '8n');
                    
                    ship.userData.bombTimer = 0;
                }
                
                // Remove ships that are too far behind or ahead
                if (ship.position.z > playerMotorcycle.position.z + 100 || 
                    ship.position.z < playerMotorcycle.position.z - 200) {
                    scene.remove(ship);
                    galaxyShips.splice(i, 1);
                }
            }
            
            // Update galaxy projectiles
            for (let i = galaxyProjectiles.length - 1; i >= 0; i--) {
                const projectile = galaxyProjectiles[i];
                
                // Move projectile
                projectile.position.add(projectile.userData.velocity);
                projectile.userData.life++;
                
                // Check collision with player
                const distance = playerMotorcycle.position.distanceTo(projectile.position);
                if (distance < 2.0 && !isGhostActive) {
                    // Player hit by galaxy projectile
                    createExplosion(projectile.position, 0xff00ff);
                    explosionSynth.triggerAttackRelease("8n");
                    
                    // Damage or effect
                                         if (score > 0) score = Math.max(0, score - 2);
                     updateScoreDisplay();
                    setMessage("âš¡ Hit by enemy fire! --2 ETHER");
                    
                    // Remove projectile
                    scene.remove(projectile);
                    galaxyProjectiles.splice(i, 1);
                    continue;
                }
                
                // Remove old projectiles
                if (projectile.userData.life > projectile.userData.maxLife ||
                    projectile.position.z > playerMotorcycle.position.z + 50) {
                    scene.remove(projectile);
                    galaxyProjectiles.splice(i, 1);
                }
            }
            
            // Update galaxy bombs
            for (let i = galaxyBombs.length - 1; i >= 0; i--) {
                const bomb = galaxyBombs[i];
                bomb.userData.life++;
                
                // Apply gravity and movement
                bomb.userData.velocity.y += bomb.userData.gravity;
                bomb.position.add(bomb.userData.velocity);
                
                // Rotate bomb as it falls
                bomb.rotation.x += 0.05;
                bomb.rotation.z += 0.03;
                
                // Check collision with player
                const distanceToPlayer = bomb.position.distanceTo(playerMotorcycle.position);
                if (distanceToPlayer < 2.5 && !isGhostActive && !bomb.userData.hasExploded) {
                    // Hit player with bomb - more damage than projectiles
                    createExplosion(bomb.position.clone(), 0xff0000);
                    explosionSynth.triggerAttackRelease("8n");
                    
                                         if (score > 0) score = Math.max(0, score - 3);
                     updateScoreDisplay();
                    setMessage("ðŸ’£ Hit by red vial bomb! --3 ETHER");
                    
                    bomb.userData.hasExploded = true;
                    
                    // Remove bomb
                    scene.remove(bomb);
                    galaxyBombs.splice(i, 1);
                    continue;
                }
                
                // Check if bomb hits ground/road
                if (bomb.position.y <= -1 && !bomb.userData.hasExploded) {
                    // Bomb hits ground - create explosion effect
                    createExplosion(bomb.position.clone(), 0xff4500); // Orange-red explosion
                    explosionSynth.triggerAttackRelease("8n");
                    
                    bomb.userData.hasExploded = true;
                }
                
                // Remove bomb if too old, exploded, or too far
                if (bomb.userData.life > bomb.userData.maxLife || 
                    bomb.userData.hasExploded ||
                    bomb.position.z > playerMotorcycle.position.z + 50 ||
                    bomb.position.z < playerMotorcycle.position.z - 50) {
                    scene.remove(bomb);
                    galaxyBombs.splice(i, 1);
                }
            }
        }

        function showRandomDialogue() {
            if (dialogueMessages.length === 0 || isGameOver || !isGameRunning || gamePaused) return;
            const randomIndex = Math.floor(Math.random() * dialogueMessages.length);
            dialogueBox.textContent = dialogueMessages[randomIndex];
            dialogueBox.style.display = 'block';
            setTimeout(() => {
                dialogueBox.style.display = 'none';
            }, 3000);
        }

         function setMessage(message) {
             dialogueBox.textContent = message;
             dialogueBox.style.display = 'block';
             setTimeout(() => {
                 dialogueBox.style.display = 'none';
             }, 3000);
         }


        // Update lightning effect for more impact
        function createLightningStrike() {
            if (isGameOver || !isGameRunning || gamePaused) return;
            lightningLight.intensity = 8; // Increased from 5
            lightningFlashElement.style.display = 'block';
            lightningFlashElement.style.backgroundColor = 'rgba(255, 255, 255, 0.9)'; // Increased opacity
            setTimeout(() => {
                lightningLight.intensity = 0;
                lightningFlashElement.style.display = 'none';
            }, lightningDuration);
        }

        // Update level up effect
        function showLevelUp(level) {
            if (level !== GRAND_PRIZE_LEVEL) {
                levelUpPopup.textContent = `LEVEL ${level}!`;
                levelUpPopup.style.display = 'block';
                levelUpPopup.style.fontSize = '4em'; // Increased from 3em
                levelUpPopup.style.textShadow = '0 0 20px #ffff00, 0 0 40px #ffff00'; // Enhanced glow
                createLightningStrike();
                
                // Add special message for extreme difficulty level
                if (level === EXTREME_DIFFICULTY_LEVEL) {
                    levelUpPopup.textContent = `EXTREME MODE!`;
                    levelUpPopup.style.fontSize = '5em';
                    levelUpPopup.style.color = '#ff0000';
                    levelUpPopup.style.textShadow = '0 0 20px #ff0000, 0 0 40px #ff0000';
                    
                    // Multiple lightning strikes for dramatic effect
                    setTimeout(() => createLightningStrike(), 300);
                    setTimeout(() => createLightningStrike(), 600);
                    setTimeout(() => createLightningStrike(), 900);
                    
                    // Show warning message
                    setTimeout(() => {
                        setMessage("WARNING: Extreme difficulty activated!");
                    }, 1500);
                }
                
                setTimeout(() => {
                    levelUpPopup.style.display = 'none';
                }, 2500); // Increased from 2000
            }
            updateRiderAppearance(level);
        }

         function updateRiderAppearance(currentLevel) {
             // Apply customization settings instead of hard-coded appearance
             // Respect the player's chosen customization settings
             
             // Apply the current rider outfit from customization settings
             applyRiderOutfit(customization.currentOutfit);
             
             // Apply the current bike skin from customization settings  
             applySkinToMotorcycle(playerMotorcycle, customization.currentSkin);
             
             // Ensure rider parts maintain proper scale
             if (playerRiderBody) {
                 playerRiderBody.scale.set(1, 1, 1);
             }
             if (playerRiderHead) {
                 playerRiderHead.scale.set(1, 1, 1);
             }
         }


         function createCoinBurst(position) {
             // Enhanced: More particles, brighter, longer life, more spread
             const numParticles = 30 + Math.floor(Math.random() * 20); // More particles
             for (let i = 0; i < numParticles; i++) {
                 const particle = getPooledObject('particles', () => {
                     const material = sharedMaterials.particle.clone();
                     return new THREE.Mesh(sharedGeometries.particle, material);
                 });
                 // Brighter, more random color (yellow/orange/white)
                 const colorOptions = [0xffff00, 0xffa500, 0xffffff, 0xffee88];
                 particle.material.color.setHex(colorOptions[Math.floor(Math.random() * colorOptions.length)]);
                 particle.material.transparent = true;
                 particle.material.opacity = 1.0;
                 particle.material.emissive = particle.material.color;
                 particle.material.emissiveIntensity = 0.7;
                 // Start bigger
                 particle.scale.set(0.7, 0.7, 0.7);
                 particle.position.copy(position);
                 // More dramatic spread
                 const velocity = new THREE.Vector3(
                     (Math.random() - 0.5) * 2.2, // wider
                     Math.random() * 1.5 + 0.5,   // more upward
                     (Math.random() - 0.5) * 2.2
                 );
                 particle.userData.velocity = velocity;
                 particle.userData.life = 0;
                 particle.userData.maxLife = 80; // Longer life
                 scene.add(particle);
                 activeBursts.push(particle);
             }
         }

         // Shared explosion geometry to prevent memory leaks
         const sharedExplosionGeometry = new THREE.SphereGeometry(0.2, 8, 8);
         
         // Function to create an explosion effect
         function createExplosion(position, color = 0xff00ff) { // Default color magenta
             const numParticles = 30 + Math.floor(Math.random() * 20); // More particles for explosion

             for (let i = 0; i < numParticles; i++) {
                 const explosionMaterial = new THREE.MeshBasicMaterial({
                     color: color,
                     transparent: true,
                     opacity: 1.0
                 });
                 const particle = new THREE.Mesh(sharedExplosionGeometry, explosionMaterial);
                 particle.position.copy(position);

                 const velocity = new THREE.Vector3(
                     (Math.random() - 0.5) * 2, // Wider spread
                     (Math.random() - 0.5) * 2,
                     (Math.random() - 0.5) * 2
                 );
                 particle.userData.velocity = velocity;
                 particle.userData.life = 0;
                 particle.userData.maxLife = 45; // Longer life for explosion particles
                 particle.userData.isExplosion = true; // Mark as explosion particle for proper disposal

                 scene.add(particle);
                 activeBursts.push(particle); // Use the same array for simplicity, manage life separately
             }
             explosionSynth.triggerAttackRelease("8n"); // Play explosion sound
         }


         function startJump() {
             if (!isJumping) {
                 isJumping = true;
                 jumpVelocity = jumpPower;
             }
         }

         function applyJumpPhysics() {
             if (isJumping) {
                 playerMotorcycle.position.y += jumpVelocity;
                 jumpVelocity += gravity;
                 if (playerMotorcycle.position.y <= 0) {
                     playerMotorcycle.position.y = 0;
                     isJumping = false;
                     jumpVelocity = 0;
                 }
             }
         }

         function activateInvincibility() { // Old power-up, kept for compatibility if needed
             if (!isInvincible) {
                 isInvincible = true;
                 setMessage("Power-up! Invincibility activated!");
                 invincibilityTimer = setTimeout(() => {
                     isInvincible = false;
                     setMessage("Invincibility ended.");
                 }, powerUpDuration);
             }
         }

        // Pre-create reusable materials to avoid memory allocation during gameplay
        const powerUpMaterials = {
            ghost: new THREE.MeshStandardMaterial({
                color: 0xff00ff,
                emissive: 0xff00ff,
                metalness: 0.2,
                roughness: 0.1,
                transparent: true,
                opacity: 0.5,
            }),
            radioactiveBody: new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 0.1,
                roughness: 0.2,
                emissive: 0xffffff,
                emissiveIntensity: 0.3
            }),
            radioactiveHead: new THREE.MeshStandardMaterial({
                color: 0xffffff,
                metalness: 0.1,
                roughness: 0.1,
                emissive: 0xffffff,
                emissiveIntensity: 0.3
            })
        };

        // Optimize score display to batch updates
        let scoreUpdatePending = false;
        function updateScoreDisplay() {
            if (scoreUpdatePending) return;
            scoreUpdatePending = true;
            requestAnimationFrame(() => {
                scoreDisplay.textContent = 'ETHER: ' + score;
                scoreUpdatePending = false;
            });
        }

        function activateRandomPowerUp() {
            const availablePowerUps = Object.keys(powerUpTypes);
            const instantUsePowerUps = ['projectile', 'obstacleDrop', 'swapPosition'];
            const currentlyHeldInstant = instantUsePowerUps.some(type => {
                if (type === 'projectile' && hasProjectile) return true;
                if (type === 'obstacleDrop' && hasObstacleDrop) return true;
                if (type === 'swapPosition' && hasSwapPosition) return true;
                return false;
            });

            let powerUpPool = availablePowerUps;
            if (currentlyHeldInstant) {
                 powerUpPool = availablePowerUps.filter(type => !instantUsePowerUps.includes(type));
                 if (powerUpPool.length === 0) {
                     score += 50;
                     updateScoreDisplay();
                     setMessage("Item Box: Small Popn Bonus!");
                     itemBoxSynth.triggerAttackRelease('C6', '16n');
                     return;
                 }
            }

            const randomTypeIndex = Math.floor(Math.random() * powerUpPool.length);
            const randomType = powerUpPool[randomTypeIndex];
            const powerUpInfo = powerUpTypes[randomType];
            itemBoxSynth.triggerAttackRelease('C5', '16n', Tone.now(), 0.8);

            if (randomType === 'ghost') {
                 if (!isGhostActive) {
                     isGhostActive = true;
                     setMessage(powerUpInfo.message);
                     shieldSynth.triggerAttackRelease('F#5', '8n');

                     // Use pre-created materials instead of creating new ones
                     if (playerRiderBody && playerRiderHead) {
                         originalRiderMaterials.body = playerRiderBody.material;
                         originalRiderMaterials.head = playerRiderHead.material;
                         
                         playerRiderBody.material = powerUpMaterials.ghost;
                         playerRiderHead.material = powerUpMaterials.ghost;
                     }

                     ghostTimer = setTimeout(() => {
                         isGhostActive = false;
                         setMessage("Ghost Mode faded.");
                         if (playerRiderBody && originalRiderMaterials.body) {
                            playerRiderBody.material = originalRiderMaterials.body;
                         }
                         if (playerRiderHead && originalRiderMaterials.head) {
                            playerRiderHead.material = originalRiderMaterials.head;
                         }
                     }, powerUpInfo.duration);
                 } else {
                      setMessage("Ghost Mode duration extended!");
                      clearTimeout(ghostTimer);
                       ghostTimer = setTimeout(() => {
                          isGhostActive = false;
                          setMessage("Ghost Mode faded.");
                          if (playerRiderBody && originalRiderMaterials.body) {
                             playerRiderBody.material = originalRiderMaterials.body;
                          }
                          if (playerRiderHead && originalRiderMaterials.head) {
                             playerRiderHead.material = originalRiderMaterials.head;
                          }
                       }, powerUpInfo.duration);
                 }
            } else if (randomType === 'magnet') {
                 if (!isMagnetActive) {
                     isMagnetActive = true;
                     setMessage(powerUpInfo.message);
                     magnetSynth.triggerAttackRelease('G5', '8n');
                     
                     // Use pre-created materials
                     if (playerRiderBody && playerRiderHead) {
                         originalRiderMaterials.body = playerRiderBody.material;
                         originalRiderMaterials.head = playerRiderHead.material;
                         
                         playerRiderBody.material = powerUpMaterials.radioactiveBody;
                         playerRiderHead.material = powerUpMaterials.radioactiveHead;
                     }
                     
                     magnetTimer = setTimeout(() => {
                         isMagnetActive = false;
                         setMessage("Radioactive mode deactivated.");
                         if (playerRiderBody && originalRiderMaterials.body) {
                            playerRiderBody.material = originalRiderMaterials.body;
                         }
                         if (playerRiderHead && originalRiderMaterials.head) {
                            playerRiderHead.material = originalRiderMaterials.head;
                         }
                     }, powerUpInfo.duration);
                 } else {
                      setMessage("Radioactive mode duration extended!");
                       clearTimeout(magnetTimer);
                       magnetTimer = setTimeout(() => {
                           isMagnetActive = false;
                           setMessage("Radioactive mode deactivated.");
                           if (playerRiderBody && originalRiderMaterials.body) {
                              playerRiderBody.material = originalRiderMaterials.body;
                           }
                           if (playerRiderHead && originalRiderMaterials.head) {
                              playerRiderHead.material = originalRiderMaterials.head;
                           }
                       }, powerUpInfo.duration);
                 }
            } else if (randomType === 'slowTime') {
                 if (!isSlowTimeActive) {
                     isSlowTimeActive = true;
                     setMessage(powerUpInfo.message);
                     slowTimeSynth.triggerAttackRelease('C6', '8n');
                     slowTimeTimer = setTimeout(() => {
                         isSlowTimeActive = false;
                         setMessage("Time returned to normal.");
                     }, powerUpInfo.duration);
                 } else {
                      setMessage("Slow Time duration extended!");
                       clearTimeout(slowTimeTimer);
                       slowTimeTimer = setTimeout(() => {
                           isSlowTimeActive = false;
                           setMessage("Time returned to normal.");
                       }, powerUpInfo.duration);
                 }
            } else if (randomType === 'speedBoost') {
                 if (!isBoosting) {
                     activateBoost(powerUpInfo.duration);
                     setMessage(powerUpInfo.message);
                 } else {
                      score += 20;
                      updateScoreDisplay();
                      setMessage("Item Box: Small Popn Bonus!");
                      itemBoxSynth.triggerAttackRelease('C6', '16n');
                 }
            } else if (randomType === 'projectile') {
                                 if (!hasProjectile) {
                    hasProjectile = true;
                    setMessage(powerUpInfo.message + (isMobileDevice() ? " Tap Power-up button." : " Press 'E' to use."));
                    forceSynth.triggerAttackRelease('G5', '8n');
                    updateMobileControlVisibility();
                 } else {
                      score += 20;
                      updateScoreDisplay();
                      setMessage("Item Box: Small Popn Bonus!");
                      itemBoxSynth.triggerAttackRelease('C6', '16n');
                 }
            } else if (randomType === 'obstacleDrop') {
                                 if (!hasObstacleDrop) {
                    hasObstacleDrop = true;
                    setMessage(powerUpInfo.message + (isMobileDevice() ? " Tap Power-up button." : " Press 'E' to use."));
                    powerUpActivateSynth.triggerAttackRelease('C7', '8n');
                    updateMobileControlVisibility();
                 } else {
                      score += 20;
                      updateScoreDisplay();
                      setMessage("Item Box: Small Popn Bonus!");
                      itemBoxSynth.triggerAttackRelease('C6', '16n');
                 }
            } else if (randomType === 'swapPosition') {
                 if (!hasSwapPosition) {
                     hasSwapPosition = true;
                     setMessage(powerUpInfo.message + (isMobileDevice() ? " Tap Power-up button." : " Press 'E' to use."));
                     powerUpActivateSynth.triggerAttackRelease('E7', '8n');
                 } else {
                      score += 20;
                      updateScoreDisplay();
                      setMessage("Item Box: Small Popn Bonus!");
                      itemBoxSynth.triggerAttackRelease('C6', '16n');
                 }
            }
            updatePowerUpDisplay();
        }

        function usePowerUp() {
            if (!isGameRunning || isGameOver || gamePaused) return;
            if (hasProjectile) {
                hasProjectile = false;
                setMessage("TRONS program activated!");
                projectileSynth.triggerAttackRelease('A4', '16n', Tone.now(), 1.0);
                fireProjectile();
                animatePowerUpDisplay('use');
                trackPowerUpUsed(); // Track power-up usage
                updateMobileControlVisibility();
            } else if (hasObstacleDrop) {
                hasObstacleDrop = false;
                setMessage("Deploying Krypton!");
                powerUpActivateSynth.triggerAttackRelease('F4', '16n');
                dropObstacle();
                animatePowerUpDisplay('use');
                trackPowerUpUsed(); // Track power-up usage
                updateMobileControlVisibility();
            } else if (hasSwapPosition) {
                hasSwapPosition = false;
                setMessage("DISCO teleportation activated!");
                powerUpActivateSynth.triggerAttackRelease('D4', '16n');
                swapPositions();
                animatePowerUpDisplay('use');
                trackPowerUpUsed(); // Track power-up usage
            } else {
                setMessage("No DISCO power available!");
                animatePowerUpDisplay('use');
            }
            updatePowerUpDisplay();
        }

        function fireProjectile() {
            // DRAMATIC DISCO LAUNCH with enhanced effects
            const projectileGroup = createPowerUp('projectile'); // Create the dramatic projectile group
            projectileGroup.position.copy(playerMotorcycle.position);
            projectileGroup.position.y += 1.0; // Launch from rider position
            projectileGroup.rotation.copy(playerMotorcycle.rotation);
            const forward = new THREE.Vector3(0, 0, -1); // Shoot forward (negative Z)
            projectileGroup.userData.direction = forward;
            projectileGroup.userData.speed = projectileSpeed * 1.5; // Faster for dramatic effect
            scene.add(projectileGroup);
            activeProjectiles.push(projectileGroup);
            totalDiscoProjectiles++; // Track for leaderboard
            
            // DEBUG: Log projectile creation
            console.log("DISCO fired!", {
                position: projectileGroup.position.clone(),
                direction: projectileGroup.userData.direction,
                speed: projectileGroup.userData.speed,
                children: projectileGroup.children.length
            });
            
            // DRAMATIC MUZZLE FLASH EFFECT
            createMuzzleFlash(playerMotorcycle.position.clone());
            
            // SCREEN FLASH EFFECT for DISCO launch
            const launchFlash = document.createElement('div');
            launchFlash.style.position = 'fixed';
            launchFlash.style.top = '0';
            launchFlash.style.left = '0';
            launchFlash.style.width = '100%';
            launchFlash.style.height = '100%';
            launchFlash.style.backgroundColor = 'rgba(0, 255, 255, 0.4)';
            launchFlash.style.pointerEvents = 'none';
            launchFlash.style.zIndex = '1000';
            document.body.appendChild(launchFlash);
            setTimeout(() => {
                if (launchFlash.parentNode) launchFlash.parentNode.removeChild(launchFlash);
            }, 150); // Cyan flash for 150ms
            
            // Enhanced camera shake for DISCO launch
            triggerCameraShake(0.8, 300); // Strong shake for 300ms
        }
        
        // Create dramatic muzzle flash for DISCO launch
        function createMuzzleFlash(position) {
            const flashGroup = new THREE.Group();
            
            // Main flash burst
            const flashGeometry = new THREE.SphereGeometry(2.0, 16, 16);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 8.0,
                transparent: true,
                opacity: 0.9
            });
            const flash = new THREE.Mesh(flashGeometry, flashMaterial);
            flashGroup.add(flash);
            
            // Energy ring bursts
            for (let i = 0; i < 5; i++) {
                const ringGeometry = new THREE.RingGeometry(0.5 + i * 0.3, 1.0 + i * 0.3, 12);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 6.0 - i * 1.0,
                    transparent: true,
                    opacity: 0.8 - i * 0.15,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.random() * Math.PI;
                ring.rotation.y = Math.random() * Math.PI;
                flashGroup.add(ring);
            }
            
            flashGroup.position.copy(position);
            flashGroup.position.y += 1.0;
            scene.add(flashGroup);
            
            // Animate muzzle flash (fade out quickly)
            let flashLife = 0;
            const flashDuration = 20; // Very short duration for muzzle flash
            const flashInterval = setInterval(() => {
                flashLife++;
                const progress = flashLife / flashDuration;
                const scale = 1.0 + progress * 2.0; // Expand rapidly
                const opacity = 1.0 - progress; // Fade out
                
                flashGroup.scale.setScalar(scale);
                flashGroup.children.forEach(child => {
                    if (child.material) {
                        child.material.opacity = opacity * (child.material.opacity > 0.5 ? 0.9 : child.material.opacity);
                    }
                });
                
                if (progress >= 1.0) {
                    scene.remove(flashGroup);
                    clearInterval(flashInterval);
                    // Dispose materials
                    flashGroup.children.forEach(child => {
                        if (child.material) child.material.dispose();
                        if (child.geometry) child.geometry.dispose();
                    });
                }
                         }, 16); // 60fps animation
        }
        
        // Create MASSIVE dramatic explosion for DISCO impacts
        function createTSphereImpactExplosion(position) {
            // SCREEN SHAKE for impact
            triggerCameraShake(1.5, 500); // Very strong shake for 500ms
            
            // IMPACT SCREEN FLASH
            const impactFlash = document.createElement('div');
            impactFlash.style.position = 'fixed';
            impactFlash.style.top = '0';
            impactFlash.style.left = '0';
            impactFlash.style.width = '100%';
            impactFlash.style.height = '100%';
            impactFlash.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
            impactFlash.style.pointerEvents = 'none';
            impactFlash.style.zIndex = '1000';
            document.body.appendChild(impactFlash);
            setTimeout(() => {
                if (impactFlash.parentNode) impactFlash.parentNode.removeChild(impactFlash);
            }, 200); // Bright white flash
            
            const explosionGroup = new THREE.Group();
            
            // MASSIVE CORE EXPLOSION
            const coreGeometry = new THREE.SphereGeometry(4.0, 20, 20);
            const coreMaterial = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                emissive: 0xff0000,
                emissiveIntensity: 10.0,
                transparent: true,
                opacity: 1.0
            });
            const coreExplosion = new THREE.Mesh(coreGeometry, coreMaterial);
            explosionGroup.add(coreExplosion);
            
            // MULTIPLE ENERGY SHOCKWAVE RINGS
            for (let i = 0; i < 8; i++) {
                const ringGeometry = new THREE.RingGeometry(1.0 + i * 0.5, 2.0 + i * 0.5, 16);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 8.0 - i * 0.8,
                    transparent: true,
                    opacity: 0.9 - i * 0.1,
                    side: THREE.DoubleSide
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.random() * Math.PI;
                ring.rotation.y = Math.random() * Math.PI;
                ring.rotation.z = Math.random() * Math.PI;
                explosionGroup.add(ring);
            }
            
            // DEBRIS PARTICLES
            for (let i = 0; i < 20; i++) {
                const debrisGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const debrisMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff4400,
                    emissive: 0xff0000,
                    emissiveIntensity: 3.0
                });
                const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
                debris.position.set(
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2,
                    (Math.random() - 0.5) * 2
                );
                debris.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3,
                    (Math.random() - 0.5) * 0.3
                );
                explosionGroup.add(debris);
            }
            
            explosionGroup.position.copy(position);
            scene.add(explosionGroup);
            
            // DRAMATIC EXPLOSION ANIMATION
            let explosionLife = 0;
            const explosionDuration = 60; // Longer duration for dramatic effect
            const explosionInterval = setInterval(() => {
                explosionLife++;
                const progress = explosionLife / explosionDuration;
                
                // Core explosion effects
                const scale = 1.0 + progress * 5.0; // Massive expansion
                const coreOpacity = 1.0 - Math.pow(progress, 0.5); // Slower fade
                
                coreExplosion.scale.setScalar(scale);
                coreExplosion.material.opacity = coreOpacity;
                
                // Shockwave rings expand at different rates
                explosionGroup.children.forEach((child, index) => {
                    if (index > 0 && index <= 8) { // Rings
                        const ringScale = 1.0 + progress * (3.0 + index * 0.5);
                        child.scale.setScalar(ringScale);
                        child.material.opacity = (0.9 - index * 0.1) * (1.0 - progress);
                        child.rotation.z += 0.02 * (index + 1); // Rotating rings
                    } else if (index > 8) { // Debris
                        child.position.add(child.userData.velocity);
                        child.userData.velocity.multiplyScalar(0.98); // Debris slowdown
                        child.rotation.x += 0.1;
                        child.rotation.y += 0.1;
                        child.material.opacity = 1.0 - progress;
                    }
                });
                
                if (progress >= 1.0) {
                    scene.remove(explosionGroup);
                    clearInterval(explosionInterval);
                    // Dispose materials and geometries
                    explosionGroup.children.forEach(child => {
                        if (child.material) child.material.dispose();
                        if (child.geometry) child.geometry.dispose();
                    });
                }
            }, 16); // 60fps animation
        }

        function dropObstacle() {
            const obstacle = createObstacle();
            obstacle.userData.isPlayerObstacle = true; // Mark as player-dropped
            const dropPosition = playerMotorcycle.position.clone();
            dropPosition.z -= 10; // Place in front of player (negative Z)
            obstacle.position.copy(dropPosition);
            scene.add(obstacle);
            obstacles.push(obstacle);
            setTimeout(() => {
                 scene.remove(obstacle);
                 const index = obstacles.indexOf(obstacle);
                 if (index !== -1) {
                     obstacles.splice(index, 1);
                 }
            }, 8000); // Increased duration to 8 seconds
        }

        function swapPositions() {
            // Find the leading AI competitor (smallest Z position)
            let leadingAI = null;
            let furthestZ = Infinity;

            aiMotorcycles.forEach(aiBike => {
                 // Check if the AI is visible and is ahead of the player
                 if (aiBike.visible && aiBike.position.z < playerMotorcycle.position.z) {
                     if (aiBike.position.z < furthestZ) {
                         furthestZ = aiBike.position.z;
                         leadingAI = aiBike;
                     }
                 }
            });

            if (leadingAI) {
                 const playerPos = playerMotorcycle.position.clone();
                 const aiPos = leadingAI.position.clone();

                 // Perform the swap
                 playerMotorcycle.position.copy(aiPos);
                 leadingAI.position.copy(playerPos);

                 // Temporarily disable AI movement after swap
                 leadingAI.userData.canMove = false;
                 setTimeout(() => {
                     leadingAI.userData.canMove = true;
                 }, 500); // AI movement re-enabled after 500ms

                 setMessage(`Swapped positions with the leading AI!`);
            } else {
                 setMessage("No leading AI competitor found to swap with!");
            }
        }


         function updatePowerUpDisplay() {
             const activeStatus = [];
             let hasInstantUsePowerUp = false;
             if (isGhostActive) activeStatus.push("Ghost");
             if (isMagnetActive) activeStatus.push("Radioactive");
             if (isSlowTimeActive) activeStatus.push("Slow Time");
             if (hasProjectile) { activeStatus.push("DISCO!"); hasInstantUsePowerUp = true; }
             if (hasObstacleDrop) { activeStatus.push("Kyrpton!"); hasInstantUsePowerUp = true; }
             if (hasSwapPosition) { activeStatus.push("Swap Position!"); hasInstantUsePowerUp = true; }

             if (activeStatus.length > 0) {
                 powerUpDisplay.textContent = "P-UP: " + activeStatus.join(" | ");
                 powerUpDisplay.style.display = 'block';
             } else {
                 powerUpDisplay.textContent = "";
                 powerUpDisplay.style.display = 'none';
             }
             if (isMobileDevice() && gameMode === 'manual' && hasInstantUsePowerUp && isGameRunning && !isGameOver && !gamePaused) {
                 usePowerUpButton.style.display = 'flex';
             } else {
                 usePowerUpButton.style.display = 'none';
             }
         }


        function animate() {
            // Cancel any previous animation frame to prevent multiple loops
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
            }
            window.animationFrameId = requestAnimationFrame(animate);
            
            if (isGameOver || !isGameRunning || gamePaused) {
                // Debug logging for early return
                if (isGameOver) console.log("Animate early return: isGameOver =", isGameOver);
                if (!isGameRunning) console.log("Animate early return: isGameRunning =", isGameRunning);
                if (gamePaused) console.log("Animate early return: gamePaused =", gamePaused);
                
                renderer.render(scene, camera);
                return;
            }
            
            // FPS counter
            fpsFrameCount++;
            const currentTime = performance.now();
            if (currentTime - fpsLastTime >= 1000) { // Update every second
                currentFPS = Math.round((fpsFrameCount * 1000) / (currentTime - fpsLastTime));
                fpsFrameCount = 0;
                fpsLastTime = currentTime;
                
                // Update FPS display in stats if available
                const fpsElement = document.getElementById('stat-fps');
                if (fpsElement) {
                    fpsElement.textContent = `${currentFPS} FPS`;
                }
            }

            // Pulse shield effect on rider
            if (isGhostActive) {
                ghostPulsePhase += 0.12; // Faster, more 'electric' pulse
                const pulseOpacity = 0.5 + Math.sin(ghostPulsePhase) * 0.3; // Varies between 0.2 and 0.8
                const pulseIntensity = 1.2 + Math.abs(Math.sin(ghostPulsePhase * 2.0)) * 1.0; // Sharp, electric flicker from 1.2 to 2.2

                if (playerRiderBody && playerRiderBody.material) {
                    playerRiderBody.material.opacity = pulseOpacity;
                    playerRiderBody.material.emissiveIntensity = pulseIntensity;
                }
                if (playerRiderHead && playerRiderHead.material) {
                    playerRiderHead.material.opacity = pulseOpacity;
                    playerRiderHead.material.emissiveIntensity = pulseIntensity;
                }
            }

            // Update infinite city generation
            updateInfiniteCity();
            
            // Update infinite road generation
            updateInfiniteRoad();
            
            // Animate neon lights for Times Square effect
            animateNeonLights();
            
            // Animate billboards (optimized - only every 3rd frame)
            if (fpsFrameCount % 3 === 0) {
                scene.traverse((object) => {
                    if (object.isMesh && object.material && object.userData.originalIntensity) {
                        const time = Date.now() * 0.002;
                        object.material.emissiveIntensity = object.userData.originalIntensity + 
                            Math.sin(time + object.userData.animationPhase) * 0.4;
                    }
                });
            }
            
            // Monitor memory usage (integrated into main loop for better performance)
            monitorMemoryLeaks();
            
            // Show leaderboard comparison messages periodically
            if (score > 0 && getAdjustedTime() - lastLeaderboardCheck > 15000) { // Every 15 seconds
                const comparisonMessage = leaderboard.getComparisonMessage(score);
                if (comparisonMessage) {
                    setMessage(comparisonMessage);
                    lastLeaderboardCheck = getAdjustedTime();
                }
            }

            // Animate bowling ball fuse sparks
            bowlingBallObstacles.forEach(ballGroup => {
                if (ballGroup.userData.fuseSparkPhase !== undefined) {
                    ballGroup.userData.fuseSparkPhase += 0.15; // Animation speed
                    const sparkIntensity = 1.5 + Math.sin(ballGroup.userData.fuseSparkPhase) * 0.8; // Flicker between 0.7 and 2.3
                    const sparkScale = 0.8 + Math.sin(ballGroup.userData.fuseSparkPhase * 1.5) * 0.4; // Size variation
                    
                    // Find the spark tip (last child added to the group)
                    const sparkTip = ballGroup.children[ballGroup.children.length - 1];
                    if (sparkTip && sparkTip.material) {
                        sparkTip.material.emissiveIntensity = sparkIntensity;
                        sparkTip.scale.setScalar(sparkScale);
                    }
                }
            });

            // Animate player engine glow
            if (playerMotorcycle.userData.engineGlow) {
                const glowIntensity = isBoosting ? 1.0 : 0.6;
                const pulse = Math.sin(Date.now() * 0.01) * 0.2 + 0.8; // Pulsing effect
                playerMotorcycle.userData.engineGlow.material.opacity = glowIntensity * pulse;
                playerMotorcycle.userData.engineGlow.scale.setScalar(pulse);
            }

            // Speed increase logic - only increase base speed up to SPEED_INCREASE_LIMIT_LEVEL
            if (level <= SPEED_INCREASE_LIMIT_LEVEL) {
                 moveSpeed = Math.min(baseMoveSpeed + (score * speedIncreaseRate), maxMoveSpeed);
            } else {
                 // Maintain max speed once limit level is reached
                 moveSpeed = maxMoveSpeed;
            }

            currentMoveSpeed = moveSpeed;
            if (isBoosting) currentMoveSpeed *= 3;
            if (isMiniBoostActive) currentMoveSpeed *= 1.25; // 25% speed increase
            if (isSlowTimeActive) currentMoveSpeed *= slowTimeFactor;
            
            // NEW: Trigger hyperspace effect when reaching max speed
            if (typeof currentMoveSpeed !== 'undefined' && currentMoveSpeed >= maxMoveSpeed && !hyperspaceActive) {
                triggerHyperspaceEffect();
                trackHyperspaceJump(); // Track hyperspace jumps
            }

            // Updated loose steering logic
            let playerSteer = getPlayerManualSteerDirection();
            
            // Smoother input transition
            lastSteerInput += (playerSteer - lastSteerInput) * inputSmoothing;
            
            // More subtle momentum update
            if (playerSteer !== 0) {
                steerMomentum += playerSteer * 0.006; // Reduced from 0.008 for more subtle effect
                steerMomentum = Math.max(-maxMomentum, Math.min(maxMomentum, steerMomentum));
            }
            
            // Slower momentum decay
            steerMomentum *= momentumDecay;
            
            // Combine direct steering with subtle momentum
            targetSteerAngle = (lastSteerInput * maxSteerAngle) + (steerMomentum * maxSteerAngle * 0.5);
            
            // Smoother angle interpolation
            currentSteerAngle += (targetSteerAngle - currentSteerAngle) * steerInterpolationSpeed;
            
            // Very subtle oscillation (reduced further for smoother gameplay)
            const oscillation = Math.sin(Date.now() * 0.001) * 0.002; // Further reduced amplitude and frequency
            currentSteerAngle += oscillation;
            
            // Reduced tilt for less rocking
            playerMotorcycle.rotation.y = currentSteerAngle;
            playerMotorcycle.rotation.z = -currentSteerAngle * 0.15; // Reduced from 0.2 for less tilt
            
            // Smoother lateral movement using velocity
            const targetLateralVelocity = (Math.sin(currentSteerAngle) * 0.3 + steerMomentum * 0.2) * steerSpeed;
            lateralVelocity += (targetLateralVelocity - lateralVelocity) * 0.1;
            lateralVelocity *= lateralDamping;
            
            // Apply smoothed lateral movement
            playerMotorcycle.position.x += lateralVelocity;

            // Smoother edge handling
            const motorcycleX = playerMotorcycle.position.x;
            if (motorcycleX < -roadEdgeThreshold) {
                playerMotorcycle.position.x = -roadEdgeThreshold;
                currentSteerAngle *= 0.85;
                steerMomentum *= 0.8;
                lateralVelocity *= 0.5; // Dampen lateral velocity on edge hit
            } else if (motorcycleX > roadEdgeThreshold) {
                playerMotorcycle.position.x = roadEdgeThreshold;
                currentSteerAngle *= 0.85;
                steerMomentum *= 0.8;
                lateralVelocity *= 0.5; // Dampen lateral velocity on edge hit
            }

            // Gradual momentum reset
            if (Math.abs(playerSteer) < 0.1) {
                steerMomentum *= 0.97;
                lateralVelocity *= 0.95; // Gradually reduce lateral velocity
            }

            applyJumpPhysics();
            playerMotorcycle.translateZ(-currentMoveSpeed);

            aiMotorcycles.forEach(aiBike => {
                 aiBike.userData.moveSpeed = baseMoveSpeed * (0.85 + Math.random() * 0.2); // AI bikes slightly slower than player for competitive racing
                 automateAIMotorcycle(aiBike);
            });

             if (level >= 2) { // Bat gangs still appear from level 2
                 batGangs.forEach(batGang => moveBatGang(batGang));
                 const currentBatGangSpawnRate = batGangSpawnRate / (level - 1);
                 if (batGangs.length < maxBatGangs && Math.random() < 1 / currentBatGangSpawnRate) {
                     const randomX = (Math.random() - 0.5) * (roadWidth - 2);
                     const randomZ = playerMotorcycle.position.z - 100 - Math.random() * 150;
                     const batGang = createBatGang();
                     batGang.position.set(randomX, 2, randomZ);
                     scene.add(batGang);
                     batGangs.push(batGang);
                 }
             }

            // Move and check collisions for Dragon
            dragons.forEach(tieFighter => {
                moveDragon(tieFighter);
                
                // Periodic reminder that stronghold is still pursuing
                if (!tieFighter.userData.lastReminderTime) {
                    tieFighter.userData.lastReminderTime = Date.now();
                }
                
                const timeSinceLastReminder = Date.now() - tieFighter.userData.lastReminderTime;
                if (timeSinceLastReminder > 8000) { // Every 8 seconds
                    const distance = tieFighter.position.distanceTo(playerMotorcycle.position);
                    if (distance > 25) {
                        setMessage("ðŸš Criminal Stronghold still pursuing...");
                    } else if (distance > 15) {
                        setMessage("âš ï¸ Stronghold gaining ground!");
                    } else {
                        setMessage("ðŸ”¥ STRONGHOLD CLOSE BEHIND!");
                    }
                    tieFighter.userData.lastReminderTime = Date.now();
                }
            });
            
            // NEW GALAXY ZONE SYSTEM (Levels 3-8)
                                    if (galaxyZoneActive && level >= 30 && level <= 49) {
                updateGalaxyZone();
            }


            // Update infinite road system (handles road segments automatically)
            updateInfiniteRoad();



            if (coins.length < maxCoins && shouldSpawnObject(coinSpawnRate, level)) {
                const randomX = (Math.random() - 0.5) * (roadWidth - 1);
                const randomZ = playerMotorcycle.position.z - 50 - Math.random() * 100;
                const coin = createCoin();
                coin.position.set(randomX, 0.5, randomZ);
                scene.add(coin);
                coins.push(coin);
            }

            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.rotation.y += 0.05; // Make coins spin

                let collisionThreshold = 1.0;
                const distance = playerMotorcycle.position.distanceTo(coin.position);

                if (distance < collisionThreshold) {
                    console.log("Photon collected! Creating burst effect at:", coin.position);
                    const burstPosition = coin.position.clone(); // Store position before removing
                    
                    // Add screen flash effect for photon collection
                    const flash = document.createElement('div');
                    flash.style.position = 'fixed';
                    flash.style.top = '0';
                    flash.style.left = '0';
                    flash.style.width = '100%';
                    flash.style.height = '100%';
                    flash.style.backgroundColor = 'rgba(255, 255, 0, 0.3)';
                    flash.style.pointerEvents = 'none';
                    flash.style.zIndex = '1000';
                    document.body.appendChild(flash);
                    setTimeout(() => {
                        if (flash.parentNode) flash.parentNode.removeChild(flash);
                    }, 100);
                    
                    scene.remove(coin);
                    returnToPool('coins', coin);
                    coins.splice(i, 1);
                    score++;
                    coinsForPowerUp++;
                    coinSynth.triggerAttackRelease('C5', '16n', Tone.now(), 0.7); // Slightly louder coin sound
                    triggerCameraShake(0.2, 100); // Very light shake for coin collection
                    updateScoreDisplay();
                    createCoinBurst(burstPosition);
                    createEtherTrail(burstPosition); // NEW: Ether collection trail
                    trackEtherCollection(); // Track ether collected

                    if (score >= levelThreshold && score > 0) {
                         const previousLevel = level;
                         level++;
                         levelThreshold = level * 5;
                         levelDisplay.textContent = 'Sector: ' + level;
                         
                         // Reset manual boost counter when entering a new level bracket (every 10 levels)
                         const previousBracket = Math.floor((previousLevel - 1) / 10);
                         const currentBracket = Math.floor((level - 1) / 10);
                         if (currentBracket > previousBracket) {
                             manualBoostsUsed = 0;
                             blasterBoltsUsed = 0; // Reset blaster bolts too
                             const maxBoosts = currentBracket + 1;
                             const maxBlasters = Math.floor(level / 10);
                             if (maxBlasters > 0) {
                                 setMessage(`ðŸŽ† Level ${level}! Manual boosts & blaster bolts reset! You now have ${maxBoosts} boost${maxBoosts > 1 ? 's' : ''} and ${maxBlasters} blaster bolt${maxBlasters > 1 ? 's' : ''} available!`);
                             } else {
                                 setMessage(`ðŸŽ† Level ${level}! Manual boosts reset! You now have ${maxBoosts} boost${maxBoosts > 1 ? 's' : ''} available!`);
                             }
                             updateBoostButtonDisplay(); // Update button display
                             updateBlasterButtonDisplay(); // Update blaster button display
                         }
                         
                         // Apply extreme difficulty at level 60
                         if (level === EXTREME_DIFFICULTY_LEVEL) {
                             applyExtremeDifficulty();
                         }
                         
                         if (level === GRAND_PRIZE_LEVEL) {
                             gamePaused = true;
                             setMessage("Congrats, see Junior for GHOST + SOL!"); // UPDATED MESSAGE
                             setTimeout(() => {
                                 gamePaused = false;
                                 setMessage("");
                             }, 30000);
                         } else {
                             showLevelUp(level);
                             
                             // NEW GALAXY ZONE ACTIVATION
                             if (level === 30) {
                                 galaxyZoneActive = true;
                                 setMessage("ðŸ™ï¸ ENTERING DOWNTOWN DISTRICT! Criminal vehicles incoming!");
                                 // Change scene atmosphere to AI Wars style
                                 scene.fog = new THREE.Fog(0x0a0a1a, 30, 200);
                                 renderer.setClearColor(0x0a0a1a);
                             }
                             if (level === 50 && galaxyZoneActive) {
                                 galaxyZoneActive = false;
                                 setMessage("ðŸŒŸ Exiting Downtown District... returning to normal streets.");
                                 // Reset atmosphere
                                 scene.fog = new THREE.Fog(0x87ceeb, 50, 300);
                                 renderer.setClearColor(0x87ceeb);
                                 // Clear remaining galaxy ships
                                 galaxyShips.forEach(ship => {
                                     scene.remove(ship);
                                 });
                                 galaxyShips.length = 0;
                                 galaxyProjectiles.forEach(proj => {
                                     scene.remove(proj);
                                 });
                                 galaxyProjectiles.length = 0;
                             }
                             
                             if (level === BOOST_UNLOCK_LEVEL) { // Check against new BOOST_UNLOCK_LEVEL
                                 setMessage("Boost Unlocked!" + (isMobileDevice() ? "" : " Press Space or Boost Button."));
                                 boostButton.disabled = isBoosting || gamePaused;
                                 updateBoostButtonDisplay(); // Update button display
                             }
                             // Krypton Crystal Zone Messages
                             if (level === 20) {
                                 setTimeout(() => setMessage("ðŸ’Ž ENTERING KRYPTON CRYSTAL ZONE! Deadly crystalline obstacles ahead!"), 1000);
                             }
                             if (level === 26) {
                                 setTimeout(() => setMessage("âœ¨ Exiting Krypton zone... clear roads ahead!"), 1000);
                             }
                             if (level === 55) {
                                 setTimeout(() => setMessage("ðŸ’Ž KRYPTON ZONE RETURNS! Advanced crystal formations detected!"), 1000);
                             }
                             if (level === 61) {
                                 setTimeout(() => setMessage("âœ¨ Crystal zone cleared... open highway restored!"), 1000);
                             }
                             if (level === 90) {
                                 setTimeout(() => setMessage("ðŸ’Ž FINAL KRYPTON ZONE! Maximum crystal density ahead!"), 1000);
                             }
                             if (level === 101) {
                                 setTimeout(() => setMessage("âœ¨ All crystal zones cleared! Pure racing ahead!"), 1000);
                             }
                             
                             if (level === 10 && !DRAGON_LEVELS.includes(10)) { // Check if it's not a tieFighter level to avoid double message
                                 currentRoadTextureIndex = 1;
                                 // Update all road segments with new shared material
                                 roadSegments.forEach(segment => {
                                     segment.material = sharedRoadMaterials[currentRoadTextureIndex];
                                 });
                                 setMessage("The road shifts... darkness deepens!");
                             }
                             if (level === 20 && !DRAGON_LEVELS.includes(20)) { // Check if it's not a tieFighter level
                                  currentRoadTextureIndex = 2;
                                  // Update all road segments with new shared material
                                  roadSegments.forEach(segment => {
                                      segment.material = sharedRoadMaterials[currentRoadTextureIndex];
                                  });
                                  setMessage("The abyss stares back!");
                             }
                                          // PERFORMANCE FIX: Cap AI motorcycles at reasonable level to prevent sluggishness
             const maxAIMotorcycles = Math.min(baseAiBikes + Math.floor((level - 1) / 2), 12); // Cap at 12 total, add every 2 levels
             if (aiMotorcycles.length < maxAIMotorcycles && level < GRAND_PRIZE_LEVEL) {
                 const bikesToAdd = Math.min(maxAIMotorcycles - aiMotorcycles.length, 3); // Add max 3 at a time for better competition
                 for (let j = 0; j < bikesToAdd; j++) {
                     const newAiBikeParts = createMotorcycle(aiColors[aiMotorcycles.length % aiColors.length], 0x000000);
                     const newAiBike = newAiBikeParts.motorcycle;
                     
                     // Force green helmets for all AI
                     if (newAiBikeParts.riderHead) {
                         newAiBikeParts.riderHead.material = new THREE.MeshStandardMaterial({
                             color: 0x00ff00,
                             metalness: 0.9,
                             roughness: 0.1,
                             emissive: 0x00ff00,
                             emissiveIntensity: 1.2,
                             transparent: true,
                             opacity: 0.9
                         });
                     }
                     
                     newAiBike.position.set((aiMotorcycles.length - (maxAIMotorcycles - 1) / 2) * 2.5, 0, playerMotorcycle.position.z - 15 - Math.random() * 40);
                     newAiBike.userData.targetX = newAiBike.position.x;
                     newAiBike.userData.targetTimer = 0;
                     newAiBike.userData.steerSpeed = 0.02;
                     newAiBike.userData.moveSpeed = baseMoveSpeed * (0.85 + Math.random() * 0.2);
                     newAiBike.userData.canMove = true;
                     scene.add(newAiBike);
                     aiMotorcycles.push(newAiBike);
                                  }
             }
             
             // COMPETITOR RESPAWN SYSTEM: Ensure minimum AI presence for racing excitement
             if (aiMotorcycles.length < 4 && level > 10) { // Always maintain at least 4 competitors after level 10
                 const respawnCount = Math.min(4 - aiMotorcycles.length, 2); // Respawn up to 2 at a time
                 for (let k = 0; k < respawnCount; k++) {
                     const respawnAiBikeParts = createMotorcycle(aiColors[aiMotorcycles.length % aiColors.length], 0x000000);
                     const respawnAiBike = respawnAiBikeParts.motorcycle;
                     
                     // Force green helmets for respawned AI
                     if (respawnAiBikeParts.riderHead) {
                         respawnAiBikeParts.riderHead.material = new THREE.MeshStandardMaterial({
                             color: 0x00ff00,
                             metalness: 0.9,
                             roughness: 0.1,
                             emissive: 0x00ff00,
                             emissiveIntensity: 1.2,
                             transparent: true,
                             opacity: 0.9
                         });
                     }
                     
                     // Spawn behind player to maintain racing feel
                     respawnAiBike.position.set(
                         (Math.random() - 0.5) * (roadWidth - 2), 
                         0, 
                         playerMotorcycle.position.z - 30 - Math.random() * 20
                     );
                     respawnAiBike.userData.targetX = respawnAiBike.position.x;
                     respawnAiBike.userData.targetTimer = 0;
                     respawnAiBike.userData.steerSpeed = 0.02;
                     respawnAiBike.userData.moveSpeed = baseMoveSpeed * (0.85 + Math.random() * 0.2);
                     respawnAiBike.userData.canMove = true;
                     scene.add(respawnAiBike);
                     aiMotorcycles.push(respawnAiBike);
                     console.log(`AI motorcycle respawned. Total AI motorcycles: ${aiMotorcycles.length}`);
                 }
             }
             
             // Only increase base speed up to the new limit level
                             if (level < SPEED_INCREASE_LIMIT_LEVEL) baseMoveSpeed += baseSpeedIncreasePerLevel;
                             if (level < GRAND_PRIZE_LEVEL) obstacleSpeedMultiplier += 0.2;

                             // Dragon spawning logic
                             if (DRAGON_LEVELS.includes(level) && dragons.length === 0) {
                                 const tieFighterType = level === 90 ? 2 : level === 50 ? 1 : 0;
                                 const tieFighter = createDragon(tieFighterType);
                                 
                                 // OPTIMAL POSITIONING: Close enough to be visible and threatening after cinematic
                                 // Position: Behind player, elevated, slightly to the side for dramatic effect
                                 const spawnDistance = tieFighterType === 2 ? 40 : tieFighterType === 1 ? 35 : 30; // Much closer
                                 const spawnHeight = tieFighterType === 2 ? 8 : tieFighterType === 1 ? 7 : 6; // Higher for bigger bosses
                                 const spawnOffset = (Math.random() - 0.5) * 8; // Slight side offset for variety
                                 
                                 tieFighter.position.set(spawnOffset, spawnHeight, playerMotorcycle.position.z - spawnDistance);
                                 scene.add(tieFighter);
                                 dragons.push(tieFighter);
                                 
                                 // More dramatic stronghold messages with Krypton hints
                                 if (tieFighterType === 2) {
                                     setMessage("ðŸ’€ FINAL CRIMINAL STRONGHOLD DEPLOYED! MAXIMUM THREAT!");
                                     setTimeout(() => setMessage("ðŸ’Ž URGENT: Only Krypton can destroy it!"), 2000);
                                 } else if (tieFighterType === 1) {
                                     setMessage("ðŸš MAJOR CRIMINAL STRONGHOLD INCOMING! EVASIVE MANEUVERS!");
                                     setTimeout(() => setMessage("ðŸ’¡ Remember: Only Krypton can destroy strongholds!"), 2000);
                                 } else {
                                     setMessage("âš ï¸ CRIMINAL STRONGHOLD DEPLOYED! IT WILL HUNT YOU DOWN!");
                                     setTimeout(() => setMessage("ðŸ”¬ Tip: Collect Krypton to defeat it!"), 2000);
                                 }
                                 
                                 // Activate cinematic camera for tieFighter
                                 activateCinematicCamera('tieFighter', tieFighter);
                             }
                         }
                    }
                } else if (coin.position.z > playerMotorcycle.position.z + 10) {
                    scene.remove(coin);
                    returnToPool('coins', coin);
                    coins.splice(i, 1);
                }
            }


            // Only spawn Krypton crystal obstacles during specific level ranges
            const shouldSpawnKrypton = (level >= 20 && level <= 25) || 
                                     (level >= 55 && level <= 60) || 
                                     (level >= 90 && level <= 100);
            
            if (shouldSpawnKrypton && obstacles.length < maxObstacles && shouldSpawnObject(obstacleSpawnRate, level)) {
                const randomX = (Math.random() - 0.5) * (roadWidth - 2);
                const randomZ = playerMotorcycle.position.z - 50 - Math.random() * 150;
                const obstacle = createObstacle();
                obstacle.position.set(randomX, 0.5, randomZ);
                scene.add(obstacle);
                obstacles.push(obstacle);
            }
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                
                // Animate Krypton crystals if they are player-dropped
                if (obstacle.userData.isPlayerObstacle && obstacle.userData.rotationSpeed) {
                    obstacle.rotation.y += obstacle.userData.rotationSpeed;
                    obstacle.rotation.x += obstacle.userData.rotationSpeed * 0.5;
                    // Pulse the energy core
                    if (obstacle.children.length > 5) { // Has energy core
                        const core = obstacle.children[obstacle.children.length - 1];
                        const pulseFactor = 1 + Math.sin(Date.now() * 0.01) * 0.3;
                        core.scale.setScalar(pulseFactor);
                    }
                }
                
                const distance = playerMotorcycle.position.distanceTo(obstacle.position);
                const obstacleCollisionThreshold = 1.5;
                
                // Only regular obstacles (not player-dropped) can kill the player
                if (!obstacle.userData.isPlayerObstacle && !isInvincible && !isGhostActive && !isCinematicInvulnerable && distance < obstacleCollisionThreshold) {
                    playCollisionSound('obstacle'); // Enhanced collision sound
                    triggerCameraShake(1.0, 400); // Strong shake for collision death
                    gameOver(); return;
                } else if (obstacle.position.z > playerMotorcycle.position.z + 10) {
                    scene.remove(obstacle);
                    obstacles.splice(i, 1);
                }
            }

            if (bowlingBallObstacles.length < maxBowlingBalls && shouldSpawnObject(bowlingBallSpawnRate, level)) {
                const randomX = (Math.random() - 0.5) * (roadWidth - 2);
                const randomZ = playerMotorcycle.position.z - 70 - Math.random() * 200;
                const bowlingBall = createBowlingBallObstacle();
                bowlingBall.position.set(randomX, 0.8, randomZ);
                scene.add(bowlingBall);
                bowlingBallObstacles.push(bowlingBall);
            }
            for (let i = bowlingBallObstacles.length - 1; i >= 0; i--) {
                const bowlingBall = bowlingBallObstacles[i];
                // Bowling balls stay stationary - player catches up to them
                // No movement - they're obstacles to be avoided
                if (bowlingBall.position.z > playerMotorcycle.position.z + 5) {
                    scene.remove(bowlingBall);
                    bowlingBallObstacles.splice(i, 1);
                }
            }


            if (itemBoxes.length < maxItemBoxes && shouldSpawnObject(itemBoxSpawnRate, level)) {
                const randomX = (Math.random() - 0.5) * (roadWidth - 2);
                const randomZ = playerMotorcycle.position.z - 100 - Math.random() * 200;
                const itemBox = createItemBox();
                itemBox.position.set(randomX, 0.5, randomZ);
                scene.add(itemBox);
                itemBoxes.push(itemBox);
            }
            for (let i = itemBoxes.length - 1; i >= 0; i--) {
                const rubyGem = itemBoxes[i];
                
                // STUNNING RUBY ANIMATION
                rubyGem.rotation.x += rubyGem.userData.rotationSpeed;
                rubyGem.rotation.y += rubyGem.userData.rotationSpeed * 1.5; // Faster Y rotation
                rubyGem.rotation.z += rubyGem.userData.rotationSpeed * 0.7;
                
                // PULSING ENERGY EFFECTS
                rubyGem.userData.pulsePhase += 0.05;
                const pulseFactor = 1 + Math.sin(rubyGem.userData.pulsePhase) * 0.2;
                
                // Pulse the inner core
                if (rubyGem.children[1]) { // Core
                    rubyGem.children[1].scale.setScalar(pulseFactor);
                }
                
                // Pulse the outer aura
                if (rubyGem.children[2]) { // Aura
                    const auraPulse = 1 + Math.sin(rubyGem.userData.pulsePhase * 1.3) * 0.15;
                    rubyGem.children[2].scale.setScalar(auraPulse);
                    rubyGem.children[2].material.opacity = 0.2 + Math.sin(rubyGem.userData.pulsePhase * 2) * 0.1;
                }
                
                const distance = playerMotorcycle.position.distanceTo(rubyGem.position);
                const itemBoxCollisionThreshold = 1.2;
                if (distance < itemBoxCollisionThreshold) {
                    scene.remove(rubyGem);
                    itemBoxes.splice(i, 1);
                    // Add camera shake for ruby collection
                    triggerCameraShake(0.5, 200);
                    activateRandomPowerUp();
                } else if (rubyGem.position.z > playerMotorcycle.position.z + 10) {
                    scene.remove(rubyGem);
                    itemBoxes.splice(i, 1);
                }
            }

            // Green Vials spawning and collection
            if (greenVials.length < maxGreenVials && shouldSpawnObject(greenVialSpawnRate, level)) {
                const randomX = (Math.random() - 0.5) * (roadWidth - 2);
                const randomZ = playerMotorcycle.position.z - 80 - Math.random() * 150;
                const greenVial = createGreenVial();
                greenVial.position.set(randomX, 0.5, randomZ);
                scene.add(greenVial);
                greenVials.push(greenVial);
                console.log("Green vial spawned at position:", greenVial.position);
            }
            for (let i = greenVials.length - 1; i >= 0; i--) {
                const greenVial = greenVials[i];
                
                // Animate the green vial (rotation and pulsing)
                greenVial.rotation.y += greenVial.userData.rotationSpeed;
                greenVial.userData.pulsePhase += 0.08;
                const pulseScale = 1 + Math.sin(greenVial.userData.pulsePhase) * 0.1;
                greenVial.scale.set(pulseScale, pulseScale, pulseScale);
                
                const distance = playerMotorcycle.position.distanceTo(greenVial.position);
                const greenVialCollisionThreshold = 1.5; // Increased collision threshold
                if (distance < greenVialCollisionThreshold) {
                    console.log("Green vial collected! Distance:", distance);
                    scene.remove(greenVial);
                    greenVials.splice(i, 1);
                    triggerCameraShake(0.3, 150); // Light shake for green vial collection
                    consumeGreenVial();
                } else if (greenVial.position.z > playerMotorcycle.position.z + 10) {
                    scene.remove(greenVial);
                    greenVials.splice(i, 1);
                }
            }

            for (let i = activeProjectiles.length - 1; i >= 0; i--) {
                 const projectile = activeProjectiles[i];
                 // Projectile is now a group, move the group
                 projectile.position.add(projectile.userData.direction.clone().multiplyScalar(projectile.userData.speed));
                 
                 // DRAMATIC DISCO SPINNING AND PULSING EFFECTS WHILE TRAVELING
                 const time = Date.now() * 0.01;
                 const pulseIntensity = 1.0 + Math.sin(time * 3) * 0.5; // Fast intense cyan pulsing
                 const scalePulse = 1.0 + Math.sin(time * 2) * 0.4; // Scale pulsing for glow effect
                 
                 // Main disco spinning animation - FAST rotation like a real disco ball!
                 projectile.rotation.z += 0.4; // Super fast spinning
                 projectile.rotation.x += 0.1; // Slight wobble for realism
                 
                 projectile.children.forEach((child, index) => {
                     if (child.material && child.material.emissiveIntensity !== undefined) {
                         // Pulse emissive intensity for dramatic disco glow
                         const baseDiscoIntensity = index === 0 ? 8.0 : index === 1 ? 6.0 : index === 2 ? 12.0 : 10.0;
                         child.material.emissiveIntensity = baseDiscoIntensity * pulseIntensity;
                     }
                     // Individual component animations
                     if (index === 1) { // Outer ring
                         child.rotation.z += 0.2; // Counter-rotate outer ring
                         child.scale.setScalar(scalePulse * 1.1);
                     } else if (index > 2) { // Energy sparks
                         child.rotation.x += 0.15 * index; // Each spark rotates differently
                         child.rotation.y += 0.1 * index;
                     }
                 });

                 // DISCO projectiles now BOUNCE OFF dragons - only Krypton can destroy them!
                 let hitDragon = false; // Flag to check if tieFighter was hit
                 for (let k = dragons.length - 1; k >= 0; k--) {
                      const tieFighter = dragons[k];
                      const distanceToDragon = projectile.position.distanceTo(tieFighter.position);
                      const tieFighterCollisionThreshold = 4.0; // Adjust threshold for tieFighter size
                      if (distanceToDragon < tieFighterCollisionThreshold) {
                          setMessage("ðŸ’« DISCO bounced off stronghold! Only Krypton can destroy it!");
                          // Create visual bounce effect
                          createExplosion(projectile.position.clone(), 0x00ffff); // Cyan bounce explosion
                          // Remove projectile but NOT the dragon
                          scene.remove(projectile); activeProjectiles.splice(i, 1);
                          hitDragon = true;
                          break; // Exit tieFighter loop after hit
                      }
                 }
                 if (hitDragon) continue; // If tieFighter was hit, move to the next projectile

                 // Check collision with bat gangs
                 let hitBat = false; // Flag to check if bat gang was hit
                 for (let k = batGangs.length - 1; k >= 0; k--) {
                     const batGang = batGangs[k];
                     const distance = projectile.position.distanceTo(batGang.position);
                     const batCollisionThreshold = 2.0; // Slightly larger threshold for bat gangs
                     if (distance < batCollisionThreshold) {
                         setMessage(`Bat gang destroyed! ++100 ETHER!`);
                                                    score += 100; // 100 points for destroying bat gang
                           updateScoreDisplay();
                         scene.remove(projectile); activeProjectiles.splice(i, 1);
                         scene.remove(batGang); batGangs.splice(k, 1);
                         createExplosion(batGang.position.clone(), 0xff8800); // Orange explosion for bat gang
                         triggerCameraShake(0.7, 350); // Strong shake for bat gang destruction
                         hitBat = true;
                         break; // Exit bat gang loop after hit
                     }
                 }
                 if (hitBat) continue; // If bat gang was hit, move to the next projectile

                 for (let j = aiMotorcycles.length - 1; j >= 0; j--) {
                     const aiBike = aiMotorcycles[j];
                     // Check distance between the projectile group's position and the AI bike
                     const distance = projectile.position.distanceTo(aiBike.position);
                     const projectileCollisionThreshold = 1.5;
                     if (distance < projectileCollisionThreshold) {
                         setMessage(`Hit an Imperial! Popn +20!`);
                         score += 20;
                         updateScoreDisplay();
                         scene.remove(projectile); activeProjectiles.splice(i, 1);
                         scene.remove(aiBike); aiMotorcycles.splice(j, 1);
                         createExplosion(aiBike.position.clone(), 0x00ff00); // Create green explosion at AI position
                         triggerCameraShake(0.6, 300); // Medium shake for enemy destruction
                         trackEnemyDefeat(); // Track enemy defeat
                         
                         // Activate cinematic camera when projectile knocks out AI
                         activateCinematicCamera('levelUp');
                         
                         break; // Exit inner loop after hit
                     }
                 }
                 if (projectile.position.z < playerMotorcycle.position.z - 200) {
                     scene.remove(projectile); activeProjectiles.splice(i, 1);
                 }
            }

            // Blaster Bolt collision detection
            if (isBlasterActive) {
                // Check collision with bat gangs
                for (let i = batGangs.length - 1; i >= 0; i--) {
                    const batGang = batGangs[i];
                    const distance = playerMotorcycle.position.distanceTo(batGang.position);
                    const blasterCollisionThreshold = 4.0; // Increased range since rider is the source
                    if (distance < blasterCollisionThreshold) {
                        setMessage(`Blaster Bolt destroyed bat gang! ++15 ETHER!`);
                        score += 15;
                        updateScoreDisplay();
                        scene.remove(batGang);
                        batGangs.splice(i, 1);
                        createTSphereImpactExplosion(batGang.position.clone()); // DRAMATIC DISCO impact explosion
                        trackEnemyDefeat();
                    }
                }
                
                // Check collision with AI riders
                for (let i = aiMotorcycles.length - 1; i >= 0; i--) {
                    const aiBike = aiMotorcycles[i];
                    const distance = playerMotorcycle.position.distanceTo(aiBike.position);
                    const blasterCollisionThreshold = 3.5; // Increased range since rider is the source
                    if (distance < blasterCollisionThreshold) {
                        setMessage(`Blaster Bolt destroyed Imperial! ++15 ETHER!`);
                        score += 15;
                        updateScoreDisplay();
                        scene.remove(aiBike);
                        aiMotorcycles.splice(i, 1);
                        console.log(`AI motorcycle destroyed by blaster bolt. Remaining: ${aiMotorcycles.length}`);
                        createTSphereImpactExplosion(aiBike.position.clone()); // DRAMATIC DISCO impact explosion
                        trackEnemyDefeat();
                    }
                }
                
                // Check collision with dragons/TIE fighters
                for (let i = dragons.length - 1; i >= 0; i--) {
                    const tieFighter = dragons[i];
                    const tieFighterHead = tieFighter.userData.segments[0];
                    const tieFighterHeadPosition = tieFighterHead.getWorldPosition(new THREE.Vector3());
                    const distance = playerMotorcycle.position.distanceTo(tieFighterHeadPosition);
                    const blasterCollisionThreshold = 5.0; // Increased range since rider is the source
                    if (distance < blasterCollisionThreshold) {
                        setMessage(`Blaster Bolt destroyed TIE Fighter! ++15 ETHER!`);
                        score += 15;
                        updateScoreDisplay();
                        scene.remove(tieFighter);
                        dragons.splice(i, 1);
                        createTSphereImpactExplosion(tieFighter.position.clone()); // DRAMATIC DISCO impact explosion
                        trackEnemyDefeat();
                    }
                }
            }

            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                const distance = playerMotorcycle.position.distanceTo(obstacle.position);
                // Only regular obstacles (not player-dropped) can kill the player
                if (!obstacle.userData.isPlayerObstacle && !isInvincible && !isGhostActive && !isCinematicInvulnerable && distance < 1.5) { gameOver(); return; }
            }
            for (let i = bowlingBallObstacles.length - 1; i >= 0; i--) {
                const bowlingBall = bowlingBallObstacles[i];
                const distance = playerMotorcycle.position.distanceTo(bowlingBall.position);
                if (!isInvincible && !isGhostActive && !isCinematicInvulnerable && distance < 1.8) { 
                    triggerCameraShake(1.2, 500); // Very strong shake for bowling ball death
                    gameOver(); return; 
                }
            }
            for (let i = aiMotorcycles.length - 1; i >= 0; i--) {
                const aiBike = aiMotorcycles[i];
                const distance = playerMotorcycle.position.distanceTo(aiBike.position);
                if (distance < 1.0) {
                    if (isMagnetActive) {
                        // Radioactive mode: kill AI competitor
                        scene.remove(aiBike);
                        aiMotorcycles.splice(i, 1);
                        console.log(`AI motorcycle destroyed by radioactive mode. Remaining: ${aiMotorcycles.length}`);
                                                  score += 30; // Award points for killing AI in Radioactive mode
                          updateScoreDisplay();
                        setMessage("Radioactive destroyed Imperial! ++30 ETHER!");
                        createExplosion(aiBike.position.clone(), 0xffffff); // White explosion for Radioactive mode
                        trackEnemyDefeat(); // Track enemy defeat
                    } else if (!isInvincible && !isGhostActive && !isCinematicInvulnerable) {
                        gameOver(); return;
                    }
                }
            }
             for (let i = bowlingBallObstacles.length - 1; i >= 0; i--) {
                 const bowlingBall = bowlingBallObstacles[i];
                 for (let j = aiMotorcycles.length - 1; j >= 0; j--) {
                     const aiBike = aiMotorcycles[j];
                     const distance = aiBike.position.distanceTo(bowlingBall.position);
                     if (distance < 1.8) {
                         scene.remove(bowlingBall); bowlingBallObstacles.splice(i, 1);
                         score = Math.max(-1, score - bowlingBallPenalty);
                         updateScoreDisplay();
                         setMessage(`An AI collected a bowling ball! Popn -${bowlingBallPenalty}!`);
                         break;
                     }
                 }
             }
             
             // Check AI collisions with player-dropped obstacles
             for (let i = obstacles.length - 1; i >= 0; i--) {
                 const obstacle = obstacles[i];
                 if (obstacle.userData.isPlayerObstacle) {
                     for (let j = aiMotorcycles.length - 1; j >= 0; j--) {
                         const aiBike = aiMotorcycles[j];
                         const distance = aiBike.position.distanceTo(obstacle.position);
                         if (distance < 1.5) {
                             scene.remove(obstacle); obstacles.splice(i, 1);
                             scene.remove(aiBike); aiMotorcycles.splice(j, 1);
                             console.log(`AI motorcycle destroyed by mine. Remaining: ${aiMotorcycles.length}`);
                             score += 10; // Award 10 points
                             updateScoreDisplay();
                             setMessage(`Imperial hit your Krypton! +10 Photons!`);
                             createExplosion(aiBike.position.clone(), 0x00ff00); // Green explosion
                             triggerCameraShake(0.5, 250); // Shake for Krypton impact
                             trackEnemyDefeat(); // Track enemy defeat
                             break;
                         }
                     }
                     
                     // KRYPTON vs DRAGON COLLISION - THE ONLY WAY TO DEFEAT DRAGONS!
                     for (let k = dragons.length - 1; k >= 0; k--) {
                         const dragon = dragons[k];
                         const distanceToKrypton = dragon.position.distanceTo(obstacle.position);
                         if (distanceToKrypton < 5.0) { // Larger range for dramatic effect
                             // KRYPTON DESTROYS THE DRAGON!
                             scene.remove(obstacle); obstacles.splice(i, 1);
                             scene.remove(dragon); dragons.splice(k, 1);
                             
                             // MASSIVE EXPLOSION AND REWARDS
                             createTSphereImpactExplosion(dragon.position.clone()); // Huge explosion
                             triggerCameraShake(5.0, 3000); // Intense screen shake
                             
                             // HUGE POINT REWARD
                             score += 1000;
                             updateScoreDisplay();
                             
                             // EPIC MESSAGE SEQUENCE
                             setMessage("ðŸ’Ž KRYPTON DESTROYS THE STRONGHOLD!");
                             setTimeout(() => setMessage("ðŸŽ† MASSIVE DESTRUCTION! +1000 ETHER!"), 1000);
                             setTimeout(() => setMessage("ðŸ‘‘ You are truly terrific!"), 2000);
                             
                             // DRAMATIC SOUND AND VISUAL EFFECTS
                             explosionSynth.triggerAttackRelease("8n");
                             powerUpActivateSynth.triggerAttackRelease('A3', '2n'); // Deep victory sound
                             
                             trackEnemyDefeat(); // Track the ultimate defeat
                             console.log("DRAGON DEFEATED BY KRYPTON!");
                             break;
                         }
                     }
                 }
             }
             if (level >= 2) { // Bat gangs still appear from level 2
                 for (let i = batGangs.length - 1; i >= 0; i--) {
                     const batGang = batGangs[i];
                     const distance = playerMotorcycle.position.distanceTo(batGang.position);
                     if (!isInvincible && !isGhostActive && !isCinematicInvulnerable && distance < 2.5) { 
                     triggerCameraShake(0.9, 400); // Strong shake for bat gang death
                     gameOver(); return; 
                 }
                 }
             }
            // Check collision with Dragon
            for (let i = dragons.length - 1; i >= 0; i--) {
                 const tieFighter = dragons[i];
                 // Get the tieFighter's head segment (first segment) for more precise collision
                 const tieFighterHead = tieFighter.userData.segments[0];
                 const tieFighterHeadPosition = tieFighterHead.getWorldPosition(new THREE.Vector3());
                 const distanceToDragon = playerMotorcycle.position.distanceTo(tieFighterHeadPosition);
                 const tieFighterPlayerCollisionThreshold = 1.5; // Reduced from 4.0/6.0 to require actual contact
                 
                 if (!isInvincible && !isCinematicInvulnerable && distanceToDragon < tieFighterPlayerCollisionThreshold) {
                     if (isGhostActive) {
                         // Ghost Mode now only protects, doesn't destroy dragons
                         setMessage("ðŸ‘» Ghost Mode protected you from the stronghold!");
                         setMessage("ðŸ’¡ Hint: Only Krypton can destroy strongholds!");
                         // Push dragon away but don't destroy it
                         const pushDirection = new THREE.Vector3()
                             .subVectors(tieFighter.position, playerMotorcycle.position)
                             .normalize()
                             .multiplyScalar(10);
                         tieFighter.position.add(pushDirection);
                     } else {
                         triggerCameraShake(1.5, 600); // Very strong shake for dragon death
                         gameOver();
                         return;
                     }
                 }
            }


            // Update burst particles life and opacity
            for (let i = activeBursts.length - 1; i >= 0; i--) {
                const burstParticle = activeBursts[i];
                burstParticle.userData.life++;
                const progress = burstParticle.userData.life / burstParticle.userData.maxLife;

                // Handle different particle types
                if (burstParticle.userData.isVoidCore) {
                    // Void core pulsing effect
                    const pulseFactor = Math.sin(burstParticle.userData.life * 0.1) * 0.3 + 1;
                    burstParticle.scale.setScalar(pulseFactor);
                    burstParticle.material.opacity = 0.9 * (1 - progress);
                } else if (burstParticle.userData.rotationSpeed !== undefined) {
                    // Wormhole particles with spiral movement
                    burstParticle.position.add(burstParticle.userData.velocity);
                    burstParticle.rotation.x += burstParticle.userData.rotationSpeed;
                    burstParticle.rotation.y += burstParticle.userData.rotationSpeed * 0.7;
                    
                    // Fade particles as they spiral inward
                    burstParticle.material.opacity = 0.8 * (1 - progress);
                    
                    // Slight scale reduction as they approach center
                    burstParticle.scale.setScalar(1 - progress * 0.3);
                } else {
                    // Standard particles (coin bursts, explosions, etc.)
                    burstParticle.position.add(burstParticle.userData.velocity);
                    burstParticle.userData.velocity.multiplyScalar(0.98); // Add some drag for better effect
                    
                    // Keep particles visible longer, fade only near the end
                    burstParticle.material.opacity = progress < 0.7 ? 1.0 : 1.0 - ((progress - 0.7) / 0.3);
                    const scale = (1 - progress) * 1.5; // Start at 1.5 and shrink to 0
                    burstParticle.scale.set(scale, scale, scale);
                    
                    // Add slight rotation for more visual appeal
                    burstParticle.rotation.x += 0.1;
                    burstParticle.rotation.y += 0.1;
                    burstParticle.rotation.z += 0.1;
                }

                if (progress >= 1) {
                    scene.remove(burstParticle);
                    // Check if this is an explosion particle (not pooled) and dispose material
                    if (burstParticle.userData.isExplosion || burstParticle.userData.isVoidCore || burstParticle.userData.rotationSpeed !== undefined) {
                        burstParticle.material.dispose();
                        if (burstParticle.geometry) burstParticle.geometry.dispose();
                    } else {
                        returnToPool('particles', burstParticle);
                    }
                    activeBursts.splice(i, 1);
                }
            }


            dialogueTimer++;
            if (dialogueTimer >= dialogueInterval) { showRandomDialogue(); dialogueTimer = 0; }
            lightningTimer++;
            if (lightningTimer >= lightningInterval) { createLightningStrike(); lightningTimer = 0; }

            // Add this line after other particle updates
            updateBoostParticles();
            
            // NEW: Update all enhancement systems (pass currentMoveSpeed context)
            updateDiscoGlow(); // Mr. Terrific's DISCO glow
            if (typeof currentMoveSpeed !== 'undefined') {
                updateEngineSound(); // Engine sound scaling
                createSpeedLines(); // Dynamic speed lines
            }
            
            // Update session stats
            if (isGameRunning && !isGameOver && !gamePaused) {
                updateSessionStats();
            }
            
            // Update Ether trails
            for (let i = etherTrails.length - 1; i >= 0; i--) {
                const trail = etherTrails[i];
                trail.position.add(trail.userData.velocity);
                trail.userData.life++;
                const progress = trail.userData.life / trail.userData.maxLife;
                trail.material.opacity = 0.7 * (1 - progress);
                
                if (progress >= 1) {
                    scene.remove(trail);
                    trail.material.dispose();
                    etherTrails.splice(i, 1);
                }
            }
            
            // Update speed lines
            for (let i = speedLines.length - 1; i >= 0; i--) {
                const line = speedLines[i];
                line.position.z += line.userData.speed;
                
                if (line.position.z > playerMotorcycle.position.z + 20) {
                    scene.remove(line);
                    line.material.dispose();
                    speedLines.splice(i, 1);
                }
            }

            // Add after the createStarfield function
            const meteors = []; // Array to hold meteor instances

            function createMeteor() {
                const meteorGroup = new THREE.Group();
                
                // Create meteor body
                const meteorGeometry = new THREE.ConeGeometry(0.2, 1, 8);
                const meteorMaterial = new THREE.MeshBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.AdditiveBlending
                });
                const meteorBody = new THREE.Mesh(meteorGeometry, meteorMaterial);
                meteorBody.rotation.x = Math.PI / 2;
                meteorGroup.add(meteorBody);
                
                // Add meteor trail
                const trailGeometry = new THREE.BufferGeometry();
                const trailMaterial = new THREE.LineBasicMaterial({
                    color: 0x00ffff,
                    transparent: true,
                    opacity: 0.4,
                    blending: THREE.AdditiveBlending
                });
                
                const trailPoints = [];
                for (let i = 0; i < 10; i++) {
                    trailPoints.push(new THREE.Vector3(0, 0, i * 0.2));
                }
                trailGeometry.setFromPoints(trailPoints);
                const trail = new THREE.Line(trailGeometry, trailMaterial);
                trail.rotation.x = Math.PI / 2;
                meteorGroup.add(trail);
                
                // Random starting position
                meteorGroup.position.set(
                    (Math.random() - 0.5) * 100,
                    50 + Math.random() * 30,
                    -100 - Math.random() * 50
                );
                
                // Random direction
                meteorGroup.userData.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    -2 - Math.random(),
                    (Math.random() - 0.5) * 2
                );
                
                meteorGroup.userData.life = 0;
                meteorGroup.userData.maxLife = 100;
                
                return meteorGroup;
            }

            function updateMeteors() {
                if (level >= 10) {
                    // Spawn new meteors
                    if (Math.random() < 0.05 && meteors.length < 10) {
                        const meteor = createMeteor();
                        scene.add(meteor);
                        meteors.push(meteor);
                    }
                    
                    // Update existing meteors
                    for (let i = meteors.length - 1; i >= 0; i--) {
                        const meteor = meteors[i];
                        meteor.userData.life++;
                        
                        // Move meteor
                        meteor.position.add(meteor.userData.velocity);
                        
                        // Rotate meteor
                        meteor.rotation.z += 0.1;
                        
                        // Fade out
                        const progress = meteor.userData.life / meteor.userData.maxLife;
                        meteor.children.forEach(child => {
                            if (child.material) {
                                child.material.opacity = 0.8 * (1 - progress);
                            }
                        });
                        
                        // Remove if too old or out of bounds
                        if (meteor.userData.life >= meteor.userData.maxLife || 
                            meteor.position.y < -50 || 
                            Math.abs(meteor.position.x) > 100 || 
                            Math.abs(meteor.position.z) > 100) {
                            scene.remove(meteor);
                            meteors.splice(i, 1);
                        }
                    }
                } else {
                    // Clear meteors if level is below 10
                    meteors.forEach(meteor => scene.remove(meteor));
                    meteors.length = 0;
                }
            }

            // Add to the animate function, after updateBoostParticles()
            updateMeteors();

            // Update all new systems
            updateWeather();
            // updateFloatingQuotes(); // Disabled to prevent errors
            updateCinematicCamera();
            
            // Apply trail effects only when boosting
            if (isBoosting && Math.random() < 0.3) {
                createTrailEffect(customization.currentTrail);
            }

            // Update camera only if not in cinematic mode
            if (!cinematicCamera.active) {
                const cameraOffset = new THREE.Vector3(0, 2.5, 4);
                const rotatedOffset = cameraOffset.applyQuaternion(playerMotorcycle.quaternion);
                camera.position.copy(playerMotorcycle.position).add(rotatedOffset);
                
                // Apply camera shake if active
                                  if (cameraShake.active) {
                      updateCameraShake();
                  }
                  
                  // Update lens flares every frame
                  updateLensFlares();
                
                camera.lookAt(playerMotorcycle.position);
            }

            renderer.render(scene, camera);
        }

        function gameOver() {
            console.log("Game Over triggered - stopping all systems");
            isGameOver = true; 
            isGameRunning = false; 
            gamePaused = true;
            
            // Force stop animation loop
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
                window.animationFrameId = null;
            }
            
            // Stop all continuous audio when game ends
            stopAllEnhancedAudio();
            
            // Calculate final session stats
            sessionStats.sessionTime = getAdjustedTime() - sessionStats.startTime;
            
            // Jackpot system removed - no longer needed

            // boostSound.pause();
            // boostSound.currentTime = 0;
            
            setGameUIVisibility(false);
            gameCanvas.style.display = 'none';
            gameFooter.style.display = 'none';
            
            // Populate the unified mission stats directly
            populateMissionStats();
            
            finalScoreDisplay.textContent = 'Final ETHER: ' + score;
            finalLevelDisplay.textContent = 'Sector Reached: ' + level;
            
            // Save session score to Firebase (completely fire-and-forget)
            setTimeout(() => {
                savePersistentScore(score).catch(error => {
                    console.error('Failed to save score, but game continues:', error);
                });
            }, 100); // Delay to ensure game over screen shows first
            
            // Check if this score deserves the name input modal
            if (leaderboard.shouldShowNameInput(score)) {
                // Delay showing high score modal to let game over screen appear first
                setTimeout(() => {
                    showHighScoreModal(score, level);
                }, 1000);
            } else if (leaderboard.isHighScore(score)) {
                // Score made the leaderboard and we have the player's name
                // Save automatically with their stored name
                const playerData = {
                    name: playerName || 'Anonymous',
                    score: score,
                    level: level,
                    playtime: calculatePlaytime(),
                    enemiesDefeated: totalEnemiesDefeated,
                    discosFired: totalDiscoProjectiles
                };
                leaderboard.saveScore(playerData);
                
                const rank = leaderboard.getRank(score);
                if (playerName) {
                    setTimeout(() => {
                        if (rank === 1) {
                            setMessage(`ðŸ† NEW HIGH SCORE! ${playerName} is #1 with ${score} ETHER!`);
                        } else {
                            setMessage(`ðŸŽ¯ Great run, ${playerName}! Rank #${rank} with ${score} ETHER!`);
                        }
                    }, 1500);
                } else {
                    setTimeout(() => {
                        setMessage(`ðŸŽ¯ Rank #${rank} achieved! Check Hall of Fame to see standings.`);
                    }, 1500);
                }
            }
            
            gameOverScreen.style.display = 'flex';
            dialogueBox.style.display = 'none';
            levelUpPopup.style.display = 'none';
            lightningFlashElement.style.display = 'none';
            crashPosition.copy(playerMotorcycle.position);
            crashNoise.triggerAttackRelease("2n", Tone.now(), 0.5);
        }

        async function restartGame() {
            console.log("=== RESTART GAME FUNCTION CALLED ===");
            console.log("Current game state - isGameOver:", isGameOver, "isGameRunning:", isGameRunning);
            
            // CRITICAL: FIRST - Hide all screens and show game immediately
            const startScreenEl = document.getElementById('start-screen');
            const gameOverScreenEl = document.getElementById('game-over-screen');
            
            if (startScreenEl) {
                startScreenEl.style.display = 'none';
                startScreenEl.style.visibility = 'hidden';
            }
            if (gameOverScreenEl) {
                gameOverScreenEl.style.display = 'none';
            }
            
            // Show game canvas immediately
            gameCanvas.style.display = 'block';
            gameCanvas.style.visibility = 'visible';
            gameFooter.style.display = 'flex';
            
            // Force set states immediately to prevent conflicts
            console.log("Forcing game states...");
            
            // IMMEDIATE state clearing - no async operations
            isGameOver = false;
            isGameRunning = true; // Set to true immediately for proper restart
            gamePaused = false;
            
            // Force stop all animation loops
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
                window.animationFrameId = null;
            }
            
            // Clear crash effects immediately
            crashPosition.set(0, 0, 0);
            
            // Force reset all display states - ENSURE clean transition
            gameOverScreen.style.display = 'none';
            startScreen.style.display = 'none';
            gameCanvas.style.display = 'block';
            gameFooter.style.display = 'flex';
            
            // Make sure we DON'T show the start screen
            const startScreenElement = document.getElementById('start-screen');
            if (startScreenElement) startScreenElement.style.display = 'none';
            
            // Reset camera position BEFORE starting game to prevent collision screen
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            
            setGameUIVisibility(true);
            
            // Clear any pending timers that might interfere
            if (invincibilityTimer) { clearTimeout(invincibilityTimer); invincibilityTimer = null; }
            if (ghostTimer) { clearTimeout(ghostTimer); ghostTimer = null; }
            if (magnetTimer) { clearTimeout(magnetTimer); magnetTimer = null; }
            if (slowTimeTimer) { clearTimeout(slowTimeTimer); slowTimeTimer = null; }
            if (miniBoostTimer) { clearTimeout(miniBoostTimer); miniBoostTimer = null; }
            resetSessionStats(); // Reset session statistics
            
            // Reset leaderboard tracking variables
            totalEnemiesDefeated = 0;
            totalDiscoProjectiles = 0;
            
            // Reset pause timing for new game
            pauseStartTime = 0;
            totalPausedTime = 0;
            sessionStartTime = Date.now(); // Use actual time for new session
            lastLeaderboardCheck = 0;
            
            // Clear any existing animation frame
            if (window.animationFrameId) {
                cancelAnimationFrame(window.animationFrameId);
                window.animationFrameId = null;
            }
            
            updateMobileControlVisibility(); updatePowerUpDisplay();

            isFirstLaunch = false;
            customization.currentTrail = 'default';
            updateSettingsDisplay();

            // boostSound.pause();
            // boostSound.currentTime = 0;

            // Load persistent ether score instead of resetting to 0
            await loadPersistentScore();
            level = 1; levelThreshold = 5; levelDisplay.textContent = 'Sector: ' + level;
            
            // Removed jackpot system - no longer needed

            coinsForPowerUp = 0; isInvincible = false;
            if (invincibilityTimer) clearTimeout(invincibilityTimer); invincibilityTimer = null;

            isGhostActive = false; if (ghostTimer) clearTimeout(ghostTimer); ghostTimer = null;
            ghostPulsePhase = 0; // Reset ghost pulse
            // Restore original materials if game ended with shield on
            if (playerRiderBody && originalRiderMaterials.body) {
                playerRiderBody.material = originalRiderMaterials.body;
            }
            if (playerRiderHead && originalRiderMaterials.head) {
                playerRiderHead.material = originalRiderMaterials.head;
            }

            isMagnetActive = false; if (magnetTimer) clearTimeout(magnetTimer); magnetTimer = null;
            isSlowTimeActive = false; if (slowTimeTimer) clearTimeout(slowTimeTimer); slowTimeTimer = null;
            slowTimeFactor = 0.5;
            hasProjectile = false; hasObstacleDrop = false; hasSwapPosition = false;
            updatePowerUpDisplay();

            baseMoveSpeed = initialBaseMoveSpeed; moveSpeed = baseMoveSpeed; isBoosting = false;
            manualBoostsUsed = 0; // Reset manual boost counter
            isMiniBoostActive = false; // Reset boost
            if (miniBoostTimer) clearTimeout(miniBoostTimer); miniBoostTimer = null;
            updateBoostButtonDisplay(); // Update button display
            boostButton.disabled = isBoosting || gamePaused || level < BOOST_UNLOCK_LEVEL;

            // Properly dispose of all objects
            coins.forEach(coin => { scene.remove(coin); returnToPool('coins', coin); }); coins.length = 0;
            obstacles.forEach(obstacle => { scene.remove(obstacle); disposeObject(obstacle); }); obstacles.length = 0;
            bowlingBallObstacles.forEach(ball => { scene.remove(ball); disposeObject(ball); }); bowlingBallObstacles.length = 0;
            batGangs.forEach(gang => { scene.remove(gang); disposeObject(gang); }); batGangs.length = 0;
            powerUps.forEach(powerUp => { scene.remove(powerUp); disposeObject(powerUp); }); powerUps.length = 0;
            itemBoxes.forEach(itemBox => { scene.remove(itemBox); disposeObject(itemBox); }); itemBoxes.length = 0;
            greenVials.forEach(vial => { scene.remove(vial); disposeObject(vial); }); greenVials.length = 0;
            activeProjectiles.forEach(projectile => { scene.remove(projectile); disposeObject(projectile); }); activeProjectiles.length = 0;
            dragons.forEach(tieFighter => { scene.remove(tieFighter); disposeObject(tieFighter); }); dragons.length = 0;
            activeBursts.forEach(burst => { scene.remove(burst); returnToPool('particles', burst); }); activeBursts.length = 0;
            
            // NEW GALAXY ZONE cleanup
            galaxyShips.forEach(ship => { scene.remove(ship); disposeObject(ship); }); galaxyShips.length = 0;
            galaxyProjectiles.forEach(proj => { scene.remove(proj); disposeObject(proj); }); galaxyProjectiles.length = 0;
            galaxyBombs.forEach(bomb => { scene.remove(bomb); disposeObject(bomb); }); galaxyBombs.length = 0;
            galaxyZoneActive = false;
            galaxyZoneTimer = 0;

             // Properly remove and recreate player motorcycle to ensure fresh state
             scene.remove(playerMotorcycle);
             
             // Recreate player motorcycle from scratch
             const playerMotorcycleParts = createMotorcycle(0x000000, 0x000000, true);
             const newPlayerMotorcycle = playerMotorcycleParts.motorcycle;
             playerRiderBody = playerMotorcycleParts.riderBody;
             playerRiderHead = playerMotorcycleParts.riderHead;
             
             // Force red helmet for player
             if (playerRiderHead) {
                 playerRiderHead.material = new THREE.MeshStandardMaterial({
                     color: 0xff3333,
                     metalness: 0.9,
                     roughness: 0.1,
                     emissive: 0xff3333,
                     emissiveIntensity: 1.5,
                     transparent: true,
                     opacity: 0.9
                 });
             }
             
             // Replace global reference
             playerMotorcycle = newPlayerMotorcycle;
             playerMotorcycle.position.set(0, 0, 0);
             scene.add(playerMotorcycle);
             
             // Recreate AI motorcycles
             aiMotorcycles.forEach(aiBike => scene.remove(aiBike)); aiMotorcycles.length = 0;
             numAIMotorcycles = baseAiBikes; createInitialAIMotorcycles();

            // Reset road segments to initial state
            currentRoadTextureIndex = 0;
            roadSegments.forEach(segment => {
                segment.material = sharedRoadMaterials[currentRoadTextureIndex];
            });
            lastSceneryChangeZ = playerMotorcycle.position.z;

            playerRandomSteerDirection = 0; playerRandomSteerTimer = 0;
            dialogueTimer = 0; lightningTimer = 0;
            lightningLight.intensity = 0; lightningFlashElement.style.display = 'none';
            obstacleSpeedMultiplier = 1.5;
            updateRiderAppearance(1); // Reset rider appearance to level 1 (matte black)
            isJumping = false; jumpVelocity = 0;

            // Reset starfield to initial relative position
            if (stars) stars.position.set(0,0,0); // Or relative to camera if desired

            boostParticles.forEach(particle => scene.remove(particle));
            boostParticles.length = 0;
            
            // NEW: Clean up enhancement effects
            etherTrails.forEach(trail => { scene.remove(trail); trail.material.dispose(); });
            etherTrails.length = 0;
            speedLines.forEach(line => { scene.remove(line); line.material.dispose(); });
            speedLines.length = 0;
            hyperspaceActive = false;
            forcePowerActive = false;
            
            // Clean up audio systems properly
            stopAllEnhancedAudio(); // Use comprehensive cleanup function
            
                         // Restart enhanced audio systems after cleanup (only if enabled)
             setTimeout(() => {
                 if (isGameRunning && audioSystemEnabled) {
                     try {
                         startEngineSynth();
                         startAmbientMusic();
                     } catch(e) {
                         console.log("Enhanced audio restart after cleanup:", e);
                     }
                 }
             }, 100);
             
            // Particle system disabled - no background updates needed
             
            // Ensure complete UI reset
            const dialogueBoxElement = document.getElementById('dialogue-box');
            if (dialogueBoxElement) {
                dialogueBoxElement.textContent = '';
                dialogueBoxElement.style.display = 'none';
            }
            
            // Finally confirm game running and start animation
            console.log("Confirming game running and starting animation loop...");
            isGameRunning = true;
            isGameOver = false;
            
            // Force render one clean frame to establish proper view
            renderer.render(scene, camera);
            
            // Clear any residual message displays
            const dialogueBox = document.getElementById('dialogue-box');
            if (dialogueBox) {
                dialogueBox.textContent = '';
                dialogueBox.style.display = 'none';
            }
            
            // Reset all visual elements to ensure clean start - STAY IN GAME
            const startScreenReset = document.getElementById('start-screen');
            if (startScreenReset) startScreenReset.style.display = 'none';
            if (gameOverScreen) gameOverScreen.style.display = 'none';
            
            // Ensure game canvas is visible and properly sized - KEEP PLAYING
            gameCanvas.style.display = 'block';
            gameCanvas.style.visibility = 'visible';
            
            // Ensure UI stays visible for continued gameplay
            setGameUIVisibility(true);
            
            // Force a complete re-render to clear any residual graphics
            renderer.clear();
            renderer.render(scene, camera);
            
            // Clear all intervals to prevent memory leaks
            if (cleanupPowerUpsInterval) clearInterval(cleanupPowerUpsInterval);
            if (cleanupSceneInterval) clearInterval(cleanupSceneInterval);
            if (memoryMonitorInterval) clearInterval(memoryMonitorInterval);
            
            // Clear any lingering timers
            const highestId = setTimeout(() => {}, 0);
            for (let i = 0; i < highestId; i++) {
                clearTimeout(i);
            }
            
            // Restart essential intervals only
            cleanupPowerUpsInterval = setInterval(cleanupPowerUps, 5000);
            cleanupSceneInterval = setInterval(cleanupScene, 30000);
            memoryMonitorInterval = setInterval(monitorPerformance, 10000);
            
            // Start animation immediately - DIRECT RESTART, NO HOME SCREEN
            console.log("Starting fresh animation loop immediately - staying in game...");
            
            // EXTRA SAFEGUARD: Verify states before starting animation
            if (isGameOver || !isGameRunning) {
                console.log("WARNING: Game states not properly set - forcing correct states");
                isGameOver = false;
                isGameRunning = true;
                gamePaused = false;
            }
            
            window.animationFrameId = requestAnimationFrame(animate);
            
            // MULTIPLE SAFEGUARDS: Ensure start screen stays hidden after restart
            setTimeout(() => {
                const startScreenCheck = document.getElementById('start-screen');
                const gameOverScreenCheck = document.getElementById('game-over-screen');
                
                if (startScreenCheck && startScreenCheck.style.display !== 'none') {
                    console.log("WARNING: Start screen was visible after restart - forcing hide");
                    startScreenCheck.style.display = 'none';
                    startScreenCheck.style.visibility = 'hidden';
                }
                if (gameOverScreenCheck && gameOverScreenCheck.style.display !== 'none') {
                    console.log("WARNING: Game over screen was visible after restart - forcing hide");
                    gameOverScreenCheck.style.display = 'none';
                }
                
                // Ensure game UI is visible
                setGameUIVisibility(true);
                gameCanvas.style.display = 'block';
                gameCanvas.style.visibility = 'visible';
                gameFooter.style.display = 'flex';
                
                // Final state verification
                if (!isGameRunning || isGameOver) {
                    console.log("CRITICAL: Game states corrupted after restart - forcing fix");
                    isGameOver = false;
                    isGameRunning = true;
                    gamePaused = false;
                }
            }, 50);
            
            // Additional safeguard at 200ms
            setTimeout(() => {
                const startScreenFinal = document.getElementById('start-screen');
                if (startScreenFinal && startScreenFinal.style.display !== 'none') {
                    console.log("FINAL WARNING: Start screen still visible - ultimate force hide");
                    startScreenFinal.style.display = 'none';
                    startScreenFinal.style.visibility = 'hidden';
                }
            }, 200);
            
            console.log("=== RESTART COMPLETE - GAME SHOULD BE RUNNING ===");
        }



        function activateBoost(duration = 3000, isManualBoost = false, forceBoost = false) {
            // Calculate available manual boosts based on level (1 per every 10 levels)
            const maxManualBoosts = Math.floor((level - 1) / 10) + 1;
            
            // Check if manual boost is allowed
            if (isManualBoost && manualBoostsUsed >= maxManualBoosts) {
                setMessage(`âš¡ Manual boosts limited! ${manualBoostsUsed}/${maxManualBoosts} used. Next boost at level ${Math.ceil(level / 10) * 10 + 1}!`);
                return;
            }
            
            if (forceBoost || (!isBoosting && isGameRunning && !gamePaused && level >= BOOST_UNLOCK_LEVEL)) {
                isBoosting = true;
                boostButton.disabled = true;
                // boostSound.play().catch(e => console.error("Error playing boost sound:", e));
                
                // Increment manual boost counter if this is a manual boost
                if (isManualBoost) {
                    manualBoostsUsed++;
                    setMessage(`âš¡ Manual Boost ${manualBoostsUsed}/${maxManualBoosts} used!`);
                    updateBoostButtonDisplay(); // Update button display
                }
                
                // Activate cinematic camera for boost
                activateCinematicCamera('boost');
                
                // Add rainbow boost light
                const boostLight = new THREE.PointLight(0xffffff, 2, 10);
                boostLight.position.set(0, 0, 1);
                boostLight.userData.hue = 0;
                playerMotorcycle.add(boostLight);
                
                // Update light color in animation loop
                const lightUpdate = () => {
                    if (isBoosting && !isGameOver) {
                        boostLight.userData.hue = (boostLight.userData.hue + 0.02) % 1;
                        const color = new THREE.Color().setHSL(boostLight.userData.hue, 1, 0.5);
                        boostLight.color.copy(color);
                        requestAnimationFrame(lightUpdate);
                    }
                };
                lightUpdate();
                
                setTimeout(() => {
                    isBoosting = false;
                    if (!gamePaused && level >= BOOST_UNLOCK_LEVEL) boostButton.disabled = false;
                    playerMotorcycle.remove(boostLight);
                    if (isFirstLaunch) {
                        isFirstLaunch = false;
                        customization.currentTrail = 'default';
                        updateSettingsDisplay();
                    }
                }, duration);
            }
        }

        boostButton.addEventListener('click', () => activateBoost(3000, true)); // Manual boost
        
        // Function to update boost button display with remaining boosts
        function updateBoostButtonDisplay() {
            if (level >= BOOST_UNLOCK_LEVEL) {
                const maxManualBoosts = Math.floor((level - 1) / 10) + 1;
                const remainingBoosts = maxManualBoosts - manualBoostsUsed;
                boostButton.textContent = `BLAST (${remainingBoosts}/${maxManualBoosts})`;
            } else {
                boostButton.textContent = 'BLAST';
            }
        }

        // Blaster Bolt system
        function activateBlasterBolt() {
            // Calculate available blaster bolts based on level (1 per every 10 levels)
            const maxBlasterBolts = Math.floor(level / 10);
            
            // Check if blaster bolt is available
            if (maxBlasterBolts === 0) {
                setMessage(`ðŸŽµ VIBES unlocks at level 10!`);
                return;
            }
            
            if (blasterBoltsUsed >= maxBlasterBolts) {
                setMessage(`ðŸŽµ VIBES limited! ${blasterBoltsUsed}/${maxBlasterBolts} used. Next at level ${Math.ceil((level + 1) / 10) * 10}!`);
                return;
            }
            
            if (!isBlasterActive && isGameRunning && !gamePaused) {
                isBlasterActive = true;
                blasterBoltsUsed++;
                blasterButton.disabled = true;
                
                setMessage(`ðŸŽµ VIBES ${blasterBoltsUsed}/${maxBlasterBolts} activated!`);
                updateBlasterButtonDisplay();
                
                // Create blue plasma ball from helmet
                createBlasterBolt();
                
                // Play sound effect
                if (audioSystemEnabled) {
                    projectileSynth.triggerAttackRelease("G4", "0.2");
                }
                
                setTimeout(() => {
                    deactivateBlasterBolt();
                }, blasterDuration);
            }
        }

        function createBlasterBolt() {
            // Store original rider materials before changing them
            if (playerRiderBody && playerRiderBody.material) {
                originalRiderMaterials.blasterBody = playerRiderBody.material.clone();
            }
            if (playerRiderHead && playerRiderHead.material) {
                originalRiderMaterials.blasterHead = playerRiderHead.material.clone();
            }
            
            // Create bright blue pulsating material for rider
            const blasterMaterial = new THREE.MeshStandardMaterial({
                color: 0x0066ff,
                emissive: 0x0033ff,
                emissiveIntensity: 2.0,
                metalness: 0.3,
                roughness: 0.2,
                transparent: true,
                opacity: 0.9
            });
            
            // Apply blue material to rider body and head
            if (playerRiderBody) {
                playerRiderBody.material = blasterMaterial.clone();
            }
            if (playerRiderHead) {
                playerRiderHead.material = blasterMaterial.clone();
            }
            
            // Add pulsing effect to rider
            const pulseRider = () => {
                if (isBlasterActive && playerRiderBody && playerRiderHead) {
                    const pulseIntensity = 2.0 + Math.sin(Date.now() * 0.015) * 1.0;
                    const pulseOpacity = 0.9 + Math.sin(Date.now() * 0.012) * 0.1;
                    
                    if (playerRiderBody.material.emissiveIntensity !== undefined) {
                        playerRiderBody.material.emissiveIntensity = pulseIntensity;
                        playerRiderBody.material.opacity = pulseOpacity;
                    }
                    if (playerRiderHead.material.emissiveIntensity !== undefined) {
                        playerRiderHead.material.emissiveIntensity = pulseIntensity;
                        playerRiderHead.material.opacity = pulseOpacity;
                    }
                    
                    requestAnimationFrame(pulseRider);
                }
            };
            pulseRider();
        }

        function deactivateBlasterBolt() {
            isBlasterActive = false;
            
            // Restore original rider materials
            if (playerRiderBody && originalRiderMaterials.blasterBody) {
                playerRiderBody.material = originalRiderMaterials.blasterBody;
                originalRiderMaterials.blasterBody = null;
            }
            if (playerRiderHead && originalRiderMaterials.blasterHead) {
                playerRiderHead.material = originalRiderMaterials.blasterHead;
                originalRiderMaterials.blasterHead = null;
            }
            
            blasterButton.disabled = false;
            updateBlasterButtonDisplay();
        }

        function updateBlasterButtonDisplay() {
            const maxBlasterBolts = Math.floor(level / 10);
            if (maxBlasterBolts > 0) {
                const remainingBolts = maxBlasterBolts - blasterBoltsUsed;
                blasterButton.textContent = `VIBES (${remainingBolts}/${maxBlasterBolts})`;
                blasterButton.disabled = isBlasterActive || remainingBolts <= 0;
            } else {
                blasterButton.textContent = 'VIBES (Locked)';
                blasterButton.disabled = true;
            }
        }

        blasterButton.addEventListener('click', () => activateBlasterBolt());

        miniBoostButton.addEventListener('click', () => activateMiniBoost());

        // Start game immediately without countdown
        async function startGameImmediately() {
            console.log("Starting game immediately...");
            
            // Load persistent ether score for new game start (with short timeout for quick start)
            try {
                await Promise.race([
                    loadPersistentScore(),
                    new Promise((resolve) => setTimeout(() => {
                        console.log('Quick start - loading with fallback score');
                        score = 0;
                        scoreDisplay.textContent = 'ETHER: ' + score;
                        resolve();
                    }, 2000)) // 2 second quick-start timeout
                ]);
            } catch (error) {
                console.log('Quick start fallback due to error:', error);
                score = 0;
                scoreDisplay.textContent = 'ETHER: ' + score;
            }
            
            // Start the actual game
            startScreen.style.display = 'none';
            gameCanvas.style.display = 'block';
            setGameUIVisibility(true);
            isGameRunning = true;
            customization.currentTrail = 'fire';
            updateSettingsDisplay();
            updateMobileControlVisibility();
            // Give player a projectile at start
            hasProjectile = true;
            updatePowerUpDisplay();
            // Removed jackpot timer - no longer needed
            
            // Initialize lens flares for neon lights
            createLensFlare(neonLight1, 80, 0xff0080); // Hot pink lens flare
            createLensFlare(neonLight2, 80, 0x00ff80); // Electric green lens flare
            createLensFlare(neonLight3, 75, 0x0080ff); // Electric blue lens flare
            createLensFlare(lightningLight, 120, 0xffffff); // Lightning lens flare
            
            // Ensure camera and player are positioned correctly
            camera.position.set(0, 5, playerMotorcycle.position.z + 10);
            camera.lookAt(playerMotorcycle.position);
            
            // Force an initial render to make sure scene is visible
            renderer.render(scene, camera);
            console.log("Initial render completed");
            
            // Audio systems start only when enabled by user (Press 'M' to enable)
            // Restart enhanced audio systems if enabled
            setTimeout(() => {
                if (audioSystemEnabled) {
                    try {
                        startEngineSynth();
                        startAmbientMusic();
                    } catch(e) {
                        console.log("Enhanced audio restart after game start:", e);
                    }
                }
            }, 100);
            
            resetSessionStats(); // Initialize session stats
            // Animation loop already running from page load
        }

        // BOOST system (25% speed boost, unlimited use)
        function activateMiniBoost() {
            if (!isGameRunning || gamePaused) return;
            
            // Clear any existing boost timer
            if (miniBoostTimer) {
                clearTimeout(miniBoostTimer);
            }
            
            if (!isMiniBoostActive) {
                isMiniBoostActive = true;
                setMessage("âš¡ BOOST! +25% Speed!");
                
                // Play a subtle sound effect
                if (audioSystemEnabled) {
                    coinSynth.triggerAttackRelease("C5", "0.1");
                }
            }
            
            // Reset timer (extends boost if already active)
            miniBoostTimer = setTimeout(() => {
                isMiniBoostActive = false;
                setMessage("");
            }, 1500); // 1.5 second duration
        }

         if (isMobileDevice()) {
             steerLeftButton.addEventListener('touchstart', () => { if (!gamePaused && gameMode === 'manual') steerLeftButton.classList.add('active'); });
             steerLeftButton.addEventListener('touchend', () => { steerLeftButton.classList.remove('active'); });
             steerLeftButton.addEventListener('mousedown', () => { if (!gamePaused && gameMode === 'manual') steerLeftButton.classList.add('active'); });
             steerLeftButton.addEventListener('mouseup', () => { steerLeftButton.classList.remove('active'); });
             steerLeftButton.addEventListener('mouseleave', () => { steerLeftButton.classList.remove('active'); });
             steerRightButton.addEventListener('touchstart', () => { if (!gamePaused && gameMode === 'manual') steerRightButton.classList.add('active'); });
             steerRightButton.addEventListener('touchend', () => { steerRightButton.classList.remove('active'); });
             steerRightButton.addEventListener('mousedown', () => { if (!gamePaused && gameMode === 'manual') steerRightButton.classList.add('active'); });
             steerRightButton.addEventListener('mouseup', () => { steerRightButton.classList.remove('active'); });
             steerRightButton.addEventListener('mouseleave', () => { steerRightButton.classList.remove('active'); });
             usePowerUpButton.addEventListener('touchstart', () => { if (!gamePaused && gameMode === 'manual') usePowerUp(); });
             usePowerUpButton.addEventListener('mousedown', () => { if (!gamePaused && gameMode === 'manual') usePowerUp(); });
         }

        // Modal system
        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'flex';
                // Close modal on outside click
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeModal(modalId);
                    }
                });
            }
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Menu button handlers
        document.getElementById('controls-btn').addEventListener('click', () => {
            openModal('controls-modal');
        });

        document.getElementById('difficulty-btn').addEventListener('click', () => {
            openModal('difficulty-modal');
        });

        document.getElementById('tips-btn').addEventListener('click', () => {
            openModal('tips-modal');
        });

        // Close button handlers
        document.querySelectorAll('.close-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const modalId = e.target.dataset.modal;
                closeModal(modalId);
            });
        });

        // Difficulty button handlers (updated for modal)
        document.querySelectorAll('.difficulty-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Remove active class from all buttons
                document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                // Add active class to clicked button
                btn.classList.add('active');
                // Set difficulty
                gameDifficulty = btn.dataset.difficulty;
                // Update the display on the main screen
                document.getElementById('current-difficulty-display').textContent = difficultySettings[gameDifficulty].name;
                setMessage(`Difficulty set to: ${difficultySettings[gameDifficulty].name}`);
                // Close modal after selection
                setTimeout(() => closeModal('difficulty-modal'), 500);
            });
        });

        // ESC key to close modals
        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                ['controls-modal', 'difficulty-modal', 'tips-modal'].forEach(modalId => {
                    const modal = document.getElementById(modalId);
                    if (modal && modal.style.display === 'flex') {
                        closeModal(modalId);
                    }
                });
            }
        });
        
        startButton.addEventListener('click', () => {
            // Ensure AudioContext is resumed on user interaction
            try {
                if (Tone.context.state !== 'running') {
                    Tone.context.resume().then(() => {
                        console.log("AudioContext resumed successfully by start button.");
                        startGameImmediately().catch(e => console.error('Error starting game:', e));
                    }).catch(e => {
                        console.log("AudioContext resume failed, but continuing with game:", e);
                        startGameImmediately().catch(e => console.error('Error starting game:', e));
                    });
                } else {
                    startGameImmediately().catch(e => console.error('Error starting game:', e));
                }
            } catch (e) {
                console.log("Audio context error, but continuing with game:", e);
                startGameImmediately().catch(e => console.error('Error starting game:', e));
            }
        });

        // Multiple event listeners to ensure the button works
        restartButton.addEventListener('click', handleRestartClick);
        restartButton.addEventListener('touchstart', handleRestartClick);
        restartButton.addEventListener('mousedown', handleRestartClick);
        
        function handleRestartClick(e) {
            console.log("=== NEW MISSION BUTTON CLICKED ===");
            console.log("Event type:", e.type);
            console.log("Current states before restart - isGameOver:", isGameOver, "isGameRunning:", isGameRunning, "gamePaused:", gamePaused);
            
            e.preventDefault();
            e.stopPropagation();
            
            // Immediately hide all possible interfering screens
            const startScreenRestart = document.getElementById('start-screen');
            const gameOverScreenRestart = document.getElementById('game-over-screen');
            
            if (startScreenRestart) {
                startScreenRestart.style.display = 'none';
                startScreenRestart.style.visibility = 'hidden';
                console.log("Pre-emptively hid start screen");
            }
            if (gameOverScreenRestart) {
                gameOverScreenRestart.style.display = 'none';
                console.log("Pre-emptively hid game over screen");
            }
            
            // Simple, direct restart - no complex logic
            try {
                console.log("Starting immediate restart process...");
                restartGame().catch(e => console.error('Error restarting game:', e));
                
                // Double-check after restart
                setTimeout(() => {
                    console.log("Post-restart check - isGameOver:", isGameOver, "isGameRunning:", isGameRunning);
                    const startScreenCheck = document.getElementById('start-screen');
                    if (startScreenCheck && startScreenCheck.style.display !== 'none') {
                        console.log("CRITICAL ERROR: Start screen is still visible after restart!");
                        startScreenCheck.style.display = 'none';
                        startScreenCheck.style.visibility = 'hidden';
                    }
                }, 100);
                
            } catch (error) {
                console.error("Error during restart:", error);
                // Fallback: reload the page
                window.location.reload();
            }
        }


        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
             updateMobileControlVisibility();
        });




        // Add after the createStarfield function
        // Shared boost particle geometry and material to prevent memory leaks
        const sharedBoostGeometry = new THREE.OctahedronGeometry(0.13, 0);
        const sharedBoostMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff, // Electric cyan
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });

        function createBoostParticle() {
            // Reuse shared geometry and material to prevent memory leaks
            const particle = new THREE.Mesh(sharedBoostGeometry, sharedBoostMaterial.clone());
            // Rotate to make diamond point forward
            particle.rotation.x = Math.PI / 4;
            particle.rotation.z = Math.PI / 4;
            // Add sparkle phase for animation
            particle.userData.sparklePhase = Math.random() * Math.PI * 2;
            // Add scale for dramatic effect
            particle.userData.initialScale = 0.8 + Math.random() * 0.4; // Random initial scale
            particle.scale.setScalar(particle.userData.initialScale);
            return particle;
        }

        function updateBoostParticles() {
            if (isBoosting) {
                // Reduce particle count for better performance
                const maxBoostParticles = 40; // Reduced from 60 to 40
                const particlesToCreate = Math.min(2, maxBoostParticles - boostParticles.length); // Reduced from 4 to 2
                
                // Create new particles only if under limit
                for (let i = 0; i < particlesToCreate; i++) {
                    const particle = createBoostParticle();
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.8, // Increased spread
                        (Math.random() - 0.5) * 0.8,
                        0.5
                    );
                    particle.position.copy(playerMotorcycle.position).add(offset);
                    particle.userData.life = 0;
                    particle.userData.maxLife = 20; // Reduced lifetime from 25 to 20
                    scene.add(particle);
                    boostParticles.push(particle);
                }
            }

            // Update existing particles
            for (let i = boostParticles.length - 1; i >= 0; i--) {
                const particle = boostParticles[i];
                particle.userData.life++;
                
                // More dramatic rotation
                particle.rotation.y += 0.15;
                particle.rotation.x += 0.05;
                
                // Enhanced sparkle effect
                particle.userData.sparklePhase += 0.25;
                const sparkle = Math.sin(particle.userData.sparklePhase) * 0.3 + 0.7; // More dramatic opacity variation
                particle.material.opacity = 0.6 * sparkle;
                
                // Electric blue color variation
                const blueIntensity = Math.sin(particle.userData.sparklePhase * 0.5) * 0.3 + 0.7;
                particle.material.color.setRGB(0, blueIntensity, blueIntensity);
                
                // Dramatic scaling effect
                const scale = particle.userData.initialScale * (1 - (particle.userData.life / particle.userData.maxLife));
                particle.scale.setScalar(scale);

                if (particle.userData.life >= particle.userData.maxLife) {
                    scene.remove(particle);
                    // Dispose of the cloned material to prevent memory leaks
                    particle.material.dispose();
                    boostParticles.splice(i, 1);
                }
            }
        }



        // Initialize game when the page loads
        window.onload = async function () {
            createCityscape();
            createInitialAIMotorcycles();
            initializeWeather();
            initializeSpatialAudio();
            applySkinToMotorcycle(playerMotorcycle, customization.currentSkin);
            applyRiderOutfit(customization.currentOutfit);
            updateSettingsDisplay();
            boostButton.disabled = isBoosting || gamePaused || level < BOOST_UNLOCK_LEVEL;
            updateBoostButtonDisplay(); // Initialize button display
            blasterButton.disabled = isBlasterActive || Math.floor(level / 10) === 0;
            updateBlasterButtonDisplay(); // Initialize blaster button display
            miniBoostButton.disabled = false; // Boost is always available
            updateRiderAppearance(1);
            playerMotorcycle.position.set(0, 0, 0);
            renderer.render(scene, camera);
            setGameUIVisibility(false);
            gameCanvas.style.display = 'none';
            gameFooter.style.display = 'flex';
            startScreen.style.display = 'flex';
            // Audio status display removed
            
            // Start the animation loop
            animate();
        }



        function updateLevelDisplay() {
            levelDisplay.textContent = 'Sector: ' + level;
        }

        // Add this function to apply extreme difficulty changes
        function applyExtremeDifficulty() {
            // Increase obstacle speed dramatically
            obstacleSpeedMultiplier *= 1.5;
            
            // Increase base move speed
            baseMoveSpeed *= 1.3;
            moveSpeed = baseMoveSpeed;
            
            // Reduce power-up durations
            for (const type in powerUpTypes) {
                if (powerUpTypes[type].duration > 0) {
                    powerUpTypes[type].duration = Math.floor(powerUpTypes[type].duration * 0.6);
                }
            }
            
            // Increase spawn rates for obstacles
            const difficultyFactor = 0.5; // Lower number means more frequent spawns
            
            // Make obstacles appear more frequently
            obstacleSpawnRate = Math.floor(obstacleSpawnRate * difficultyFactor);
            bowlingBallSpawnRate = Math.floor(bowlingBallSpawnRate * difficultyFactor);
            batGangSpawnRate = Math.floor(batGangSpawnRate * difficultyFactor);
            
            // Increase max obstacles
            maxObstacles += 2;
            maxBowlingBalls += 1;
            maxBatGangs += 1;
            
            // Spawn a tieFighter regardless of tieFighter levels
            if (dragons.length === 0) {
                const tieFighter = createDragon(1); // Mid-level tieFighter
                tieFighter.position.set(0, 5, playerMotorcycle.position.z - 150);
                scene.add(tieFighter);
                dragons.push(tieFighter);
                setMessage("A tieFighter appears from the darkness!");
            }
            
            // Make AI competitors more aggressive
            aiMotorcycles.forEach(aiBike => {
                aiBike.userData.steerSpeed *= 1.4;
                aiBike.userData.moveSpeed *= 1.2;
            });
        }



        document.getElementById('how-to-play-link').addEventListener('click', function(event) {
            event.preventDefault();
            toggleGameInstructions();
        });

        // --- JS: UI/UX POLISH ---
        // Animate score when it changes
        function animateScore() {
            scoreDisplay.classList.add('animated-pop');
            setTimeout(() => scoreDisplay.classList.remove('animated-pop'), 300);
        }
        // Animate power-up display
        function animatePowerUpDisplay(type) {
            powerUpDisplay.classList.add('animated-pulse');
            setTimeout(() => powerUpDisplay.classList.remove('animated-pulse'), 800);
            // Optionally shake on use
            if (type === 'use') {
                powerUpDisplay.classList.add('animated-shake');
                setTimeout(() => powerUpDisplay.classList.remove('animated-shake'), 300);
            }
        }
        // Button press feedback
        function addButtonPressFeedback(button) {
            button.addEventListener('mousedown', () => {
                button.style.transform = 'scale(0.92)';
            });
            button.addEventListener('mouseup', () => {
                button.style.transform = '';
            });
            button.addEventListener('mouseleave', () => {
                button.style.transform = '';
            });
            button.addEventListener('touchstart', () => {
                button.style.transform = 'scale(0.92)';
            });
            button.addEventListener('touchend', () => {
                button.style.transform = '';
            });
        }
        addButtonPressFeedback(boostButton);
        addButtonPressFeedback(blasterButton);
        addButtonPressFeedback(miniBoostButton);
        addButtonPressFeedback(usePowerUpButton);
                  // Animate score on update - function merged with optimized version above
        // Animate power-up display on activation/use
        function updatePowerUpDisplay() {
            const activeStatus = [];
            let hasInstantUsePowerUp = false;
            if (isGhostActive) activeStatus.push("Ghost");
            if (isMagnetActive) activeStatus.push("Radioactive");
            if (isSlowTimeActive) activeStatus.push("Slow Time");
            if (hasProjectile) { activeStatus.push("DISCO!"); hasInstantUsePowerUp = true; }
            if (hasObstacleDrop) { activeStatus.push("Obstacle Drop!"); hasInstantUsePowerUp = true; }
            if (hasSwapPosition) { activeStatus.push("Swap Position!"); hasInstantUsePowerUp = true; }
            if (activeStatus.length > 0) {
                powerUpDisplay.textContent = "P-UP: " + activeStatus.join(" | ");
                powerUpDisplay.style.display = 'block';
                animatePowerUpDisplay('activate');
            } else {
                powerUpDisplay.textContent = "";
                powerUpDisplay.style.display = 'none';
            }
            if (isMobileDevice() && gameMode === 'manual' && hasInstantUsePowerUp && isGameRunning && !isGameOver && !gamePaused) {
                usePowerUpButton.style.display = 'flex';
            } else {
                usePowerUpButton.style.display = 'none';
            }
        }
        // DUPLICATE FUNCTION REMOVED - usePowerUp is already defined earlier
        // Update all score/jackpot updates to use new functions
        // Replace all direct scoreDisplay.textContent and jackpotDisplay.textContent assignments with updateScoreDisplay() and updateJackpotDisplay() where appropriate.

        // Dynamic Weather System
        const weather = {
            current: 'clear', // 'clear', 'rain', 'storm'
            intensity: 0,
            rainParticles: [],
            stormTimer: 0,
            changeTimer: 0,
            changeInterval: 1800, // Change weather every 30 seconds (1800 frames at 60fps)
            rainGeometry: null,
            rainMaterial: null,
            rainMesh: null
        };

        // Mr. Terrific Quotes Display
        const starWarsQuotes = [
            "Fair Play prevails",
            "Technology serves justice",
            "Excellence through intellect",
            "T-Spheres activate",
            "Justice never sleeps",
            "Fair Play in all things",
            "Terrific technology deployed",
            "Intellect over brute force",
            "The terrific truth",
            "Science conquers all"
        ];
        const floatingQuotes = [];

        // Customization System
        const customization = {
            bikeTrails: ['default', 'rainbow', 'electric', 'force', 'fire'],
            currentTrail: 'fire',
            bikeSkins: ['default', 'chrome', 'neon', 'carbon', 'gold'],
            currentSkin: 'carbon',
            riderOutfits: ['rebel', 'jedi', 'force_user', 'pilot'],
            currentOutfit: 'force_user'
        };

        // Cinematic Camera System
        const cinematicCamera = {
            active: false,
            type: 'none', // 'levelUp', 'tieFighter', 'boost', 'crash'
            timer: 0,
            duration: 0,
            originalPosition: new THREE.Vector3(),
            targetPosition: new THREE.Vector3(),
            originalRotation: new THREE.Euler(),
            targetRotation: new THREE.Euler()
        };
        
        // Cinematic invulnerability flag
        let isCinematicInvulnerable = false;

        // Enhanced Audio System with 3D positioning
        const spatialAudio = {
            listener: null,
            coinSounds: [],
            engineSound: null,
            windSound: null,
            rainSound: null
        };

        // LOCAL LEADERBOARD SYSTEM
        const leaderboard = {
            maxEntries: 10,
            storageKey: 'trons_leaderboard',
            
            // Save a new score to the leaderboard
            saveScore(playerData) {
                const scores = this.getScores();
                scores.push({
                    name: playerData.name || 'Anonymous',
                    score: playerData.score,
                    level: playerData.level,
                    timestamp: new Date().toISOString(),
                    playtime: playerData.playtime || '0s',
                    enemiesDefeated: playerData.enemiesDefeated || 0,
                    discosFired: playerData.discosFired || 0,
                    achievements: playerData.achievements || []
                });
                
                // Sort by score (highest first) and keep only top entries
                scores.sort((a, b) => b.score - a.score);
                const topScores = scores.slice(0, this.maxEntries);
                
                localStorage.setItem(this.storageKey, JSON.stringify(topScores));
                return topScores;
            },
            
            // Get all scores from localStorage
            getScores() {
                const stored = localStorage.getItem(this.storageKey);
                return stored ? JSON.parse(stored) : [];
            },
            
            // Check if current score qualifies for leaderboard
            isHighScore(score) {
                const scores = this.getScores();
                if (scores.length < this.maxEntries) return true;
                return score > scores[scores.length - 1].score;
            },
            
            // Check if this is truly a NEW high score (better than previous best)
            isNewHighScore(score) {
                const scores = this.getScores();
                if (scores.length === 0) return true; // First ever score
                return score > scores[0].score; // Beat the current #1 score
            },
            
            // Check if this qualifies for leaderboard AND we should show name input
            shouldShowNameInput(score) {
                const scores = this.getScores();
                
                // Don't show name input if player already provided their name
                if (playerName) return false;
                
                // Always show for first-time players (empty leaderboard)
                if (scores.length === 0) return true;
                
                // Show if leaderboard isn't full yet AND score qualifies
                if (scores.length < this.maxEntries && score > 0) return true;
                
                // Show only if this beats the lowest score on the board
                if (score > scores[scores.length - 1].score) return true;
                
                return false;
            },
            
            // Get player's rank for current score
            getRank(score) {
                const scores = this.getScores();
                let rank = 1;
                for (let i = 0; i < scores.length; i++) {
                    if (score > scores[i].score) break;
                    rank++;
                }
                return rank;
            },
            
            // Get motivational message based on current performance
            getComparisonMessage(currentScore) {
                const scores = this.getScores();
                if (scores.length === 0) return "First run! Set the bar high!";
                
                const topScore = scores[0];
                const rank = this.getRank(currentScore);
                
                if (currentScore > topScore.score) {
                    return `ðŸ”¥ NEW HIGH SCORE! Beating ${topScore.name}'s ${topScore.score}!`;
                } else if (rank <= 3) {
                    return `ðŸ¥‰ Top 3 run! Currently #${rank} on leaderboard!`;
                } else if (rank <= 5) {
                    return `â­ Top 5 performance! Rank #${rank}!`;
                } else if (currentScore > topScore.score * 0.5) {
                    return `ðŸ’ª Solid run! ${Math.round((currentScore/topScore.score)*100)}% of top score!`;
                } else {
                    return `ðŸŽ¯ Aim for ${topScore.name}'s record: ${topScore.score} ETHER!`;
                }
            },
            
            // Clear all scores (for testing/reset)
            clearScores() {
                localStorage.removeItem(this.storageKey);
            }
        };

        // LEADERBOARD UI FUNCTIONS
        function displayLeaderboard() {
            const modal = document.getElementById('leaderboard-modal');
            const content = document.getElementById('leaderboard-content');
            const scores = leaderboard.getScores();
            
            if (scores.length === 0) {
                content.innerHTML = `
                    <div style="text-align: center; color: #ffff00; font-size: 1.2em; padding: 40px;">
                        <p>ðŸ No races completed yet!</p>
                        <p style="font-size: 0.9em; color: #00ffff;">Be the first to set a record!</p>
                    </div>
                `;
            } else {
                let leaderboardHTML = `
                    <div style="background: rgba(0,0,0,0.3); border-radius: 10px; padding: 20px;">
                        <table style="width: 100%; border-collapse: collapse; color: white;">
                            <thead>
                                <tr style="border-bottom: 2px solid #00ffff;">
                                    <th style="padding: 10px; text-align: left; color: #ffff00;">Rank</th>
                                    <th style="padding: 10px; text-align: left; color: #ffff00;">Pilot</th>
                                    <th style="padding: 10px; text-align: center; color: #ffff00;">ETHER</th>
                                    <th style="padding: 10px; text-align: center; color: #ffff00;">Level</th>
                                    <th style="padding: 10px; text-align: center; color: #ffff00;">Enemies</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                scores.forEach((score, index) => {
                    const rank = index + 1;
                    let rankDisplay = `#${rank}`;
                    let rankColor = '#ffffff';
                    
                    if (rank === 1) {
                        rankDisplay = 'ðŸ¥‡';
                        rankColor = '#ffff00';
                    } else if (rank === 2) {
                        rankDisplay = 'ðŸ¥ˆ';
                        rankColor = '#c0c0c0';
                    } else if (rank === 3) {
                        rankDisplay = 'ðŸ¥‰';
                        rankColor = '#cd7f32';
                    }
                    
                    const date = new Date(score.timestamp);
                    const dateStr = date.toLocaleDateString();
                    
                    // For Player One, find the highest level achieved across all scores
                    let displayName = score.name;
                    if (score.name === "Player One") {
                        const playerOneScores = scores.filter(s => s.name === "Player One");
                        const highestLevel = Math.max(...playerOneScores.map(s => s.level));
                        displayName = `Player One - Highest Level: ${highestLevel}`;
                    }
                    
                    leaderboardHTML += `
                        <tr style="border-bottom: 1px solid #333; ${rank <= 3 ? 'background: rgba(255,255,0,0.1);' : ''}">
                            <td style="padding: 12px; color: ${rankColor}; font-weight: bold; font-size: 1.1em;">${rankDisplay}</td>
                            <td style="padding: 12px;">
                                <div style="font-weight: bold; color: #00ffff;">${displayName}</div>
                                <div style="font-size: 0.8em; color: #999;">${dateStr}</div>
                            </td>
                            <td style="padding: 12px; text-align: center; font-weight: bold; color: #00ff00;">${score.score.toLocaleString()}</td>
                            <td style="padding: 12px; text-align: center; color: #ffff00;">${score.level}</td>
                            <td style="padding: 12px; text-align: center; color: #ff8800;">${score.enemiesDefeated || 0}</td>
                        </tr>
                    `;
                });
                
                leaderboardHTML += `
                            </tbody>
                        </table>
                    </div>
                `;
                content.innerHTML = leaderboardHTML;
            }
            
            modal.style.display = 'block';
        }

        function showHighScoreModal(score, level) {
            // Automatically save score with "Player One" name
            const playerData = {
                name: playerName,
                score: score,
                level: level,
                playtime: calculatePlaytime(),
                enemiesDefeated: totalEnemiesDefeated,
                discosFired: totalDiscoProjectiles
            };
            
            leaderboard.saveScore(playerData);
            
            const rank = leaderboard.getRank(score);
            let rankMessage = `ðŸŽ‰ Score saved! You're rank #${rank}!`;
            
            if (rank === 1) {
                rankMessage = `ðŸ† NEW HIGH SCORE! You're #1! ðŸ†`;
            } else if (rank <= 3) {
                rankMessage = `ðŸŽ‰ Top 3! You're rank #${rank}! ðŸŽ‰`;
            } else if (rank <= 5) {
                rankMessage = `â­ Top 5! You're rank #${rank}! â­`;
            }
            
            // Show a congratulatory message
            setMessage(rankMessage);
        }

        function calculatePlaytime() {
            const playtimeMs = getAdjustedTime() - sessionStartTime;
            const minutes = Math.floor(playtimeMs / 60000);
            const seconds = Math.floor((playtimeMs % 60000) / 1000);
            return `${minutes}m ${seconds}s`;
        }

        // Initialize 3D Audio - DISABLED to prevent errors
        function initializeSpatialAudio() {
            // Spatial audio disabled - THREE.AudioBuffer constructor issues
            // Can be re-enabled when audio system is properly configured
            console.log("Spatial audio initialization skipped to prevent errors");
        }

        // Customization Functions
        function applySkinToMotorcycle(motorcycle, skinType) {
            const skinConfigs = {
                default: { color: 0x0077ff, metalness: 0.8, roughness: 0.2, emissive: 0x003366 },
                chrome: { color: 0xcccccc, metalness: 1.0, roughness: 0.0, emissive: 0x444444 },
                neon: { color: 0x00ffff, metalness: 0.3, roughness: 0.7, emissive: 0x00ffff },
                carbon: { color: 0x222222, metalness: 0.9, roughness: 0.1, emissive: 0x111111 },
                gold: { color: 0xffd700, metalness: 0.8, roughness: 0.2, emissive: 0xffaa00 }
            };
            
            const config = skinConfigs[skinType] || skinConfigs.default;
            
            motorcycle.children.forEach(child => {
                if (child.material && child.geometry && child.geometry.type === "BoxGeometry") {
                    child.material = new THREE.MeshStandardMaterial({
                        color: config.color,
                        metalness: config.metalness,
                        roughness: config.roughness,
                        emissive: config.emissive,
                        emissiveIntensity: 0.5
                    });
                }
            });
        }

                 function createTrailEffect(trailType) {
             const trailConfigs = {
                 default: { colors: [0x0077ff], intensity: 0.5, size: 0.3 },
                 rainbow: { colors: [0xff0000, 0xff8800, 0xffff00, 0x00ff00, 0x0088ff, 0x8800ff], intensity: 0.8, size: 0.4 },
                 electric: { colors: [0x00ffff, 0xffffff], intensity: 1.0, size: 0.5 },
                 force: { colors: [0xff00ff, 0x8800ff], intensity: 0.9, size: 0.6 },
                 fire: { colors: [0xff4400, 0xff8800, 0xffff00], intensity: 0.7, size: 0.4 }
             };
             
             const config = trailConfigs[trailType] || trailConfigs.default;
             
             // Create trail particles
             for (let i = 0; i < 3; i++) {
                 const trailGeometry = new THREE.SphereGeometry(config.size, 8, 8);
                 const trailMaterial = new THREE.MeshBasicMaterial({
                     color: config.colors[i % config.colors.length],
                     transparent: true,
                     opacity: config.intensity * 0.6,
                     blending: THREE.AdditiveBlending
                 });
                 
                 const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                 trail.position.set(
                     (Math.random() - 0.5) * 1.5,
                     Math.random() * 0.5,
                     1 + Math.random() * 2
                 );
                 
                 trail.userData.life = 0;
                 trail.userData.maxLife = 30;
                 trail.userData.velocity = new THREE.Vector3(
                     (Math.random() - 0.5) * 0.1,
                     (Math.random() - 0.5) * 0.1,
                     0.5
                 );
                 
                 playerMotorcycle.add(trail);
                 
                 setTimeout(() => {
                     playerMotorcycle.remove(trail);
                 }, 500);
             }
         }

         function applyRiderOutfit(outfitType) {
             const outfitConfigs = {
                 rebel: { 
                     bodyColor: 0x000000, 
                     headColor: 0x004400, 
                     bodyEmissive: 0x000000, 
                     headEmissive: 0x00ff00,
                     bodyEmissiveIntensity: 0.1,
                     headEmissiveIntensity: 0.8,
                     headTransparent: true,
                     headOpacity: 0.7
                 },
                 jedi: { 
                     bodyColor: 0x8B4513, 
                     headColor: 0xFFE4B5, 
                     bodyEmissive: 0x654321, 
                     headEmissive: 0x00ff00,
                     bodyEmissiveIntensity: 0.2,
                     headEmissiveIntensity: 0.6,
                     headTransparent: false,
                     headOpacity: 1.0
                 },
                 futuristic: { 
                     bodyColor: 0x333333, 
                     headColor: 0x00ffff, 
                     bodyEmissive: 0x00ffff, 
                     headEmissive: 0x00ffff,
                     bodyEmissiveIntensity: 0.3,
                     headEmissiveIntensity: 0.2,
                     headTransparent: false,
                     headOpacity: 1.0
                 },
                 force: { 
                     bodyColor: 0x4400ff, 
                     headColor: 0xff00ff, 
                     bodyEmissive: 0xff00ff, 
                     headEmissive: 0xff00ff,
                     bodyEmissiveIntensity: 0.3,
                     headEmissiveIntensity: 0.2,
                     headTransparent: false,
                     headOpacity: 1.0
                 },
                 force_user: { 
                     bodyColor: 0x2F2F2F, 
                     headColor: 0xff3333, 
                     bodyEmissive: 0x1a1a1a, 
                     headEmissive: 0xff3333,
                     bodyEmissiveIntensity: 0.2,
                     headEmissiveIntensity: 0.6,
                     headTransparent: false,
                     headOpacity: 1.0
                 },
                 pilot: { 
                     bodyColor: 0x654321, 
                     headColor: 0xffffff, 
                     bodyEmissive: 0xffaa00, 
                     headEmissive: 0xffaa00,
                     bodyEmissiveIntensity: 0.3,
                     headEmissiveIntensity: 0.2,
                     headTransparent: false,
                     headOpacity: 1.0
                 }
             };
             
             const config = outfitConfigs[outfitType] || outfitConfigs.rebel;
             
             if (playerRiderBody) {
                 playerRiderBody.material = new THREE.MeshStandardMaterial({
                     color: config.bodyColor,
                     metalness: 0.3,
                     roughness: 0.7,
                     emissive: config.bodyEmissive,
                     emissiveIntensity: config.bodyEmissiveIntensity
                 });
             }
             
             if (playerRiderHead) {
                 playerRiderHead.material = new THREE.MeshStandardMaterial({
                     color: config.headColor,
                     metalness: 0.1,
                     roughness: 0.1,
                     emissive: config.headEmissive,
                     emissiveIntensity: config.headEmissiveIntensity,
                     transparent: config.headTransparent,
                     opacity: config.headOpacity
                 });
             }
         }

         // Settings Menu Functions
         function toggleSettingsMenu() {
             const settingsMenu = document.getElementById('settings-menu');
             const isVisible = settingsMenu.style.display === 'block';
             
             if (isVisible) {
                 // Closing settings menu
                 settingsMenu.style.display = 'none';
                 // Resume game if it was running
                 if (isGameRunning && !isGameOver && gamePaused) {
                     gamePaused = false;
                     document.getElementById('pause-overlay').style.display = 'none';
                     animate(); // Resume game loop
                 }
             } else {
                 // Opening settings menu
                 settingsMenu.style.display = 'block';
                 updateSettingsDisplay();
                 // Auto-pause game if it's running
                 if (isGameRunning && !isGameOver && !gamePaused) {
                     gamePaused = true;
                     document.getElementById('pause-overlay').style.display = 'flex';
                 }
             }
         }

         function toggleGameInstructions() {
             const instructionsDiv = document.getElementById('game-instructions');
             const settingsMenu = document.getElementById('settings-menu');
             const isVisible = instructionsDiv.style.display === 'block';
 
             if (isVisible) {
                 // If instructions are visible, just hide them. Don't close the whole menu.
                 instructionsDiv.style.display = 'none';
             } else {
                 // If instructions are hidden, make sure the settings menu is open first, then show them.
                 settingsMenu.style.display = 'block';
                 instructionsDiv.style.display = 'block';
             }
         }

         function updateSettingsDisplay() {
             // Safely update customization displays only if elements exist
             const currentSkin = document.getElementById('current-skin');
             const currentTrail = document.getElementById('current-trail');
             const currentOutfit = document.getElementById('current-outfit');
             const miniSkin = document.getElementById('mini-skin');
             const miniTrail = document.getElementById('mini-trail');
             const miniOutfit = document.getElementById('mini-outfit');
             
             if (currentSkin) currentSkin.textContent = capitalizeFirst(customization.currentSkin);
             if (currentTrail) currentTrail.textContent = capitalizeFirst(customization.currentTrail);
             if (currentOutfit) currentOutfit.textContent = capitalizeFirst(customization.currentOutfit);
             if (miniSkin) miniSkin.textContent = capitalizeFirst(customization.currentSkin);
             if (miniTrail) miniTrail.textContent = capitalizeFirst(customization.currentTrail);
             if (miniOutfit) miniOutfit.textContent = capitalizeFirst(customization.currentOutfit);
         }

         function capitalizeFirst(str) {
             return str.charAt(0).toUpperCase() + str.slice(1);
         }

         function changeBikeSkin(direction) {
             const currentIndex = customization.bikeSkins.indexOf(customization.currentSkin);
             let newIndex;
             
             if (direction === 'next') {
                 newIndex = (currentIndex + 1) % customization.bikeSkins.length;
             } else {
                 newIndex = (currentIndex - 1 + customization.bikeSkins.length) % customization.bikeSkins.length;
             }
             
             customization.currentSkin = customization.bikeSkins[newIndex];
             applySkinToMotorcycle(playerMotorcycle, customization.currentSkin);
             updateSettingsDisplay();
             setMessage(`Bike skin: ${capitalizeFirst(customization.currentSkin)}`);
         }

         function changeTrailEffect(direction) {
             const currentIndex = customization.bikeTrails.indexOf(customization.currentTrail);
             let newIndex;
             
             if (direction === 'next') {
                 newIndex = (currentIndex + 1) % customization.bikeTrails.length;
             } else {
                 newIndex = (currentIndex - 1 + customization.bikeTrails.length) % customization.bikeTrails.length;
             }
             
             customization.currentTrail = customization.bikeTrails[newIndex];
             updateSettingsDisplay();
             setMessage(`Trail effect: ${capitalizeFirst(customization.currentTrail)}`);
         }

         function changeRiderOutfit(direction) {
             const currentIndex = customization.riderOutfits.indexOf(customization.currentOutfit);
             let newIndex;
             
             if (direction === 'next') {
                 newIndex = (currentIndex + 1) % customization.riderOutfits.length;
             } else {
                 newIndex = (currentIndex - 1 + customization.riderOutfits.length) % customization.riderOutfits.length;
             }
             
             customization.currentOutfit = customization.riderOutfits[newIndex];
             applyRiderOutfit(customization.currentOutfit);
             updateSettingsDisplay();
             setMessage(`Rider outfit: ${capitalizeFirst(customization.currentOutfit)}`);
         }

         function consumeGreenVial() {
             console.log("consumeGreenVial() called");
             // Play a collection sound
             coinSynth.triggerAttackRelease('A5', '8n', Tone.now(), 0.7);
             
             // Give ether bonus
             score += 25; // Give 25 ether for consuming green vial
             updateScoreDisplay();
             
             // Also give projectile power-up
             if (!hasProjectile) {
                 hasProjectile = true;
                 setMessage(`Green vial consumed! ++25 ETHER + Lightsaber Ready!`);
                 projectileSynth.triggerAttackRelease('G6', '8n'); // Play projectile ready sound
             } else {
                 setMessage(`Green vial consumed! ++25 ETHER bonus!`);
             }
             
             updatePowerUpDisplay(); // Update power-up display to show projectile
             
             // Create sparkle burst effect at player position
             createSparkleVialBurst(playerMotorcycle.position.clone());
         }

         function createSparkleVialBurst(position) {
             const burstCount = 15;
             for (let i = 0; i < burstCount; i++) {
                 const sparkleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                 const sparkleMaterial = new THREE.MeshBasicMaterial({
                     color: 0x00ff44,
                     emissive: 0x00ff44,
                     emissiveIntensity: 1.0,
                     transparent: true,
                     opacity: 1.0
                 });
                 const sparkle = new THREE.Mesh(sparkleGeometry, sparkleMaterial);
                 sparkle.position.copy(position);
                 sparkle.position.y += 1; // Slightly above ground
                 
                 // Random velocity for sparkles
                 const velocity = new THREE.Vector3(
                     (Math.random() - 0.5) * 0.4,
                     Math.random() * 0.3 + 0.1,
                     (Math.random() - 0.5) * 0.4
                 );
                 sparkle.userData.velocity = velocity;
                 sparkle.userData.life = 0;
                 sparkle.userData.maxLife = 60; // Frames
                 
                 scene.add(sparkle);
                 activeBursts.push(sparkle);
             }
         }

         // Pause/Resume Functions
         function togglePause() {
             if (!isGameRunning || isGameOver) return;
             
             gamePaused = !gamePaused;
             const pauseOverlay = document.getElementById('pause-overlay');
             
             if (gamePaused) {
                 // Record when pause started
                 pauseStartTime = Date.now();
                 // Cancel the current animation frame to truly pause
                 if (window.animationFrameId) {
                     cancelAnimationFrame(window.animationFrameId);
                     window.animationFrameId = null;
                 }
                 pauseOverlay.style.display = 'flex';
                 pauseOverlay.style.animation = 'pausePulse 2s infinite';
                 // Stop continuous audio when paused
                 stopAllEnhancedAudio();
             } else {
                 // Calculate how long we were paused and add to total
                 const pauseDuration = Date.now() - pauseStartTime;
                 totalPausedTime += pauseDuration;
                 
                 pauseOverlay.style.display = 'none';
                 // Resume the game loop and restart audio (only if enabled)
                 if (audioSystemEnabled) {
                     try {
                         startEngineSynth();
                         startAmbientMusic();
                     } catch(e) {
                         console.log("Audio restart after pause:", e);
                     }
                 }
                 // Only restart animation if it's not already running
                 if (!window.animationFrameId) {
                     animate();
                 }
             }
         }
         
         // NEW VISUAL & AUDIO ENHANCEMENT FUNCTIONS
         
         // 1. WORMHOLE HYPERSPACE EFFECT (Dark and mysterious)
         function triggerHyperspaceEffect() {
             if (hyperspaceActive) return;
             hyperspaceActive = true;
             
             // Dark wormhole effect with swirling distortion
             const wormholeOverlay = document.createElement('div');
             wormholeOverlay.style.position = 'fixed';
             wormholeOverlay.style.top = '0';
             wormholeOverlay.style.left = '0';
             wormholeOverlay.style.width = '100%';
             wormholeOverlay.style.height = '100%';
             wormholeOverlay.style.background = 'radial-gradient(ellipse at center, rgba(20,0,40,0.9) 0%, rgba(60,20,80,0.7) 30%, rgba(100,50,150,0.5) 60%, rgba(0,0,0,0.8) 100%)';
             wormholeOverlay.style.pointerEvents = 'none';
             wormholeOverlay.style.zIndex = '1000';
             wormholeOverlay.style.animation = 'wormholeSwirl 1.2s ease-in-out';
             document.body.appendChild(wormholeOverlay);
             
             // Add CSS animation for wormhole swirling effect
             if (!document.getElementById('wormhole-styles')) {
                 const wormholeStyles = document.createElement('style');
                 wormholeStyles.id = 'wormhole-styles';
                 wormholeStyles.textContent = `
                     @keyframes wormholeSwirl {
                         0% { 
                             transform: rotate(0deg) scale(0.1); 
                             opacity: 0;
                         }
                         30% { 
                             transform: rotate(180deg) scale(1.2); 
                             opacity: 0.9;
                         }
                         70% { 
                             transform: rotate(360deg) scale(1.0); 
                             opacity: 0.7;
                         }
                         100% { 
                             transform: rotate(540deg) scale(0.8); 
                             opacity: 0;
                         }
                     }
                 `;
                 document.head.appendChild(wormholeStyles);
             }
             
             // Create dark energy particles swirling inward
             for (let i = 0; i < 40; i++) {
                 const particle = new THREE.Mesh(
                     new THREE.SphereGeometry(0.008 + Math.random() * 0.012, 4, 4),
                     new THREE.MeshBasicMaterial({ 
                         color: Math.random() > 0.7 ? 0x8844ff : 0x442288,
                         transparent: true, 
                         opacity: 0.8,
                         emissive: Math.random() > 0.5 ? 0x220044 : 0x440088,
                         metalness: 0.2,
                         roughness: 0.8,                         emissiveIntensity: 0.6
                     })
                 );
                 
                 // Arrange particles in spiral pattern
                 const angle = (i / 40) * Math.PI * 4;
                 const radius = 15 + Math.random() * 10;
                 particle.position.set(
                     Math.cos(angle) * radius,
                     Math.sin(angle) * radius * 0.3,
                     playerMotorcycle.position.z - 5 - Math.random() * 15
                 );
                 
                 // Spiral inward velocity
                 particle.userData.velocity = new THREE.Vector3(
                     -Math.cos(angle) * 0.3,
                     -Math.sin(angle) * 0.1,
                     -2
                 );
                 particle.userData.life = 0;
                 particle.userData.maxLife = 50;
                 particle.userData.rotationSpeed = (Math.random() - 0.5) * 0.2;
                 scene.add(particle);
                 activeBursts.push(particle);
             }
             
             // Create central dark void effect
             const voidCore = new THREE.Mesh(
                 new THREE.SphereGeometry(2, 16, 16),
                 new THREE.MeshBasicMaterial({ 
                     color: 0x000000,
                     transparent: true,
                     opacity: 0.9,
                     side: THREE.DoubleSide
                 })
             );
             voidCore.position.set(0, 0, playerMotorcycle.position.z - 10);
             voidCore.userData.life = 0;
             voidCore.userData.maxLife = 60;
             voidCore.userData.isVoidCore = true;
             scene.add(voidCore);
             activeBursts.push(voidCore);
             

             
             setTimeout(() => {
                 wormholeOverlay.remove();
                 hyperspaceActive = false;
             }, 1200);
         }
         
         // 2. ETHER COLLECTION TRAILS
         function createEtherTrail(position) {
             for (let i = 0; i < 8; i++) {
                 const trail = new THREE.Mesh(
                     new THREE.SphereGeometry(0.03, 6, 6),
                     new THREE.MeshBasicMaterial({ 
                         color: 0xffff00, 
                         transparent: true, 
                         opacity: 0.7,
                         emissive: 0xffaa00,
                         metalness: 0.2,
                         roughness: 0.8,                         emissiveIntensity: 0.5
                     })
                 );
                 trail.position.copy(position);
                 trail.position.add(new THREE.Vector3(
                     (Math.random() - 0.5) * 0.5,
                     (Math.random() - 0.5) * 0.5,
                     Math.random() * 2
                 ));
                 trail.userData.velocity = new THREE.Vector3(0, 0, 1);
                 trail.userData.life = 0;
                 trail.userData.maxLife = 40;
                 scene.add(trail);
                 etherTrails.push(trail);
             }
         }
         
         // 3. MR. TERRIFIC'S DISCO GLOW
         function updateDiscoGlow() {
                         // Don't apply DISCO glow when in Radioactive mode (rider should stay pure white)
            if (isMagnetActive) {
                return; // Skip DISCO glow entirely during Radioactive mode
             }
             
             const hasPowerUp = hasProjectile || hasObstacleDrop || hasSwapPosition || isGhostActive || isSlowTimeActive;
             
             if (hasPowerUp && playerRiderHead) {
                 forcePowerActive = true;
                 const glowIntensity = 0.8 + Math.sin(Date.now() * 0.01) * 0.4;
                 playerRiderHead.material.emissiveIntensity = glowIntensity;
                 playerRiderHead.material.emissive.setHex(0x00ffff); // Cyan DISCO glow
             } else if (playerRiderHead && forcePowerActive) {
                 forcePowerActive = false;
                 playerRiderHead.material.emissiveIntensity = 0.8; // Reset to normal
                 playerRiderHead.material.emissive.setHex(0xff3333); // Keep red but dimmer
             }
         }
         
         // 4. DYNAMIC SPEED LINES
         function createSpeedLines() {
             if (typeof currentMoveSpeed === 'undefined') return; // Safety check
             const lineCount = Math.floor(currentMoveSpeed * 3); // Reduced from 5 to 3 for better performance
             for (let i = 0; i < lineCount && speedLines.length < 30; i++) { // Reduced from 50 to 30
                 const line = new THREE.Mesh(
                     new THREE.CylinderGeometry(0.01, 0.01, 3, 4),
                     new THREE.MeshBasicMaterial({ 
                         color: 0x0088ff, 
                         transparent: true, 
                         opacity: 0.3 
                     })
                 );
                 line.position.set(
                     (Math.random() - 0.5) * 30,
                     (Math.random() - 0.5) * 15,
                     playerMotorcycle.position.z - 20 - Math.random() * 50
                 );
                 line.rotation.x = Math.PI / 2; // Make lines horizontal
                 line.userData.speed = currentMoveSpeed + Math.random() * 2;
                 scene.add(line);
                 speedLines.push(line);
             }
         }
         
         // 5. ENGINE SOUND SCALING
         function updateEngineSound() {
             if (audioSystemEnabled && engineSynth && engineSynth.state === 'started' && typeof currentMoveSpeed !== 'undefined' && isGameRunning && !isGameOver) {
                 try {
                     const baseFreq = 60;
                     const speedMultiplier = currentMoveSpeed / initialBaseMoveSpeed;
                     const newFreq = Math.max(40, Math.min(120, baseFreq + (speedMultiplier * 40))); // Clamp frequency
                     engineSynth.frequency.value = newFreq;
                     
                     const volume = isBoosting ? -15 : -20;
                     engineSynth.volume.value = volume;
                 } catch(e) {
                     console.log("Engine sound update error:", e);
                 }
             }
         }
         
         // 6. AMBIENT STAR WARS MUSIC
         function startAmbientMusic() {
             if (!ambientMusicActive && audioSystemEnabled) {
                 ambientMusicActive = true;
                 // Create a simple Star Wars-like ambient melody
                 const melody = ['C4', 'G4', 'F4', 'E4', 'D4', 'C5', 'G4'];
                 let noteIndex = 0;
                 
                 // Clear any existing interval first
                 if (ambientMusicInterval) {
                     clearInterval(ambientMusicInterval);
                 }
                 
                 ambientMusicInterval = setInterval(() => {
                     if (ambientMusicActive && audioSystemEnabled && isGameRunning && !isGameOver) {
                         ambientSynth.triggerAttackRelease(melody[noteIndex], '2n');
                         noteIndex = (noteIndex + 1) % melody.length;
                     }
                 }, 4000); // Play a note every 4 seconds
             }
         }
         
         // Stop ambient music properly
         function stopAmbientMusic() {
             ambientMusicActive = false;
             if (ambientMusicInterval) {
                 clearInterval(ambientMusicInterval);
                 ambientMusicInterval = null;
             }
         }
         
                 // Stop all enhanced audio systems
        function stopAllEnhancedAudio() {
            // Stop engine synth
            if (engineSynth && engineSynth.state === 'started') {
                try {
                    engineSynth.stop();
                } catch(e) {
                    console.log("Engine synth stop error:", e);
                }
            }
            
            // Stop boost sound if it's playing
            if (boostSound.state === 'started') {
                try {
                    boostSound.stop();
                } catch(e) {
                    console.log("Boost sound stop error:", e);
                }
            }
            
            // Stop ambient music
            stopAmbientMusic();
        }
        
        // Safe engine synth start (prevents multiple starts)
        function startEngineSynth() {
            if (audioSystemEnabled && engineSynth && engineSynth.state !== 'started') {
                try {
                    engineSynth.start();
                } catch(e) {
                    console.log("Engine synth start error:", e);
                }
            }
        }
        
        // Toggle audio system on/off
        function toggleAudioSystem() {
            audioSystemEnabled = !audioSystemEnabled;
            
            if (audioSystemEnabled) {
                console.log("ðŸŽµ AUDIO SYSTEM ENABLED - Sound ON");
                setMessage("ðŸŽµ Audio System: ON (Press 'M' to disable)");
                
                // Start enhanced audio systems if game is running
                if (isGameRunning && !isGameOver && !gamePaused) {
                    try {
                        startEngineSynth();
                        startAmbientMusic();
                    } catch(e) {
                        console.log("Audio system start error:", e);
                    }
                }
            } else {
                console.log("ðŸ”‡ AUDIO SYSTEM DISABLED - Sound OFF");
                // Audio message removed
                stopAllEnhancedAudio();
            }
            
            // Update audio status display
            updateAudioStatusDisplay();
        }
        
        // Stop all audio function
        function stopAllEnhancedAudio() {
            // Stop engine synth
            if (engineSynth && engineSynth.state === 'started') {
                try {
                    engineSynth.stop();
                } catch(e) {
                    console.log("Engine synth stop error:", e);
                }
            }
            
            // Stop boost sound if it's playing
            if (boostSound.state === 'started') {
                try {
                    boostSound.stop();
                } catch(e) {
                    console.log("Boost sound stop error:", e);
                }
            }
            
            // Stop ambient music
            stopAmbientMusic();
        }
        
                 // Audio status display removed - no longer needed
         function updateAudioStatusDisplay() {
             // Audio status display removed - no longer needed
         }
         
         // SESSION STATS FUNCTIONS
         function resetSessionStats() {
             sessionStats.distanceTraveled = 0;
             sessionStats.enemiesDefeated = 0;
             sessionStats.etherCollected = 0;
             sessionStats.startTime = Date.now();
             sessionStats.sessionTime = 0;
             sessionStats.maxSpeed = 0;
             sessionStats.hyperspaceJumps = 0;
             sessionStats.powerUpsUsed = 0;
         }
         
         function updateSessionStats() {
             // Update distance traveled (based on move speed)
             if (typeof currentMoveSpeed !== 'undefined') {
                 sessionStats.distanceTraveled += currentMoveSpeed * 0.1; // Scale factor for realistic units
                 sessionStats.maxSpeed = Math.max(sessionStats.maxSpeed, currentMoveSpeed);
             }
         }
         
         function trackEnemyDefeat() {
             sessionStats.enemiesDefeated++;
             totalEnemiesDefeated++; // Track for leaderboard
         }
         
         function trackEtherCollection() {
             sessionStats.etherCollected++;
         }
         
         function trackHyperspaceJump() {
             sessionStats.hyperspaceJumps++;
         }
         
         function trackPowerUpUsed() {
             sessionStats.powerUpsUsed++;
         }
         
         function formatTime(milliseconds) {
             const minutes = Math.floor(milliseconds / 60000);
             const seconds = Math.floor((milliseconds % 60000) / 1000);
             return `${minutes}:${seconds.toString().padStart(2, '0')}`;
         }
         
         function formatDistance(distance) {
             return `${Math.floor(distance)} parsecs`;
         }
         
         function populateMissionStats() {
             // Format session stats
             const sessionTimeFormatted = formatTime(sessionStats.sessionTime);
             const distanceFormatted = formatDistance(sessionStats.distanceTraveled);
             
             // Populate the stats in the unified game over screen
             document.getElementById('stat-time').textContent = sessionTimeFormatted;
             document.getElementById('stat-distance').textContent = distanceFormatted;
             document.getElementById('stat-ether').textContent = sessionStats.etherCollected;
             document.getElementById('stat-enemies').textContent = sessionStats.enemiesDefeated;
             document.getElementById('stat-powerups').textContent = sessionStats.powerUpsUsed;
             document.getElementById('stat-jumps').textContent = sessionStats.hyperspaceJumps;
             document.getElementById('stat-speed').textContent = `Mach ${sessionStats.maxSpeed.toFixed(1)}`;
         }
         
         // 7. ENHANCED COLLISION SOUNDS
         function playCollisionSound(type = 'normal') {
             if (!audioSystemEnabled) return; // No sound if audio disabled
             
             switch(type) {
                 case 'obstacle':
                     crashNoise.triggerAttackRelease("16n", Tone.now(), 0.8);
                     break;
                 case 'enemy':
                     explosionSynth.triggerAttackRelease("8n", Tone.now(), 0.6);
                     break;
                 case 'powerup':
                     forceSynth.triggerAttackRelease('E5', '8n');
                     break;
                 default:
                     crashNoise.triggerAttackRelease("32n", Tone.now(), 0.5);
             }
         }

         function handleScreenTap(event) {
             // Disable pause on mobile devices
             if (isMobileDevice()) {
                 return;
             }
             
             // Don't pause if clicking on UI elements
             const target = event.target;
             if (target.tagName === 'BUTTON' || 
                 target.closest('#settings-menu') || 
                 target.closest('.overlay') ||
                 target.closest('.game-footer') ||
                 target.closest('#boost-button') ||
                 target.closest('#blaster-button') ||
                 target.closest('#use-power-up-button') ||
                 target.closest('.mobile-controls')) {
                 return;
             }
             
             // Don't pause if settings menu is open
             const settingsMenu = document.getElementById('settings-menu');
             if (settingsMenu.style.display === 'block') {
                 return;
             }
             
             // Only toggle pause during active gameplay
             if (isGameRunning && !isGameOver) {
                 togglePause();
             }
         }

        // Cinematic Camera System
        function activateCinematicCamera(type, target = null) {
            cinematicCamera.active = true;
            cinematicCamera.type = type;
            cinematicCamera.timer = 0;
            
            // Enable cinematic invulnerability
            isCinematicInvulnerable = true;
            setMessage("ðŸŽ¬ Cinematic Mode - You are invulnerable!");
            
            // Add subtle glow effect to indicate invulnerability
            if (playerMotorcycle) {
                playerMotorcycle.children.forEach(child => {
                    if (child.material) {
                        child.material.emissiveIntensity = 0.8;
                    }
                });
            }
            
            // Store current camera position/rotation
            cinematicCamera.originalPosition.copy(camera.position);
            cinematicCamera.originalRotation.copy(camera.rotation);
            
            switch (type) {
                case 'levelUp':
                    cinematicCamera.duration = 180; // 3 seconds
                    cinematicCamera.targetPosition.set(
                        playerMotorcycle.position.x,
                        playerMotorcycle.position.y + 8,
                        playerMotorcycle.position.z - 5
                    );
                    break;
                    
                case 'tieFighter':
                    cinematicCamera.duration = 360; // 6 seconds for more drama
                    if (target) {
                        // Start with a wide sweeping angle
                        cinematicCamera.targetPosition.set(
                            target.position.x + 15,
                            target.position.y + 12,
                            target.position.z + 20
                        );
                        // Add camera shake for dramatic effect
                        triggerCameraShake(2.0, 2000);
                        // Enhance all dragon segments for dramatic effect
                        target.userData.segments.forEach(segment => {
                            if(segment.material.emissive) {
                                segment.material.emissiveIntensity = 4.0; // Maximum glow
                            }
                        });
                    }
                    break;
                    
                case 'boost':
                    cinematicCamera.duration = 120; // 2 seconds
                    cinematicCamera.targetPosition.set(
                        playerMotorcycle.position.x,
                        playerMotorcycle.position.y + 2,
                        playerMotorcycle.position.z + 8
                    );
                    break;
                    
                case 'crash':
                    cinematicCamera.duration = 150; // 2.5 seconds
                    cinematicCamera.targetPosition.set(
                        playerMotorcycle.position.x + 5,
                        playerMotorcycle.position.y + 3,
                        playerMotorcycle.position.z + 2
                    );
                    break;
            }
        }

        function updateCinematicCamera() {
            if (!cinematicCamera.active) return;
            
            cinematicCamera.timer++;
            const progress = cinematicCamera.timer / cinematicCamera.duration;
            
            if (progress >= 1) {
                // End cinematic camera
                cinematicCamera.active = false;
                // Disable cinematic invulnerability when normal view is restored
                isCinematicInvulnerable = false;
                
                // Remove glow effect
                if (playerMotorcycle) {
                    playerMotorcycle.children.forEach(child => {
                        if (child.material) {
                            child.material.emissiveIntensity = 0.5; // Return to normal
                        }
                    });
                }

                if (cinematicCamera.type === 'tieFighter') {
                    // After cinematic ends, position stronghold for optimal visibility
                    if (dragons.length > 0) {
                        const stronghold = dragons[0];
                        // Position slightly behind and above player for dramatic effect
                        stronghold.position.set(
                            playerMotorcycle.position.x + (Math.random() - 0.5) * 6, // Slight side offset
                            playerMotorcycle.position.y + 6, // Above player
                            playerMotorcycle.position.z - 25 // Close behind for immediate threat
                        );
                        setMessage("ðŸŽ¯ Stronghold locked onto your position!");
                    }
                    
                    // Give boost on level 10 for dramatic chase
                    if (level === 10) {
                        activateBoost(3000, false);
                    }
                }
                
                return;
            }
            
            // Smooth interpolation
            const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease out cubic
            
            switch (cinematicCamera.type) {
                case 'levelUp':
                    // Spiral around player
                    const radius = 8;
                    const angle = progress * Math.PI * 2;
                    camera.position.set(
                        playerMotorcycle.position.x + Math.cos(angle) * radius,
                        playerMotorcycle.position.y + 5 + Math.sin(progress * Math.PI) * 3,
                        playerMotorcycle.position.z + Math.sin(angle) * radius
                    );
                    camera.lookAt(playerMotorcycle.position);
                    break;
                    
                case 'tieFighter':
                    // DRAMATIC SWEEPING CINEMATIC
                    if (dragons.length > 0) {
                        const dragon = dragons[0];
                        const phase = progress * Math.PI * 2; // Full rotation over duration
                        
                        // Sweeping circular motion around the dragon
                        const radius = 25 - (progress * 10); // Start far, move closer
                        const height = 15 - (progress * 5); // Start high, descend
                        
                        camera.position.set(
                            dragon.position.x + Math.cos(phase) * radius,
                            dragon.position.y + height + Math.sin(progress * Math.PI) * 3,
                            dragon.position.z + Math.sin(phase) * radius
                        );
                        
                        // Always look at the dragon for maximum drama
                        camera.lookAt(dragon.position);
                        
                        // Add dramatic lighting flashes
                        if (Math.random() < 0.1) {
                            createLightningStrike();
                        }
                    }
                    break;
                    
                case 'boost':
                    // Close follow cam
                    const offset = new THREE.Vector3(0, 2, 8);
                    const targetPos = playerMotorcycle.position.clone().add(offset);
                    camera.position.lerp(targetPos, 0.1);
                    camera.lookAt(playerMotorcycle.position);
                    break;
                    
                case 'crash':
                    // Slow motion effect
                    camera.position.lerp(cinematicCamera.targetPosition, 0.03);
                    camera.lookAt(playerMotorcycle.position);
                    break;
            }
        }
        
        // CAMERA SHAKE SYSTEM FUNCTIONS
        function triggerCameraShake(intensity, duration) {
            cameraShake.active = true;
            cameraShake.intensity = intensity;
            cameraShake.duration = duration;
            cameraShake.timer = 0;
        }
        
        function updateCameraShake() {
            if (!cameraShake.active) return;
            
            cameraShake.timer += 16; // Assuming 60fps (16ms per frame)
            const progress = cameraShake.timer / cameraShake.duration;
            
            if (progress >= 1.0) {
                // End camera shake
                cameraShake.active = false;
                cameraShake.offsetX = 0;
                cameraShake.offsetY = 0;
                cameraShake.offsetZ = 0;
                return;
            }
            
            // Calculate shake intensity with decay over time
            const currentIntensity = cameraShake.intensity * (1.0 - progress);
            
            // Generate random shake offsets
            cameraShake.offsetX = (Math.random() - 0.5) * currentIntensity;
            cameraShake.offsetY = (Math.random() - 0.5) * currentIntensity;
            cameraShake.offsetZ = (Math.random() - 0.5) * currentIntensity * 0.5; // Less Z movement
            
            // Apply shake to camera position
            camera.position.x += cameraShake.offsetX;
            camera.position.y += cameraShake.offsetY;
            camera.position.z += cameraShake.offsetZ;
        }

        // Weather System Functions
        function initializeWeather() {
            // Create rain particle system
            const rainCount = 1000;
            const rainPositions = new Float32Array(rainCount * 3);
            const rainVelocities = new Float32Array(rainCount * 3);
            
            for (let i = 0; i < rainCount; i++) {
                const i3 = i * 3;
                rainPositions[i3] = (Math.random() - 0.5) * 200;     // x
                rainPositions[i3 + 1] = Math.random() * 100 + 50;   // y
                rainPositions[i3 + 2] = (Math.random() - 0.5) * 200; // z
                
                rainVelocities[i3] = (Math.random() - 0.5) * 2;     // x velocity
                rainVelocities[i3 + 1] = -10 - Math.random() * 5;   // y velocity (falling)
                rainVelocities[i3 + 2] = (Math.random() - 0.5) * 2; // z velocity
            }
            
            weather.rainGeometry = new THREE.BufferGeometry();
            weather.rainGeometry.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
            weather.rainGeometry.userData.velocities = rainVelocities;
            
            weather.rainMaterial = new THREE.PointsMaterial({
                color: 0x87ceeb,
                size: 0.5,
                transparent: true,
                opacity: 0
            });
            
            weather.rainMesh = new THREE.Points(weather.rainGeometry, weather.rainMaterial);
            scene.add(weather.rainMesh);
        }

        function updateWeather() {
            if (!isGameRunning) return;

            // Only have weather in levels 5-25
            if (level < 5 || level > 25) {
                weather.current = 'clear';
                weather.intensity = Math.max(0, weather.intensity - 0.02);
                if (weather.rainMaterial) {
                    weather.rainMaterial.opacity = weather.intensity * 0.8;
                }
                return;
            }

            weather.changeTimer++;
            
            // Change weather periodically
            if (weather.changeTimer >= weather.changeInterval) {
                const weatherTypes = ['clear', 'rain', 'storm'];
                const oldWeather = weather.current;
                weather.current = weatherTypes[Math.floor(Math.random() * weatherTypes.length)];
                weather.changeTimer = 0;
                
                if (weather.current !== oldWeather) {
                    setMessage(`Weather changing to ${weather.current}!`);
                }
            }

            // Update weather effects
            switch (weather.current) {
                case 'clear':
                    weather.intensity = Math.max(0, weather.intensity - 0.01);
                    break;
                case 'rain':
                    weather.intensity = Math.min(0.7, weather.intensity + 0.02);
                    updateRain();
                    break;
                case 'storm':
                    weather.intensity = Math.min(1.0, weather.intensity + 0.03);
                    updateRain();
                    updateStorm();
                    break;
            }

            // Update rain opacity
            if (weather.rainMaterial) {
                weather.rainMaterial.opacity = weather.intensity * 0.8;
            }

            // Weather affects gameplay
            if (weather.current === 'rain') {
                // Reduce traction slightly in rain
                steerSpeed *= 0.95;
            } else if (weather.current === 'storm') {
                // Storms reduce visibility and control
                steerSpeed *= 0.9;
                // Add random steering disruption
                if (Math.random() < 0.02) {
                    targetSteerAngle += (Math.random() - 0.5) * 0.1;
                }
            }
        }

        function updateRain() {
            if (!weather.rainMesh) return;

            const positions = weather.rainGeometry.attributes.position.array;
            const velocities = weather.rainGeometry.userData.velocities;
            
            for (let i = 0; i < positions.length; i += 3) {
                // Update positions
                positions[i] += velocities[i] * weather.intensity;
                positions[i + 1] += velocities[i + 1] * weather.intensity;
                positions[i + 2] += velocities[i + 2] * weather.intensity;
                
                // Reset particles that fall too low
                if (positions[i + 1] < -10) {
                    positions[i] = (Math.random() - 0.5) * 200;
                    positions[i + 1] = 100;
                    positions[i + 2] = (Math.random() - 0.5) * 200;
                }
            }
            
            weather.rainGeometry.attributes.position.needsUpdate = true;
            
            // Move rain with player
            weather.rainMesh.position.z = playerMotorcycle.position.z;
        }

        function updateStorm() {
            weather.stormTimer++;
            
            // Create lightning flashes during storms
            if (weather.stormTimer % 180 === 0 && Math.random() < 0.3) {
                createLightningStrike();
                // Thunder sound
                crashNoise.triggerAttackRelease("1n", Tone.now() + 0.5, 0.3);
            }
        }

        // Star Wars Quotes Visualization
        function createFloatingQuote() {
            const quote = starWarsQuotes[Math.floor(Math.random() * starWarsQuotes.length)];
            
            // Create canvas for equation text
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            
            // Style the text
            context.fillStyle = 'rgba(0, 255, 255, 0.8)';
            context.font = 'bold 48px "Times New Roman", serif';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Add glow effect
            context.shadowColor = '#00ffff';
            context.shadowBlur = 10;
            context.fillText(quote, 256, 64);
            
            // Create texture and material
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            
            // Create mesh
            const geometry = new THREE.PlaneGeometry(8, 2);
            const mesh = new THREE.Mesh(geometry, material);
            
            // Position randomly around the track
            mesh.position.set(
                (Math.random() - 0.5) * 30,
                5 + Math.random() * 10,
                playerMotorcycle.position.z - 50 - Math.random() * 100
            );
            
            // Add rotation for dynamic movement
            mesh.userData.rotationSpeed = (Math.random() - 0.5) * 0.02;
            mesh.userData.floatSpeed = 0.01 + Math.random() * 0.02;
            mesh.userData.life = 0;
            mesh.userData.maxLife = 600; // 10 seconds at 60fps
            
            scene.add(mesh);
            floatingQuotes.push(mesh);
        }

        function updateFloatingQuotes() {
            // Spawn new equations periodically
            if (Math.random() < 0.008 && floatingQuotes.length < 8) {
                createFloatingQuote();
            }
            
            // Update existing equations
            for (let i = floatingQuotes.length - 1; i >= 0; i--) {
                const quote = floatingQuotes[i];
                quote.userData.life++;
                
                // Floating motion
                quote.position.y += Math.sin(quote.userData.life * quote.userData.floatSpeed) * 0.02;
                quote.rotation.y += quote.userData.rotationSpeed;
                
                // Fade out over time
                const progress = quote.userData.life / quote.userData.maxLife;
                quote.material.opacity = 0.8 * (1 - progress);
                
                // Remove when expired
                if (quote.userData.life >= quote.userData.maxLife) {
                    scene.remove(quote);
                    floatingQuotes.splice(i, 1);
                }
                
                // Remove if too far behind player
                if (quote.position.z > playerMotorcycle.position.z + 50) {
                    scene.remove(quote);
                    floatingQuotes.splice(i, 1);
                }
            }
        }

        // --- Particle Animation Script DISABLED ---
        // Particle system removed for cleaner TRONS aesthetic
        let particleAnimationActive = false;
        let particlesArray;
        // Particle object properties - DISABLED
        class Particle {
            constructor() { return; }
            draw() { return; }
            update() { return; }
        }
        function initParticles() {
            // Particle system disabled
            return;
        }
        function animateParticles() {
            // Particle system disabled
            return;
        }
        function showParticleBackground() {
            // Particle system disabled for cleaner TRONS look
        }
        function hideParticleBackground() {
            // Particle system disabled for cleaner TRONS look
        }
        // Particle resize handler disabled
        // function updateParticleBackgroundVisibility disabled
        // All particle background logic disabled for TRONS
    </script>

    <!-- Firebase Initialization Script -->
    <script>
        // Global Firebase variables for game persistence
        let db = null;
        let auth = null;
        let userId = null;
        
        // Circuit breaker for Firebase operations
        let firebaseFailureCount = 0;
        let firebaseCircuitBreakerOpen = false;
        let lastFirebaseAttempt = 0;
        
        // Your actual Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyBIHOzCZ3XwxDLLNHuB88zBppPQ7YFNqp0",
            authDomain: "cyphes-bf0ff.firebaseapp.com",
            projectId: "cyphes-bf0ff",
            storageBucket: "cyphes-bf0ff.firebasestorage.app",
            messagingSenderId: "257882444109",
            appId: "1:257882444109:web:20ca44cd773910731da704",
            measurementId: "G-L8CD8SEET2"
        };

        // Initialize Firebase when the page loads
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                console.log('Initializing Firebase...');
                
                // Initialize Firebase app
                const app = window.firebase.initializeApp(firebaseConfig);
                
                // Get Firebase services
                auth = window.firebase.getAuth(app);
                db = window.firebase.getFirestore(app);
                
                // Handle analytics separately as it may fail
                try {
                    const analytics = window.firebase.getAnalytics(app);
                } catch (analyticsError) {
                    console.warn('Analytics initialization failed, continuing without it:', analyticsError);
                }
                
                // Set up authentication state listener
                window.firebase.onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log('User signed in:', userId);
                        
                        // Firebase is ready - you can now use db, auth, and userId in your game
                        if (typeof onFirebaseReady === 'function') {
                            onFirebaseReady();
                        }
                        
                        // Dispatch custom event for game to listen to
                        window.dispatchEvent(new CustomEvent('firebaseReady', { 
                            detail: { db, auth, userId } 
                        }));
                    } else {
                        console.log('No user signed in, trying anonymous auth...');
                        try {
                            await window.firebase.signInAnonymously(auth);
                        } catch (authError) {
                            console.warn('Anonymous authentication failed, continuing without Firebase:', authError);
                            // Continue without authentication - game will work in offline mode
                            handleFirebaseFailure();
                            // Still dispatch event so game doesn't wait forever
                            window.dispatchEvent(new CustomEvent('firebaseReady', { 
                                detail: { db: null, auth: null, userId: null } 
                            }));
                        }
                    }
                });
                
            } catch (error) {
                console.error('Firebase initialization error, continuing without Firebase:', error);
                handleFirebaseFailure();
                // Ensure game continues without Firebase
                window.dispatchEvent(new CustomEvent('firebaseReady', { 
                    detail: { db: null, auth: null, userId: null } 
                }));
            }
        });
        
        // Helper function to check if Firebase is ready
        function isFirebaseReady() {
            return db !== null && auth !== null && userId !== null && !firebaseCircuitBreakerOpen;
        }
        
        // Circuit breaker logic
        function handleFirebaseFailure() {
            firebaseFailureCount++;
            lastFirebaseAttempt = Date.now();
            
            if (firebaseFailureCount >= 3) {
                firebaseCircuitBreakerOpen = true;
                console.warn('Firebase circuit breaker opened - too many failures, disabling for 60 seconds');
                
                setTimeout(() => {
                    firebaseCircuitBreakerOpen = false;
                    firebaseFailureCount = 0;
                    console.log('Firebase circuit breaker reset - re-enabling');
                }, 60000); // 60 second cooldown
            }
        }
        
        function handleFirebaseSuccess() {
            firebaseFailureCount = 0; // Reset failure count on success
        }
        
        // Backup mechanism: If Firebase takes too long to initialize, continue without it
        setTimeout(() => {
            if (!isFirebaseReady()) {
                console.warn('Firebase initialization taking too long, continuing without persistence');
                // Allow game to continue even without Firebase
                if (typeof score === 'undefined') {
                    score = 0;
                    if (scoreDisplay) scoreDisplay.textContent = 'ETHER: ' + score;
                }
            }
        }, 10000); // 10 second backup timeout
        
        // Helper function for game to wait for Firebase
        function waitForFirebase() {
            return new Promise((resolve) => {
                if (isFirebaseReady()) {
                    resolve({ db, auth, userId });
                } else {
                    window.addEventListener('firebaseReady', (event) => {
                        resolve(event.detail);
                    }, { once: true });
                }
            });
        }
        
        // Save session score to player's persistent ether in Firestore
        async function savePersistentScore(sessionScore) {
            if (!isFirebaseReady() || sessionScore <= 0) {
                console.log('Firebase not ready, circuit breaker open, or no score to save');
                return;
            }
            
            try {
                // Add timeout to prevent hanging
                const savePromise = async () => {
                    const playerDocRef = window.firebase.doc(db, 'players', userId);
                    const playerDoc = await window.firebase.getDoc(playerDocRef);
                    
                    let currentEther = 0;
                    if (playerDoc.exists()) {
                        const data = playerDoc.data();
                        currentEther = data.ether || 0;
                    }
                    
                    const newTotalEther = currentEther + sessionScore;
                    
                    await window.firebase.setDoc(playerDocRef, {
                        ether: newTotalEther,
                        lastPlayed: new Date().toISOString(),
                        totalSessions: (playerDoc.exists() ? (playerDoc.data().totalSessions || 0) + 1 : 1)
                    }, { merge: true });
                    
                    console.log(`Session score ${sessionScore} added to persistent ether. Total: ${newTotalEther}`);
                    handleFirebaseSuccess();
                };
                
                // 3 second timeout for save operation (reduced)
                await Promise.race([
                    savePromise(),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Save timeout')), 3000))
                ]);
                
            } catch (error) {
                console.error('Error saving persistent score (game will continue):', error);
                handleFirebaseFailure();
                // Don't let save errors break the game flow
            }
        }
        
        // Load persistent ether score from Firestore
        async function loadPersistentScore() {
            if (!isFirebaseReady()) {
                console.log('Firebase not ready or circuit breaker open, starting with score 0');
                score = 0;
                scoreDisplay.textContent = 'ETHER: ' + score;
                return;
            }
            
            try {
                // Add timeout to prevent hanging on load
                const loadPromise = async () => {
                    const playerDocRef = window.firebase.doc(db, 'players', userId);
                    const playerDoc = await window.firebase.getDoc(playerDocRef);
                    
                    if (playerDoc.exists()) {
                        const data = playerDoc.data();
                        score = data.ether || 0;
                        console.log(`Loaded persistent ether: ${score}`);
                    } else {
                        // First time player - start with 0
                        score = 0;
                        console.log('New player - starting with 0 ether');
                    }
                    handleFirebaseSuccess();
                };
                
                // 2 second timeout for load operation (reduced)
                await Promise.race([
                    loadPromise(),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Load timeout')), 2000))
                ]);
                
                scoreDisplay.textContent = 'ETHER: ' + score;
                
            } catch (error) {
                console.error('Error loading persistent score (using fallback):', error);
                handleFirebaseFailure();
                // Fallback to 0 if there's an error
                score = 0;
                scoreDisplay.textContent = 'ETHER: ' + score;
            }
        }
    </script>
</body>
</html>

